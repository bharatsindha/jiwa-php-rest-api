<?php
/**
 * JournalSetsApi
 * PHP version 5
 *
 * @category Class
 * @package  Jiwa
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * JiwaAPI
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.28-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Jiwa\JiwaAPI;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Jiwa\ApiException;
use Jiwa\Configuration;
use Jiwa\HeaderSelector;
use Jiwa\ObjectSerializer;

/**
 * JournalSetsApi Class Doc Comment
 *
 * @category Class
 * @package  Jiwa
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class JournalSetsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation journalSetABANDONRequestAbandonDelete
     *
     * Abandons a stateful journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id journal_set_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function journalSetABANDONRequestAbandonDelete($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        list($response) = $this->journalSetABANDONRequestAbandonDeleteWithHttpInfo($accept, $jiwa_stateful, $journal_set_id);
        return $response;
    }

    /**
     * Operation journalSetABANDONRequestAbandonDeleteWithHttpInfo
     *
     * Abandons a stateful journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetABANDONRequestAbandonDeleteWithHttpInfo($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful, $journal_set_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetABANDONRequestAbandonDeleteAsync
     *
     * Abandons a stateful journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetABANDONRequestAbandonDeleteAsync($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        return $this->journalSetABANDONRequestAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful, $journal_set_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetABANDONRequestAbandonDeleteAsyncWithHttpInfo
     *
     * Abandons a stateful journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetABANDONRequestAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful, $journal_set_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetABANDONRequestAbandonDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetABANDONRequestAbandonDelete'
            );
        }

        $resourcePath = '/JournalSets/Abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($journal_set_id !== null) {
            $queryParams['JournalSetID'] = ObjectSerializer::toQueryValue($journal_set_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDELETERequestJournalSetIDDelete
     *
     * Deletes a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function journalSetDELETERequestJournalSetIDDelete($accept, $journal_set_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetDELETERequestJournalSetIDDeleteWithHttpInfo($accept, $journal_set_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetDELETERequestJournalSetIDDeleteWithHttpInfo
     *
     * Deletes a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDELETERequestJournalSetIDDeleteWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetDELETERequestJournalSetIDDeleteRequest($accept, $journal_set_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDELETERequestJournalSetIDDeleteAsync
     *
     * Deletes a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDELETERequestJournalSetIDDeleteAsync($accept, $journal_set_id, $jiwa_stateful = null)
    {
        return $this->journalSetDELETERequestJournalSetIDDeleteAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDELETERequestJournalSetIDDeleteAsyncWithHttpInfo
     *
     * Deletes a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDELETERequestJournalSetIDDeleteAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetDELETERequestJournalSetIDDeleteRequest($accept, $journal_set_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDELETERequestJournalSetIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDELETERequestJournalSetIDDeleteRequest($accept, $journal_set_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDELETERequestJournalSetIDDelete'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetDELETERequestJournalSetIDDelete'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDelete
     *
     * Deletes a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDelete($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteWithHttpInfo
     *
     * Deletes a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteRequest($accept, $journal_set_id, $document_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteAsync
     *
     * Deletes a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteAsync($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        return $this->journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteAsyncWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteAsyncWithHttpInfo
     *
     * Deletes a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteAsyncWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteRequest($accept, $journal_set_id, $document_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDeleteRequest($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDelete'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDelete'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling journalSetDocumentDELETERequestJournalSetIDDocumentsDocumentIDDelete'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGet
     *
     * Retrieves a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Document
     */
    public function journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGet($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetWithHttpInfo
     *
     * Retrieves a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetRequest($accept, $journal_set_id, $document_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetAsync
     *
     * Retrieves a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetAsync($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        return $this->journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetAsyncWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetAsyncWithHttpInfo
     *
     * Retrieves a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetAsyncWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetRequest($accept, $journal_set_id, $document_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGetRequest($accept, $journal_set_id, $document_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGet'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGet'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling journalSetDocumentGETRequestJournalSetIDDocumentsDocumentIDGet'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdate
     *
     * Updates a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type document_type (optional)
     * @param  string $file_id file_id (optional)
     * @param  string $physical_file_name physical_file_name (optional)
     * @param  string $full_physical_file_name full_physical_file_name (optional)
     * @param  string $description description (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $file_binary file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Document
     */
    public function journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdate($accept, $journal_set_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        list($response) = $this->journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);
        return $response;
    }

    /**
     * Operation journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateWithHttpInfo
     *
     * Updates a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateRequest($accept, $journal_set_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateAsync
     *
     * Updates a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateAsync($accept, $journal_set_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        return $this->journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateAsyncWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateAsyncWithHttpInfo
     *
     * Updates a journal set document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateAsyncWithHttpInfo($accept, $journal_set_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateRequest($accept, $journal_set_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdateRequest($accept, $journal_set_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdate'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdate'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling journalSetDocumentPATCHRequestJournalSetIDDocumentsDocumentIDUpdate'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_type !== null) {
            $queryParams['DocumentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($file_id !== null) {
            $queryParams['FileID'] = ObjectSerializer::toQueryValue($file_id);
        }
        // query params
        if ($physical_file_name !== null) {
            $queryParams['PhysicalFileName'] = ObjectSerializer::toQueryValue($physical_file_name);
        }
        // query params
        if ($full_physical_file_name !== null) {
            $queryParams['FullPhysicalFileName'] = ObjectSerializer::toQueryValue($full_physical_file_name);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($file_binary !== null) {
            $queryParams['FileBinary'] = ObjectSerializer::toQueryValue($file_binary);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentPOSTRequestJournalSetIDDocumentsPost
     *
     * Appends a document to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type document_type (optional)
     * @param  string $file_id file_id (optional)
     * @param  string $physical_file_name physical_file_name (optional)
     * @param  string $full_physical_file_name full_physical_file_name (optional)
     * @param  string $description description (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $file_binary file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Document
     */
    public function journalSetDocumentPOSTRequestJournalSetIDDocumentsPost($accept, $journal_set_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        list($response) = $this->journalSetDocumentPOSTRequestJournalSetIDDocumentsPostWithHttpInfo($accept, $journal_set_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);
        return $response;
    }

    /**
     * Operation journalSetDocumentPOSTRequestJournalSetIDDocumentsPostWithHttpInfo
     *
     * Appends a document to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentPOSTRequestJournalSetIDDocumentsPostWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->journalSetDocumentPOSTRequestJournalSetIDDocumentsPostRequest($accept, $journal_set_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentPOSTRequestJournalSetIDDocumentsPostAsync
     *
     * Appends a document to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentPOSTRequestJournalSetIDDocumentsPostAsync($accept, $journal_set_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        return $this->journalSetDocumentPOSTRequestJournalSetIDDocumentsPostAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentPOSTRequestJournalSetIDDocumentsPostAsyncWithHttpInfo
     *
     * Appends a document to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentPOSTRequestJournalSetIDDocumentsPostAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->journalSetDocumentPOSTRequestJournalSetIDDocumentsPostRequest($accept, $journal_set_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentPOSTRequestJournalSetIDDocumentsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentPOSTRequestJournalSetIDDocumentsPostRequest($accept, $journal_set_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentPOSTRequestJournalSetIDDocumentsPost'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetDocumentPOSTRequestJournalSetIDDocumentsPost'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_type !== null) {
            $queryParams['DocumentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($file_id !== null) {
            $queryParams['FileID'] = ObjectSerializer::toQueryValue($file_id);
        }
        // query params
        if ($physical_file_name !== null) {
            $queryParams['PhysicalFileName'] = ObjectSerializer::toQueryValue($physical_file_name);
        }
        // query params
        if ($full_physical_file_name !== null) {
            $queryParams['FullPhysicalFileName'] = ObjectSerializer::toQueryValue($full_physical_file_name);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($file_binary !== null) {
            $queryParams['FileBinary'] = ObjectSerializer::toQueryValue($file_binary);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete
     *
     * Deletes a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete($accept, $document_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo($accept, $document_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo
     *
     * Deletes a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsync
     *
     * Deletes a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsync($accept, $document_type_id, $jiwa_stateful = null)
    {
        return $this->journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo
     *
     * Deletes a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling journalSetDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
            );
        }

        $resourcePath = '/JournalSets/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet
     *
     * Retrieves a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\DocumentType
     */
    public function journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet($accept, $document_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo($accept, $document_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo
     *
     * Retrieves a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsync
     *
     * Retrieves a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsync($accept, $document_type_id, $jiwa_stateful = null)
    {
        return $this->journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo
     *
     * Retrieves a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling journalSetDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
            );
        }

        $resourcePath = '/JournalSets/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate
     *
     * Updates a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\DocumentType
     */
    public function journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo
     *
     * Updates a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsync
     *
     * Updates a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsync($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo
     *
     * Updates a journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling journalSetDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
            );
        }

        $resourcePath = '/JournalSets/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentTypePOSTRequestDocumentTypesPost
     *
     * Creates a new journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\DocumentType
     */
    public function journalSetDocumentTypePOSTRequestDocumentTypesPost($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->journalSetDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation journalSetDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo
     *
     * Creates a new journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->journalSetDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentTypePOSTRequestDocumentTypesPostAsync
     *
     * Creates a new journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypePOSTRequestDocumentTypesPostAsync($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->journalSetDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo
     *
     * Creates a new journal set document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->journalSetDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentTypePOSTRequestDocumentTypesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentTypePOSTRequestDocumentTypesPost'
            );
        }

        $resourcePath = '/JournalSets/DocumentTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentTypesGETManyRequestDocumentTypesGet
     *
     * Retrieves a list of journal set document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\DocumentType[]
     */
    public function journalSetDocumentTypesGETManyRequestDocumentTypesGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo
     *
     * Retrieves a list of journal set document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\DocumentType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType[]';
        $request = $this->journalSetDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentTypesGETManyRequestDocumentTypesGetAsync
     *
     * Retrieves a list of journal set document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypesGETManyRequestDocumentTypesGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->journalSetDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo
     *
     * Retrieves a list of journal set document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType[]';
        $request = $this->journalSetDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentTypesGETManyRequestDocumentTypesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentTypesGETManyRequestDocumentTypesGet'
            );
        }

        $resourcePath = '/JournalSets/DocumentTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetDocumentsGETManyRequestJournalSetIDDocumentsGet
     *
     * Retrieves a list of journal set documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Document[]
     */
    public function journalSetDocumentsGETManyRequestJournalSetIDDocumentsGet($accept, $journal_set_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetWithHttpInfo($accept, $journal_set_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetWithHttpInfo
     *
     * Retrieves a list of journal set documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Document[], HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document[]';
        $request = $this->journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetRequest($accept, $journal_set_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetAsync
     *
     * Retrieves a list of journal set documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetAsync($accept, $journal_set_id, $jiwa_stateful = null)
    {
        return $this->journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetAsyncWithHttpInfo
     *
     * Retrieves a list of journal set documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document[]';
        $request = $this->journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetRequest($accept, $journal_set_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetDocumentsGETManyRequestJournalSetIDDocumentsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetDocumentsGETManyRequestJournalSetIDDocumentsGetRequest($accept, $journal_set_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetDocumentsGETManyRequestJournalSetIDDocumentsGet'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetDocumentsGETManyRequestJournalSetIDDocumentsGet'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetGETRequestJournalSetIDGet
     *
     * Retrieves a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\JournalSet
     */
    public function journalSetGETRequestJournalSetIDGet($accept, $journal_set_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetGETRequestJournalSetIDGetWithHttpInfo($accept, $journal_set_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetGETRequestJournalSetIDGetWithHttpInfo
     *
     * Retrieves a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\JournalSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetGETRequestJournalSetIDGetWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSet';
        $request = $this->journalSetGETRequestJournalSetIDGetRequest($accept, $journal_set_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetGETRequestJournalSetIDGetAsync
     *
     * Retrieves a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetGETRequestJournalSetIDGetAsync($accept, $journal_set_id, $jiwa_stateful = null)
    {
        return $this->journalSetGETRequestJournalSetIDGetAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetGETRequestJournalSetIDGetAsyncWithHttpInfo
     *
     * Retrieves a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetGETRequestJournalSetIDGetAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSet';
        $request = $this->journalSetGETRequestJournalSetIDGetRequest($accept, $journal_set_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetGETRequestJournalSetIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetGETRequestJournalSetIDGetRequest($accept, $journal_set_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetGETRequestJournalSetIDGet'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetGETRequestJournalSetIDGet'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDelete
     *
     * Deletes a line from a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $journal_set_line_id journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $reference reference (optional)
     * @param  string $remark remark (optional)
     * @param  string $trans_code1_id trans_code1_id (optional)
     * @param  string $trans_code1_description trans_code1_description (optional)
     * @param  string $trans_code2_id trans_code2_id (optional)
     * @param  string $trans_code2_description trans_code2_description (optional)
     * @param  string $bas_code bas_code (optional)
     * @param  \DateTime $trans_post_date_time trans_post_date_time (optional)
     * @param  double $debit_amount debit_amount (optional)
     * @param  double $credit_amount credit_amount (optional)
     * @param  bool $allow_group allow_group (optional)
     * @param  string $staff staff (optional)
     * @param  string $job_costing_stage_id job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description general_ledger_account_description (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDelete($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null)
    {
        list($response) = $this->journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description);
        return $response;
    }

    /**
     * Operation journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteWithHttpInfo
     *
     * Deletes a line from a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteAsync
     *
     * Deletes a line from a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteAsync($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null)
    {
        return $this->journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteAsyncWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteAsyncWithHttpInfo
     *
     * Deletes a line from a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteAsyncWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDeleteRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDelete'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDelete'
            );
        }
        // verify the required parameter 'journal_set_line_id' is set
        if ($journal_set_line_id === null || (is_array($journal_set_line_id) && count($journal_set_line_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_line_id when calling journalSetLineDELETERequestJournalSetIDLinesJournalSetLineIDDelete'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Lines/{JournalSetLineID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($reference !== null) {
            $queryParams['Reference'] = ObjectSerializer::toQueryValue($reference);
        }
        // query params
        if ($remark !== null) {
            $queryParams['Remark'] = ObjectSerializer::toQueryValue($remark);
        }
        // query params
        if ($trans_code1_id !== null) {
            $queryParams['TransCode1ID'] = ObjectSerializer::toQueryValue($trans_code1_id);
        }
        // query params
        if ($trans_code1_description !== null) {
            $queryParams['TransCode1Description'] = ObjectSerializer::toQueryValue($trans_code1_description);
        }
        // query params
        if ($trans_code2_id !== null) {
            $queryParams['TransCode2ID'] = ObjectSerializer::toQueryValue($trans_code2_id);
        }
        // query params
        if ($trans_code2_description !== null) {
            $queryParams['TransCode2Description'] = ObjectSerializer::toQueryValue($trans_code2_description);
        }
        // query params
        if ($bas_code !== null) {
            $queryParams['BASCode'] = ObjectSerializer::toQueryValue($bas_code);
        }
        // query params
        if ($trans_post_date_time !== null) {
            $queryParams['TransPostDateTime'] = ObjectSerializer::toQueryValue($trans_post_date_time);
        }
        // query params
        if ($debit_amount !== null) {
            $queryParams['DebitAmount'] = ObjectSerializer::toQueryValue($debit_amount);
        }
        // query params
        if ($credit_amount !== null) {
            $queryParams['CreditAmount'] = ObjectSerializer::toQueryValue($credit_amount);
        }
        // query params
        if ($allow_group !== null) {
            $queryParams['AllowGroup'] = ObjectSerializer::toQueryValue($allow_group);
        }
        // query params
        if ($staff !== null) {
            $queryParams['Staff'] = ObjectSerializer::toQueryValue($staff);
        }
        // query params
        if ($job_costing_stage_id !== null) {
            $queryParams['JobCostingStageID'] = ObjectSerializer::toQueryValue($job_costing_stage_id);
        }
        // query params
        if ($job_costing_full_job_no !== null) {
            $queryParams['JobCostingFullJobNo'] = ObjectSerializer::toQueryValue($job_costing_full_job_no);
        }
        // query params
        if ($general_ledger_account_rec_id !== null) {
            $queryParams['GeneralLedgerAccountRecID'] = ObjectSerializer::toQueryValue($general_ledger_account_rec_id);
        }
        // query params
        if ($general_ledger_account_account_no !== null) {
            $queryParams['GeneralLedgerAccountAccountNo'] = ObjectSerializer::toQueryValue($general_ledger_account_account_no);
        }
        // query params
        if ($general_ledger_account_description !== null) {
            $queryParams['GeneralLedgerAccountDescription'] = ObjectSerializer::toQueryValue($general_ledger_account_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($journal_set_line_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetLineID' . '}',
                ObjectSerializer::toPathValue($journal_set_line_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGet
     *
     * Retrieves a journal set line.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $journal_set_line_id journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\JournalSetLine
     */
    public function journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGet($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetWithHttpInfo
     *
     * Retrieves a journal set line.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\JournalSetLine, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSetLine';
        $request = $this->journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetAsync
     *
     * Retrieves a journal set line.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetAsync($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null)
    {
        return $this->journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetAsyncWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetAsyncWithHttpInfo
     *
     * Retrieves a journal set line.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetAsyncWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSetLine';
        $request = $this->journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGetRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGet'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGet'
            );
        }
        // verify the required parameter 'journal_set_line_id' is set
        if ($journal_set_line_id === null || (is_array($journal_set_line_id) && count($journal_set_line_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_line_id when calling journalSetLineGETRequestJournalSetIDLinesJournalSetLineIDGet'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Lines/{JournalSetLineID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($journal_set_line_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetLineID' . '}',
                ObjectSerializer::toPathValue($journal_set_line_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdate
     *
     * Updates a line for a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $journal_set_line_id journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $reference reference (optional)
     * @param  string $remark remark (optional)
     * @param  string $trans_code1_id trans_code1_id (optional)
     * @param  string $trans_code1_description trans_code1_description (optional)
     * @param  string $trans_code2_id trans_code2_id (optional)
     * @param  string $trans_code2_description trans_code2_description (optional)
     * @param  string $bas_code bas_code (optional)
     * @param  \DateTime $trans_post_date_time trans_post_date_time (optional)
     * @param  double $debit_amount debit_amount (optional)
     * @param  double $credit_amount credit_amount (optional)
     * @param  bool $allow_group allow_group (optional)
     * @param  string $staff staff (optional)
     * @param  string $job_costing_stage_id job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\JournalSetLine
     */
    public function journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdate($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        list($response) = $this->journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description, $body);
        return $response;
    }

    /**
     * Operation journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateWithHttpInfo
     *
     * Updates a line for a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\JournalSetLine, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSetLine';
        $request = $this->journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateAsync
     *
     * Updates a line for a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateAsync($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        return $this->journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateAsyncWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateAsyncWithHttpInfo
     *
     * Updates a line for a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateAsyncWithHttpInfo($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSetLine';
        $request = $this->journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $journal_set_line_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdateRequest($accept, $journal_set_id, $journal_set_line_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdate'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdate'
            );
        }
        // verify the required parameter 'journal_set_line_id' is set
        if ($journal_set_line_id === null || (is_array($journal_set_line_id) && count($journal_set_line_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_line_id when calling journalSetLinePATCHRequestJournalSetIDLinesJournalSetLineIDUpdate'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Lines/{JournalSetLineID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($reference !== null) {
            $queryParams['Reference'] = ObjectSerializer::toQueryValue($reference);
        }
        // query params
        if ($remark !== null) {
            $queryParams['Remark'] = ObjectSerializer::toQueryValue($remark);
        }
        // query params
        if ($trans_code1_id !== null) {
            $queryParams['TransCode1ID'] = ObjectSerializer::toQueryValue($trans_code1_id);
        }
        // query params
        if ($trans_code1_description !== null) {
            $queryParams['TransCode1Description'] = ObjectSerializer::toQueryValue($trans_code1_description);
        }
        // query params
        if ($trans_code2_id !== null) {
            $queryParams['TransCode2ID'] = ObjectSerializer::toQueryValue($trans_code2_id);
        }
        // query params
        if ($trans_code2_description !== null) {
            $queryParams['TransCode2Description'] = ObjectSerializer::toQueryValue($trans_code2_description);
        }
        // query params
        if ($bas_code !== null) {
            $queryParams['BASCode'] = ObjectSerializer::toQueryValue($bas_code);
        }
        // query params
        if ($trans_post_date_time !== null) {
            $queryParams['TransPostDateTime'] = ObjectSerializer::toQueryValue($trans_post_date_time);
        }
        // query params
        if ($debit_amount !== null) {
            $queryParams['DebitAmount'] = ObjectSerializer::toQueryValue($debit_amount);
        }
        // query params
        if ($credit_amount !== null) {
            $queryParams['CreditAmount'] = ObjectSerializer::toQueryValue($credit_amount);
        }
        // query params
        if ($allow_group !== null) {
            $queryParams['AllowGroup'] = ObjectSerializer::toQueryValue($allow_group);
        }
        // query params
        if ($staff !== null) {
            $queryParams['Staff'] = ObjectSerializer::toQueryValue($staff);
        }
        // query params
        if ($job_costing_stage_id !== null) {
            $queryParams['JobCostingStageID'] = ObjectSerializer::toQueryValue($job_costing_stage_id);
        }
        // query params
        if ($job_costing_full_job_no !== null) {
            $queryParams['JobCostingFullJobNo'] = ObjectSerializer::toQueryValue($job_costing_full_job_no);
        }
        // query params
        if ($general_ledger_account_rec_id !== null) {
            $queryParams['GeneralLedgerAccountRecID'] = ObjectSerializer::toQueryValue($general_ledger_account_rec_id);
        }
        // query params
        if ($general_ledger_account_account_no !== null) {
            $queryParams['GeneralLedgerAccountAccountNo'] = ObjectSerializer::toQueryValue($general_ledger_account_account_no);
        }
        // query params
        if ($general_ledger_account_description !== null) {
            $queryParams['GeneralLedgerAccountDescription'] = ObjectSerializer::toQueryValue($general_ledger_account_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($journal_set_line_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetLineID' . '}',
                ObjectSerializer::toPathValue($journal_set_line_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetLinePOSTRequestJournalSetIDLinesPost
     *
     * Appends a line to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $reference reference (optional)
     * @param  string $remark remark (optional)
     * @param  string $trans_code1_id trans_code1_id (optional)
     * @param  string $trans_code1_description trans_code1_description (optional)
     * @param  string $trans_code2_id trans_code2_id (optional)
     * @param  string $trans_code2_description trans_code2_description (optional)
     * @param  string $bas_code bas_code (optional)
     * @param  \DateTime $trans_post_date_time trans_post_date_time (optional)
     * @param  double $debit_amount debit_amount (optional)
     * @param  double $credit_amount credit_amount (optional)
     * @param  bool $allow_group allow_group (optional)
     * @param  string $staff staff (optional)
     * @param  string $job_costing_stage_id job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\JournalSetLine
     */
    public function journalSetLinePOSTRequestJournalSetIDLinesPost($accept, $journal_set_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        list($response) = $this->journalSetLinePOSTRequestJournalSetIDLinesPostWithHttpInfo($accept, $journal_set_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description, $body);
        return $response;
    }

    /**
     * Operation journalSetLinePOSTRequestJournalSetIDLinesPostWithHttpInfo
     *
     * Appends a line to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\JournalSetLine, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetLinePOSTRequestJournalSetIDLinesPostWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSetLine';
        $request = $this->journalSetLinePOSTRequestJournalSetIDLinesPostRequest($accept, $journal_set_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetLinePOSTRequestJournalSetIDLinesPostAsync
     *
     * Appends a line to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLinePOSTRequestJournalSetIDLinesPostAsync($accept, $journal_set_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        return $this->journalSetLinePOSTRequestJournalSetIDLinesPostAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetLinePOSTRequestJournalSetIDLinesPostAsyncWithHttpInfo
     *
     * Appends a line to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLinePOSTRequestJournalSetIDLinesPostAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSetLine';
        $request = $this->journalSetLinePOSTRequestJournalSetIDLinesPostRequest($accept, $journal_set_id, $jiwa_stateful, $item_no, $reference, $remark, $trans_code1_id, $trans_code1_description, $trans_code2_id, $trans_code2_description, $bas_code, $trans_post_date_time, $debit_amount, $credit_amount, $allow_group, $staff, $job_costing_stage_id, $job_costing_full_job_no, $general_ledger_account_rec_id, $general_ledger_account_account_no, $general_ledger_account_description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetLinePOSTRequestJournalSetIDLinesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $item_no (optional)
     * @param  string $reference (optional)
     * @param  string $remark (optional)
     * @param  string $trans_code1_id (optional)
     * @param  string $trans_code1_description (optional)
     * @param  string $trans_code2_id (optional)
     * @param  string $trans_code2_description (optional)
     * @param  string $bas_code (optional)
     * @param  \DateTime $trans_post_date_time (optional)
     * @param  double $debit_amount (optional)
     * @param  double $credit_amount (optional)
     * @param  bool $allow_group (optional)
     * @param  string $staff (optional)
     * @param  string $job_costing_stage_id (optional)
     * @param  string $job_costing_full_job_no (optional)
     * @param  string $general_ledger_account_rec_id (optional)
     * @param  string $general_ledger_account_account_no (optional)
     * @param  string $general_ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\JournalSetLinePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetLinePOSTRequestJournalSetIDLinesPostRequest($accept, $journal_set_id, $jiwa_stateful = null, $item_no = null, $reference = null, $remark = null, $trans_code1_id = null, $trans_code1_description = null, $trans_code2_id = null, $trans_code2_description = null, $bas_code = null, $trans_post_date_time = null, $debit_amount = null, $credit_amount = null, $allow_group = null, $staff = null, $job_costing_stage_id = null, $job_costing_full_job_no = null, $general_ledger_account_rec_id = null, $general_ledger_account_account_no = null, $general_ledger_account_description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetLinePOSTRequestJournalSetIDLinesPost'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetLinePOSTRequestJournalSetIDLinesPost'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Lines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($reference !== null) {
            $queryParams['Reference'] = ObjectSerializer::toQueryValue($reference);
        }
        // query params
        if ($remark !== null) {
            $queryParams['Remark'] = ObjectSerializer::toQueryValue($remark);
        }
        // query params
        if ($trans_code1_id !== null) {
            $queryParams['TransCode1ID'] = ObjectSerializer::toQueryValue($trans_code1_id);
        }
        // query params
        if ($trans_code1_description !== null) {
            $queryParams['TransCode1Description'] = ObjectSerializer::toQueryValue($trans_code1_description);
        }
        // query params
        if ($trans_code2_id !== null) {
            $queryParams['TransCode2ID'] = ObjectSerializer::toQueryValue($trans_code2_id);
        }
        // query params
        if ($trans_code2_description !== null) {
            $queryParams['TransCode2Description'] = ObjectSerializer::toQueryValue($trans_code2_description);
        }
        // query params
        if ($bas_code !== null) {
            $queryParams['BASCode'] = ObjectSerializer::toQueryValue($bas_code);
        }
        // query params
        if ($trans_post_date_time !== null) {
            $queryParams['TransPostDateTime'] = ObjectSerializer::toQueryValue($trans_post_date_time);
        }
        // query params
        if ($debit_amount !== null) {
            $queryParams['DebitAmount'] = ObjectSerializer::toQueryValue($debit_amount);
        }
        // query params
        if ($credit_amount !== null) {
            $queryParams['CreditAmount'] = ObjectSerializer::toQueryValue($credit_amount);
        }
        // query params
        if ($allow_group !== null) {
            $queryParams['AllowGroup'] = ObjectSerializer::toQueryValue($allow_group);
        }
        // query params
        if ($staff !== null) {
            $queryParams['Staff'] = ObjectSerializer::toQueryValue($staff);
        }
        // query params
        if ($job_costing_stage_id !== null) {
            $queryParams['JobCostingStageID'] = ObjectSerializer::toQueryValue($job_costing_stage_id);
        }
        // query params
        if ($job_costing_full_job_no !== null) {
            $queryParams['JobCostingFullJobNo'] = ObjectSerializer::toQueryValue($job_costing_full_job_no);
        }
        // query params
        if ($general_ledger_account_rec_id !== null) {
            $queryParams['GeneralLedgerAccountRecID'] = ObjectSerializer::toQueryValue($general_ledger_account_rec_id);
        }
        // query params
        if ($general_ledger_account_account_no !== null) {
            $queryParams['GeneralLedgerAccountAccountNo'] = ObjectSerializer::toQueryValue($general_ledger_account_account_no);
        }
        // query params
        if ($general_ledger_account_description !== null) {
            $queryParams['GeneralLedgerAccountDescription'] = ObjectSerializer::toQueryValue($general_ledger_account_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetLinesGETManyRequestJournalSetIDLinesGet
     *
     * Retrieves a list of journal set lines.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\JournalSetLine[]
     */
    public function journalSetLinesGETManyRequestJournalSetIDLinesGet($accept, $journal_set_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetLinesGETManyRequestJournalSetIDLinesGetWithHttpInfo($accept, $journal_set_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetLinesGETManyRequestJournalSetIDLinesGetWithHttpInfo
     *
     * Retrieves a list of journal set lines.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\JournalSetLine[], HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetLinesGETManyRequestJournalSetIDLinesGetWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSetLine[]';
        $request = $this->journalSetLinesGETManyRequestJournalSetIDLinesGetRequest($accept, $journal_set_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSetLine[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetLinesGETManyRequestJournalSetIDLinesGetAsync
     *
     * Retrieves a list of journal set lines.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLinesGETManyRequestJournalSetIDLinesGetAsync($accept, $journal_set_id, $jiwa_stateful = null)
    {
        return $this->journalSetLinesGETManyRequestJournalSetIDLinesGetAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetLinesGETManyRequestJournalSetIDLinesGetAsyncWithHttpInfo
     *
     * Retrieves a list of journal set lines.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetLinesGETManyRequestJournalSetIDLinesGetAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSetLine[]';
        $request = $this->journalSetLinesGETManyRequestJournalSetIDLinesGetRequest($accept, $journal_set_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetLinesGETManyRequestJournalSetIDLinesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetLinesGETManyRequestJournalSetIDLinesGetRequest($accept, $journal_set_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetLinesGETManyRequestJournalSetIDLinesGet'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetLinesGETManyRequestJournalSetIDLinesGet'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Lines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNoteDELETERequestJournalSetIDNotesNoteIDDelete
     *
     * Deletes a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function journalSetNoteDELETERequestJournalSetIDNotesNoteIDDelete($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteWithHttpInfo
     *
     * Deletes a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteRequest($accept, $journal_set_id, $note_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteAsync
     *
     * Deletes a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteAsync($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        return $this->journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteAsyncWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteAsyncWithHttpInfo
     *
     * Deletes a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteAsyncWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteRequest($accept, $journal_set_id, $note_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNoteDELETERequestJournalSetIDNotesNoteIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNoteDELETERequestJournalSetIDNotesNoteIDDeleteRequest($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNoteDELETERequestJournalSetIDNotesNoteIDDelete'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetNoteDELETERequestJournalSetIDNotesNoteIDDelete'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling journalSetNoteDELETERequestJournalSetIDNotesNoteIDDelete'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNoteGETRequestJournalSetIDNotesNoteIDGet
     *
     * Retrieves a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Note
     */
    public function journalSetNoteGETRequestJournalSetIDNotesNoteIDGet($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetNoteGETRequestJournalSetIDNotesNoteIDGetWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetNoteGETRequestJournalSetIDNotesNoteIDGetWithHttpInfo
     *
     * Retrieves a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNoteGETRequestJournalSetIDNotesNoteIDGetWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->journalSetNoteGETRequestJournalSetIDNotesNoteIDGetRequest($accept, $journal_set_id, $note_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNoteGETRequestJournalSetIDNotesNoteIDGetAsync
     *
     * Retrieves a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteGETRequestJournalSetIDNotesNoteIDGetAsync($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        return $this->journalSetNoteGETRequestJournalSetIDNotesNoteIDGetAsyncWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNoteGETRequestJournalSetIDNotesNoteIDGetAsyncWithHttpInfo
     *
     * Retrieves a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteGETRequestJournalSetIDNotesNoteIDGetAsyncWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->journalSetNoteGETRequestJournalSetIDNotesNoteIDGetRequest($accept, $journal_set_id, $note_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNoteGETRequestJournalSetIDNotesNoteIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNoteGETRequestJournalSetIDNotesNoteIDGetRequest($accept, $journal_set_id, $note_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNoteGETRequestJournalSetIDNotesNoteIDGet'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetNoteGETRequestJournalSetIDNotesNoteIDGet'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling journalSetNoteGETRequestJournalSetIDNotesNoteIDGet'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdate
     *
     * Updates a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type note_type (optional)
     * @param  int $line_no line_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $note_text note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Note
     */
    public function journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdate($accept, $journal_set_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        list($response) = $this->journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);
        return $response;
    }

    /**
     * Operation journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateWithHttpInfo
     *
     * Updates a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateRequest($accept, $journal_set_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateAsync
     *
     * Updates a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateAsync($accept, $journal_set_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        return $this->journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateAsyncWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateAsyncWithHttpInfo
     *
     * Updates a journal set note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateAsyncWithHttpInfo($accept, $journal_set_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateRequest($accept, $journal_set_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdateRequest($accept, $journal_set_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdate'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdate'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling journalSetNotePATCHRequestJournalSetIDNotesNoteIDUpdate'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($note_type !== null) {
            $queryParams['NoteType'] = ObjectSerializer::toQueryValue($note_type);
        }
        // query params
        if ($line_no !== null) {
            $queryParams['LineNo'] = ObjectSerializer::toQueryValue($line_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($note_text !== null) {
            $queryParams['NoteText'] = ObjectSerializer::toQueryValue($note_text);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNotePOSTRequestJournalSetIDNotesPost
     *
     * Appends a note to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type note_type (optional)
     * @param  int $line_no line_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $note_text note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Note
     */
    public function journalSetNotePOSTRequestJournalSetIDNotesPost($accept, $journal_set_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        list($response) = $this->journalSetNotePOSTRequestJournalSetIDNotesPostWithHttpInfo($accept, $journal_set_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);
        return $response;
    }

    /**
     * Operation journalSetNotePOSTRequestJournalSetIDNotesPostWithHttpInfo
     *
     * Appends a note to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNotePOSTRequestJournalSetIDNotesPostWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->journalSetNotePOSTRequestJournalSetIDNotesPostRequest($accept, $journal_set_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNotePOSTRequestJournalSetIDNotesPostAsync
     *
     * Appends a note to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNotePOSTRequestJournalSetIDNotesPostAsync($accept, $journal_set_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        return $this->journalSetNotePOSTRequestJournalSetIDNotesPostAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNotePOSTRequestJournalSetIDNotesPostAsyncWithHttpInfo
     *
     * Appends a note to a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNotePOSTRequestJournalSetIDNotesPostAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->journalSetNotePOSTRequestJournalSetIDNotesPostRequest($accept, $journal_set_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNotePOSTRequestJournalSetIDNotesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNotePOSTRequestJournalSetIDNotesPostRequest($accept, $journal_set_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNotePOSTRequestJournalSetIDNotesPost'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetNotePOSTRequestJournalSetIDNotesPost'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($note_type !== null) {
            $queryParams['NoteType'] = ObjectSerializer::toQueryValue($note_type);
        }
        // query params
        if ($line_no !== null) {
            $queryParams['LineNo'] = ObjectSerializer::toQueryValue($line_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($note_text !== null) {
            $queryParams['NoteText'] = ObjectSerializer::toQueryValue($note_text);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDelete
     *
     * Deletes a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDelete($accept, $note_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo($accept, $note_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo
     *
     * Deletes a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsync
     *
     * Deletes a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsync($accept, $note_type_id, $jiwa_stateful = null)
    {
        return $this->journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo
     *
     * Deletes a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling journalSetNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
            );
        }

        $resourcePath = '/JournalSets/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGet
     *
     * Retrieves a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\NoteType
     */
    public function journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGet($accept, $note_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo($accept, $note_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo
     *
     * Retrieves a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetAsync
     *
     * Retrieves a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetAsync($accept, $note_type_id, $jiwa_stateful = null)
    {
        return $this->journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo
     *
     * Retrieves a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGet'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling journalSetNoteTypeGETRequestNoteTypesNoteTypeIDGet'
            );
        }

        $resourcePath = '/JournalSets/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate
     *
     * Updates a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\NoteType
     */
    public function journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo
     *
     * Updates a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsync
     *
     * Updates a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsync($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo
     *
     * Updates a journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling journalSetNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
            );
        }

        $resourcePath = '/JournalSets/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNoteTypePOSTRequestNoteTypesPost
     *
     * Creates a new journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\NoteType
     */
    public function journalSetNoteTypePOSTRequestNoteTypesPost($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->journalSetNoteTypePOSTRequestNoteTypesPostWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation journalSetNoteTypePOSTRequestNoteTypesPostWithHttpInfo
     *
     * Creates a new journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNoteTypePOSTRequestNoteTypesPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->journalSetNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNoteTypePOSTRequestNoteTypesPostAsync
     *
     * Creates a new journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypePOSTRequestNoteTypesPostAsync($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->journalSetNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo
     *
     * Creates a new journal set note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->journalSetNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNoteTypePOSTRequestNoteTypesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\JournalSetNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNoteTypePOSTRequestNoteTypesPost'
            );
        }

        $resourcePath = '/JournalSets/NoteTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNoteTypesGETManyRequestNoteTypesGet
     *
     * Retrieves a list of journal set note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\NoteType[]
     */
    public function journalSetNoteTypesGETManyRequestNoteTypesGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetNoteTypesGETManyRequestNoteTypesGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetNoteTypesGETManyRequestNoteTypesGetWithHttpInfo
     *
     * Retrieves a list of journal set note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\NoteType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNoteTypesGETManyRequestNoteTypesGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType[]';
        $request = $this->journalSetNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNoteTypesGETManyRequestNoteTypesGetAsync
     *
     * Retrieves a list of journal set note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypesGETManyRequestNoteTypesGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->journalSetNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo
     *
     * Retrieves a list of journal set note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType[]';
        $request = $this->journalSetNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNoteTypesGETManyRequestNoteTypesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNoteTypesGETManyRequestNoteTypesGet'
            );
        }

        $resourcePath = '/JournalSets/NoteTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetNotesGETManyRequestJournalSetIDNotesGet
     *
     * Retrieves a list of journal set notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Note[]
     */
    public function journalSetNotesGETManyRequestJournalSetIDNotesGet($accept, $journal_set_id, $jiwa_stateful = null)
    {
        list($response) = $this->journalSetNotesGETManyRequestJournalSetIDNotesGetWithHttpInfo($accept, $journal_set_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation journalSetNotesGETManyRequestJournalSetIDNotesGetWithHttpInfo
     *
     * Retrieves a list of journal set notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Note[], HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetNotesGETManyRequestJournalSetIDNotesGetWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note[]';
        $request = $this->journalSetNotesGETManyRequestJournalSetIDNotesGetRequest($accept, $journal_set_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetNotesGETManyRequestJournalSetIDNotesGetAsync
     *
     * Retrieves a list of journal set notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNotesGETManyRequestJournalSetIDNotesGetAsync($accept, $journal_set_id, $jiwa_stateful = null)
    {
        return $this->journalSetNotesGETManyRequestJournalSetIDNotesGetAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetNotesGETManyRequestJournalSetIDNotesGetAsyncWithHttpInfo
     *
     * Retrieves a list of journal set notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetNotesGETManyRequestJournalSetIDNotesGetAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note[]';
        $request = $this->journalSetNotesGETManyRequestJournalSetIDNotesGetRequest($accept, $journal_set_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetNotesGETManyRequestJournalSetIDNotesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetNotesGETManyRequestJournalSetIDNotesGetRequest($accept, $journal_set_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetNotesGETManyRequestJournalSetIDNotesGet'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetNotesGETManyRequestJournalSetIDNotesGet'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}/Notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetPATCHRequestJournalSetIDUpdate
     *
     * Updates a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no set_no (optional)
     * @param  string $set_type set_type (optional)
     * @param  string $description description (optional)
     * @param  string $source source (optional)
     * @param  string $source_id source_id (optional)
     * @param  \DateTime $posted_date posted_date (optional)
     * @param  bool $is_reversed is_reversed (optional)
     * @param  string $reverse_type reverse_type (optional)
     * @param  \DateTime $reverse_date reverse_date (optional)
     * @param  int $repeating_units repeating_units (optional)
     * @param  string $repeating_type repeating_type (optional)
     * @param  \DateTime $next_repeating_date next_repeating_date (optional)
     * @param  bool $repeating_will_end repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $staff staff (optional)
     * @param  string $lines lines (optional)
     * @param  string $notes notes (optional)
     * @param  string $documents documents (optional)
     * @param  int $posted_to_period_no posted_to_period_no (optional)
     * @param  string $posted_to_period_name posted_to_period_name (optional)
     * @param  string $posted_to_year_type posted_to_year_type (optional)
     * @param  int $posted_to_year_no posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\JournalSet
     */
    public function journalSetPATCHRequestJournalSetIDUpdate($accept, $journal_set_id, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        list($response) = $this->journalSetPATCHRequestJournalSetIDUpdateWithHttpInfo($accept, $journal_set_id, $jiwa_stateful, $set_no, $set_type, $description, $source, $source_id, $posted_date, $is_reversed, $reverse_type, $reverse_date, $repeating_units, $repeating_type, $next_repeating_date, $repeating_will_end, $repeating_end_date, $last_saved_date_time, $staff, $lines, $notes, $documents, $posted_to_period_no, $posted_to_period_name, $posted_to_year_type, $posted_to_year_no, $posted_to_period_no_is_globally_locked, $posted_to_period_no_is_externally_locked, $body);
        return $response;
    }

    /**
     * Operation journalSetPATCHRequestJournalSetIDUpdateWithHttpInfo
     *
     * Updates a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no (optional)
     * @param  string $set_type (optional)
     * @param  string $description (optional)
     * @param  string $source (optional)
     * @param  string $source_id (optional)
     * @param  \DateTime $posted_date (optional)
     * @param  bool $is_reversed (optional)
     * @param  string $reverse_type (optional)
     * @param  \DateTime $reverse_date (optional)
     * @param  int $repeating_units (optional)
     * @param  string $repeating_type (optional)
     * @param  \DateTime $next_repeating_date (optional)
     * @param  bool $repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $staff (optional)
     * @param  string $lines (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  int $posted_to_period_no (optional)
     * @param  string $posted_to_period_name (optional)
     * @param  string $posted_to_year_type (optional)
     * @param  int $posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\JournalSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetPATCHRequestJournalSetIDUpdateWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSet';
        $request = $this->journalSetPATCHRequestJournalSetIDUpdateRequest($accept, $journal_set_id, $jiwa_stateful, $set_no, $set_type, $description, $source, $source_id, $posted_date, $is_reversed, $reverse_type, $reverse_date, $repeating_units, $repeating_type, $next_repeating_date, $repeating_will_end, $repeating_end_date, $last_saved_date_time, $staff, $lines, $notes, $documents, $posted_to_period_no, $posted_to_period_name, $posted_to_year_type, $posted_to_year_no, $posted_to_period_no_is_globally_locked, $posted_to_period_no_is_externally_locked, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetPATCHRequestJournalSetIDUpdateAsync
     *
     * Updates a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no (optional)
     * @param  string $set_type (optional)
     * @param  string $description (optional)
     * @param  string $source (optional)
     * @param  string $source_id (optional)
     * @param  \DateTime $posted_date (optional)
     * @param  bool $is_reversed (optional)
     * @param  string $reverse_type (optional)
     * @param  \DateTime $reverse_date (optional)
     * @param  int $repeating_units (optional)
     * @param  string $repeating_type (optional)
     * @param  \DateTime $next_repeating_date (optional)
     * @param  bool $repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $staff (optional)
     * @param  string $lines (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  int $posted_to_period_no (optional)
     * @param  string $posted_to_period_name (optional)
     * @param  string $posted_to_year_type (optional)
     * @param  int $posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetPATCHRequestJournalSetIDUpdateAsync($accept, $journal_set_id, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        return $this->journalSetPATCHRequestJournalSetIDUpdateAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful, $set_no, $set_type, $description, $source, $source_id, $posted_date, $is_reversed, $reverse_type, $reverse_date, $repeating_units, $repeating_type, $next_repeating_date, $repeating_will_end, $repeating_end_date, $last_saved_date_time, $staff, $lines, $notes, $documents, $posted_to_period_no, $posted_to_period_name, $posted_to_year_type, $posted_to_year_no, $posted_to_period_no_is_globally_locked, $posted_to_period_no_is_externally_locked, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetPATCHRequestJournalSetIDUpdateAsyncWithHttpInfo
     *
     * Updates a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no (optional)
     * @param  string $set_type (optional)
     * @param  string $description (optional)
     * @param  string $source (optional)
     * @param  string $source_id (optional)
     * @param  \DateTime $posted_date (optional)
     * @param  bool $is_reversed (optional)
     * @param  string $reverse_type (optional)
     * @param  \DateTime $reverse_date (optional)
     * @param  int $repeating_units (optional)
     * @param  string $repeating_type (optional)
     * @param  \DateTime $next_repeating_date (optional)
     * @param  bool $repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $staff (optional)
     * @param  string $lines (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  int $posted_to_period_no (optional)
     * @param  string $posted_to_period_name (optional)
     * @param  string $posted_to_year_type (optional)
     * @param  int $posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetPATCHRequestJournalSetIDUpdateAsyncWithHttpInfo($accept, $journal_set_id, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSet';
        $request = $this->journalSetPATCHRequestJournalSetIDUpdateRequest($accept, $journal_set_id, $jiwa_stateful, $set_no, $set_type, $description, $source, $source_id, $posted_date, $is_reversed, $reverse_type, $reverse_date, $repeating_units, $repeating_type, $next_repeating_date, $repeating_will_end, $repeating_end_date, $last_saved_date_time, $staff, $lines, $notes, $documents, $posted_to_period_no, $posted_to_period_name, $posted_to_year_type, $posted_to_year_no, $posted_to_period_no_is_globally_locked, $posted_to_period_no_is_externally_locked, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetPATCHRequestJournalSetIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $journal_set_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no (optional)
     * @param  string $set_type (optional)
     * @param  string $description (optional)
     * @param  string $source (optional)
     * @param  string $source_id (optional)
     * @param  \DateTime $posted_date (optional)
     * @param  bool $is_reversed (optional)
     * @param  string $reverse_type (optional)
     * @param  \DateTime $reverse_date (optional)
     * @param  int $repeating_units (optional)
     * @param  string $repeating_type (optional)
     * @param  \DateTime $next_repeating_date (optional)
     * @param  bool $repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $staff (optional)
     * @param  string $lines (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  int $posted_to_period_no (optional)
     * @param  string $posted_to_period_name (optional)
     * @param  string $posted_to_year_type (optional)
     * @param  int $posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetPATCHRequestJournalSetIDUpdateRequest($accept, $journal_set_id, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetPATCHRequestJournalSetIDUpdate'
            );
        }
        // verify the required parameter 'journal_set_id' is set
        if ($journal_set_id === null || (is_array($journal_set_id) && count($journal_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $journal_set_id when calling journalSetPATCHRequestJournalSetIDUpdate'
            );
        }

        $resourcePath = '/JournalSets/{JournalSetID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($set_no !== null) {
            $queryParams['SetNo'] = ObjectSerializer::toQueryValue($set_no);
        }
        // query params
        if ($set_type !== null) {
            $queryParams['SetType'] = ObjectSerializer::toQueryValue($set_type);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($source_id !== null) {
            $queryParams['SourceID'] = ObjectSerializer::toQueryValue($source_id);
        }
        // query params
        if ($posted_date !== null) {
            $queryParams['PostedDate'] = ObjectSerializer::toQueryValue($posted_date);
        }
        // query params
        if ($is_reversed !== null) {
            $queryParams['IsReversed'] = ObjectSerializer::toQueryValue($is_reversed);
        }
        // query params
        if ($reverse_type !== null) {
            $queryParams['ReverseType'] = ObjectSerializer::toQueryValue($reverse_type);
        }
        // query params
        if ($reverse_date !== null) {
            $queryParams['ReverseDate'] = ObjectSerializer::toQueryValue($reverse_date);
        }
        // query params
        if ($repeating_units !== null) {
            $queryParams['RepeatingUnits'] = ObjectSerializer::toQueryValue($repeating_units);
        }
        // query params
        if ($repeating_type !== null) {
            $queryParams['RepeatingType'] = ObjectSerializer::toQueryValue($repeating_type);
        }
        // query params
        if ($next_repeating_date !== null) {
            $queryParams['NextRepeatingDate'] = ObjectSerializer::toQueryValue($next_repeating_date);
        }
        // query params
        if ($repeating_will_end !== null) {
            $queryParams['RepeatingWillEnd'] = ObjectSerializer::toQueryValue($repeating_will_end);
        }
        // query params
        if ($repeating_end_date !== null) {
            $queryParams['RepeatingEndDate'] = ObjectSerializer::toQueryValue($repeating_end_date);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($staff !== null) {
            $queryParams['Staff'] = ObjectSerializer::toQueryValue($staff);
        }
        // query params
        if ($lines !== null) {
            $queryParams['Lines'] = ObjectSerializer::toQueryValue($lines);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($documents !== null) {
            $queryParams['Documents'] = ObjectSerializer::toQueryValue($documents);
        }
        // query params
        if ($posted_to_period_no !== null) {
            $queryParams['PostedToPeriodNo'] = ObjectSerializer::toQueryValue($posted_to_period_no);
        }
        // query params
        if ($posted_to_period_name !== null) {
            $queryParams['PostedToPeriodName'] = ObjectSerializer::toQueryValue($posted_to_period_name);
        }
        // query params
        if ($posted_to_year_type !== null) {
            $queryParams['PostedToYearType'] = ObjectSerializer::toQueryValue($posted_to_year_type);
        }
        // query params
        if ($posted_to_year_no !== null) {
            $queryParams['PostedToYearNo'] = ObjectSerializer::toQueryValue($posted_to_year_no);
        }
        // query params
        if ($posted_to_period_no_is_globally_locked !== null) {
            $queryParams['PostedToPeriodNoIsGloballyLocked'] = ObjectSerializer::toQueryValue($posted_to_period_no_is_globally_locked);
        }
        // query params
        if ($posted_to_period_no_is_externally_locked !== null) {
            $queryParams['PostedToPeriodNoIsExternallyLocked'] = ObjectSerializer::toQueryValue($posted_to_period_no_is_externally_locked);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($journal_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'JournalSetID' . '}',
                ObjectSerializer::toPathValue($journal_set_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetPOSTRequestPost
     *
     * Creates a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no set_no (optional)
     * @param  string $set_type set_type (optional)
     * @param  string $description description (optional)
     * @param  string $source source (optional)
     * @param  string $source_id source_id (optional)
     * @param  \DateTime $posted_date posted_date (optional)
     * @param  bool $is_reversed is_reversed (optional)
     * @param  string $reverse_type reverse_type (optional)
     * @param  \DateTime $reverse_date reverse_date (optional)
     * @param  int $repeating_units repeating_units (optional)
     * @param  string $repeating_type repeating_type (optional)
     * @param  \DateTime $next_repeating_date next_repeating_date (optional)
     * @param  bool $repeating_will_end repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $staff staff (optional)
     * @param  string $lines lines (optional)
     * @param  string $notes notes (optional)
     * @param  string $documents documents (optional)
     * @param  int $posted_to_period_no posted_to_period_no (optional)
     * @param  string $posted_to_period_name posted_to_period_name (optional)
     * @param  string $posted_to_year_type posted_to_year_type (optional)
     * @param  int $posted_to_year_no posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\JournalSet
     */
    public function journalSetPOSTRequestPost($accept, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        list($response) = $this->journalSetPOSTRequestPostWithHttpInfo($accept, $jiwa_stateful, $set_no, $set_type, $description, $source, $source_id, $posted_date, $is_reversed, $reverse_type, $reverse_date, $repeating_units, $repeating_type, $next_repeating_date, $repeating_will_end, $repeating_end_date, $last_saved_date_time, $staff, $lines, $notes, $documents, $posted_to_period_no, $posted_to_period_name, $posted_to_year_type, $posted_to_year_no, $posted_to_period_no_is_globally_locked, $posted_to_period_no_is_externally_locked, $body);
        return $response;
    }

    /**
     * Operation journalSetPOSTRequestPostWithHttpInfo
     *
     * Creates a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no (optional)
     * @param  string $set_type (optional)
     * @param  string $description (optional)
     * @param  string $source (optional)
     * @param  string $source_id (optional)
     * @param  \DateTime $posted_date (optional)
     * @param  bool $is_reversed (optional)
     * @param  string $reverse_type (optional)
     * @param  \DateTime $reverse_date (optional)
     * @param  int $repeating_units (optional)
     * @param  string $repeating_type (optional)
     * @param  \DateTime $next_repeating_date (optional)
     * @param  bool $repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $staff (optional)
     * @param  string $lines (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  int $posted_to_period_no (optional)
     * @param  string $posted_to_period_name (optional)
     * @param  string $posted_to_year_type (optional)
     * @param  int $posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\JournalSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetPOSTRequestPostWithHttpInfo($accept, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSet';
        $request = $this->journalSetPOSTRequestPostRequest($accept, $jiwa_stateful, $set_no, $set_type, $description, $source, $source_id, $posted_date, $is_reversed, $reverse_type, $reverse_date, $repeating_units, $repeating_type, $next_repeating_date, $repeating_will_end, $repeating_end_date, $last_saved_date_time, $staff, $lines, $notes, $documents, $posted_to_period_no, $posted_to_period_name, $posted_to_year_type, $posted_to_year_no, $posted_to_period_no_is_globally_locked, $posted_to_period_no_is_externally_locked, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetPOSTRequestPostAsync
     *
     * Creates a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no (optional)
     * @param  string $set_type (optional)
     * @param  string $description (optional)
     * @param  string $source (optional)
     * @param  string $source_id (optional)
     * @param  \DateTime $posted_date (optional)
     * @param  bool $is_reversed (optional)
     * @param  string $reverse_type (optional)
     * @param  \DateTime $reverse_date (optional)
     * @param  int $repeating_units (optional)
     * @param  string $repeating_type (optional)
     * @param  \DateTime $next_repeating_date (optional)
     * @param  bool $repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $staff (optional)
     * @param  string $lines (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  int $posted_to_period_no (optional)
     * @param  string $posted_to_period_name (optional)
     * @param  string $posted_to_year_type (optional)
     * @param  int $posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetPOSTRequestPostAsync($accept, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        return $this->journalSetPOSTRequestPostAsyncWithHttpInfo($accept, $jiwa_stateful, $set_no, $set_type, $description, $source, $source_id, $posted_date, $is_reversed, $reverse_type, $reverse_date, $repeating_units, $repeating_type, $next_repeating_date, $repeating_will_end, $repeating_end_date, $last_saved_date_time, $staff, $lines, $notes, $documents, $posted_to_period_no, $posted_to_period_name, $posted_to_year_type, $posted_to_year_no, $posted_to_period_no_is_globally_locked, $posted_to_period_no_is_externally_locked, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetPOSTRequestPostAsyncWithHttpInfo
     *
     * Creates a journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no (optional)
     * @param  string $set_type (optional)
     * @param  string $description (optional)
     * @param  string $source (optional)
     * @param  string $source_id (optional)
     * @param  \DateTime $posted_date (optional)
     * @param  bool $is_reversed (optional)
     * @param  string $reverse_type (optional)
     * @param  \DateTime $reverse_date (optional)
     * @param  int $repeating_units (optional)
     * @param  string $repeating_type (optional)
     * @param  \DateTime $next_repeating_date (optional)
     * @param  bool $repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $staff (optional)
     * @param  string $lines (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  int $posted_to_period_no (optional)
     * @param  string $posted_to_period_name (optional)
     * @param  string $posted_to_year_type (optional)
     * @param  int $posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetPOSTRequestPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSet';
        $request = $this->journalSetPOSTRequestPostRequest($accept, $jiwa_stateful, $set_no, $set_type, $description, $source, $source_id, $posted_date, $is_reversed, $reverse_type, $reverse_date, $repeating_units, $repeating_type, $next_repeating_date, $repeating_will_end, $repeating_end_date, $last_saved_date_time, $staff, $lines, $notes, $documents, $posted_to_period_no, $posted_to_period_name, $posted_to_year_type, $posted_to_year_no, $posted_to_period_no_is_globally_locked, $posted_to_period_no_is_externally_locked, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetPOSTRequestPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $set_no (optional)
     * @param  string $set_type (optional)
     * @param  string $description (optional)
     * @param  string $source (optional)
     * @param  string $source_id (optional)
     * @param  \DateTime $posted_date (optional)
     * @param  bool $is_reversed (optional)
     * @param  string $reverse_type (optional)
     * @param  \DateTime $reverse_date (optional)
     * @param  int $repeating_units (optional)
     * @param  string $repeating_type (optional)
     * @param  \DateTime $next_repeating_date (optional)
     * @param  bool $repeating_will_end (optional)
     * @param  \DateTime $repeating_end_date (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $staff (optional)
     * @param  string $lines (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  int $posted_to_period_no (optional)
     * @param  string $posted_to_period_name (optional)
     * @param  string $posted_to_year_type (optional)
     * @param  int $posted_to_year_no (optional)
     * @param  bool $posted_to_period_no_is_globally_locked (optional)
     * @param  bool $posted_to_period_no_is_externally_locked (optional)
     * @param  \Jiwa\JiwaModel\JournalSetPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetPOSTRequestPostRequest($accept, $jiwa_stateful = null, $set_no = null, $set_type = null, $description = null, $source = null, $source_id = null, $posted_date = null, $is_reversed = null, $reverse_type = null, $reverse_date = null, $repeating_units = null, $repeating_type = null, $next_repeating_date = null, $repeating_will_end = null, $repeating_end_date = null, $last_saved_date_time = null, $staff = null, $lines = null, $notes = null, $documents = null, $posted_to_period_no = null, $posted_to_period_name = null, $posted_to_year_type = null, $posted_to_year_no = null, $posted_to_period_no_is_globally_locked = null, $posted_to_period_no_is_externally_locked = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetPOSTRequestPost'
            );
        }

        $resourcePath = '/JournalSets/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($set_no !== null) {
            $queryParams['SetNo'] = ObjectSerializer::toQueryValue($set_no);
        }
        // query params
        if ($set_type !== null) {
            $queryParams['SetType'] = ObjectSerializer::toQueryValue($set_type);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($source_id !== null) {
            $queryParams['SourceID'] = ObjectSerializer::toQueryValue($source_id);
        }
        // query params
        if ($posted_date !== null) {
            $queryParams['PostedDate'] = ObjectSerializer::toQueryValue($posted_date);
        }
        // query params
        if ($is_reversed !== null) {
            $queryParams['IsReversed'] = ObjectSerializer::toQueryValue($is_reversed);
        }
        // query params
        if ($reverse_type !== null) {
            $queryParams['ReverseType'] = ObjectSerializer::toQueryValue($reverse_type);
        }
        // query params
        if ($reverse_date !== null) {
            $queryParams['ReverseDate'] = ObjectSerializer::toQueryValue($reverse_date);
        }
        // query params
        if ($repeating_units !== null) {
            $queryParams['RepeatingUnits'] = ObjectSerializer::toQueryValue($repeating_units);
        }
        // query params
        if ($repeating_type !== null) {
            $queryParams['RepeatingType'] = ObjectSerializer::toQueryValue($repeating_type);
        }
        // query params
        if ($next_repeating_date !== null) {
            $queryParams['NextRepeatingDate'] = ObjectSerializer::toQueryValue($next_repeating_date);
        }
        // query params
        if ($repeating_will_end !== null) {
            $queryParams['RepeatingWillEnd'] = ObjectSerializer::toQueryValue($repeating_will_end);
        }
        // query params
        if ($repeating_end_date !== null) {
            $queryParams['RepeatingEndDate'] = ObjectSerializer::toQueryValue($repeating_end_date);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($staff !== null) {
            $queryParams['Staff'] = ObjectSerializer::toQueryValue($staff);
        }
        // query params
        if ($lines !== null) {
            $queryParams['Lines'] = ObjectSerializer::toQueryValue($lines);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($documents !== null) {
            $queryParams['Documents'] = ObjectSerializer::toQueryValue($documents);
        }
        // query params
        if ($posted_to_period_no !== null) {
            $queryParams['PostedToPeriodNo'] = ObjectSerializer::toQueryValue($posted_to_period_no);
        }
        // query params
        if ($posted_to_period_name !== null) {
            $queryParams['PostedToPeriodName'] = ObjectSerializer::toQueryValue($posted_to_period_name);
        }
        // query params
        if ($posted_to_year_type !== null) {
            $queryParams['PostedToYearType'] = ObjectSerializer::toQueryValue($posted_to_year_type);
        }
        // query params
        if ($posted_to_year_no !== null) {
            $queryParams['PostedToYearNo'] = ObjectSerializer::toQueryValue($posted_to_year_no);
        }
        // query params
        if ($posted_to_period_no_is_globally_locked !== null) {
            $queryParams['PostedToPeriodNoIsGloballyLocked'] = ObjectSerializer::toQueryValue($posted_to_period_no_is_globally_locked);
        }
        // query params
        if ($posted_to_period_no_is_externally_locked !== null) {
            $queryParams['PostedToPeriodNoIsExternallyLocked'] = ObjectSerializer::toQueryValue($posted_to_period_no_is_externally_locked);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation journalSetSAVERequestSaveGet
     *
     * Saves a stateful stateful journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id journal_set_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\JournalSet
     */
    public function journalSetSAVERequestSaveGet($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        list($response) = $this->journalSetSAVERequestSaveGetWithHttpInfo($accept, $jiwa_stateful, $journal_set_id);
        return $response;
    }

    /**
     * Operation journalSetSAVERequestSaveGetWithHttpInfo
     *
     * Saves a stateful stateful journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\JournalSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function journalSetSAVERequestSaveGetWithHttpInfo($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSet';
        $request = $this->journalSetSAVERequestSaveGetRequest($accept, $jiwa_stateful, $journal_set_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\JournalSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation journalSetSAVERequestSaveGetAsync
     *
     * Saves a stateful stateful journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetSAVERequestSaveGetAsync($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        return $this->journalSetSAVERequestSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful, $journal_set_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation journalSetSAVERequestSaveGetAsyncWithHttpInfo
     *
     * Saves a stateful stateful journal set.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function journalSetSAVERequestSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\JournalSet';
        $request = $this->journalSetSAVERequestSaveGetRequest($accept, $jiwa_stateful, $journal_set_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'journalSetSAVERequestSaveGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $journal_set_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function journalSetSAVERequestSaveGetRequest($accept, $jiwa_stateful = null, $journal_set_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling journalSetSAVERequestSaveGet'
            );
        }

        $resourcePath = '/JournalSets/Save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($journal_set_id !== null) {
            $queryParams['JournalSetID'] = ObjectSerializer::toQueryValue($journal_set_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
