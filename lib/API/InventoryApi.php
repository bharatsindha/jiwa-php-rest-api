<?php
/**
 * InventoryApi
 * PHP version 5
 *
 * @category Class
 * @package  Jiwa
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * JiwaAPI
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.28-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Jiwa\JiwaAPI;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Jiwa\ApiException;
use Jiwa\Configuration;
use Jiwa\HeaderSelector;
use Jiwa\ObjectSerializer;

/**
 * InventoryApi Class Doc Comment
 *
 * @category Class
 * @package  Jiwa
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class InventoryApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation inventoryABANDONRequestAbandonDelete
     *
     * Abandons a stateful inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id inventory_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryABANDONRequestAbandonDelete($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        list($response) = $this->inventoryABANDONRequestAbandonDeleteWithHttpInfo($accept, $jiwa_stateful, $inventory_id);
        return $response;
    }

    /**
     * Operation inventoryABANDONRequestAbandonDeleteWithHttpInfo
     *
     * Abandons a stateful inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryABANDONRequestAbandonDeleteWithHttpInfo($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful, $inventory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryABANDONRequestAbandonDeleteAsync
     *
     * Abandons a stateful inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryABANDONRequestAbandonDeleteAsync($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        return $this->inventoryABANDONRequestAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful, $inventory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryABANDONRequestAbandonDeleteAsyncWithHttpInfo
     *
     * Abandons a stateful inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryABANDONRequestAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful, $inventory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryABANDONRequestAbandonDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryABANDONRequestAbandonDelete'
            );
        }

        $resourcePath = '/Inventory/Abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inventory_id !== null) {
            $queryParams['InventoryID'] = ObjectSerializer::toQueryValue($inventory_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDelete
     *
     * Deletes a inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $alternate_child_id alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description linked_inventory_description (optional)
     * @param  string $notes notes (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDelete($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null)
    {
        list($response) = $this->inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes);
        return $response;
    }

    /**
     * Operation inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteWithHttpInfo
     *
     * Deletes a inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteAsync
     *
     * Deletes a inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteAsync($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null)
    {
        return $this->inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteAsyncWithHttpInfo
     *
     * Deletes a inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDeleteRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDelete'
            );
        }
        // verify the required parameter 'alternate_child_id' is set
        if ($alternate_child_id === null || (is_array($alternate_child_id) && count($alternate_child_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alternate_child_id when calling inventoryAlternateChildDELETERequestInventoryIDAlternateChildrenAlternateChildIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AlternateChildren/{AlternateChildID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($linked_inventory_id !== null) {
            $queryParams['LinkedInventoryID'] = ObjectSerializer::toQueryValue($linked_inventory_id);
        }
        // query params
        if ($linked_inventory_part_no !== null) {
            $queryParams['LinkedInventoryPartNo'] = ObjectSerializer::toQueryValue($linked_inventory_part_no);
        }
        // query params
        if ($linked_inventory_description !== null) {
            $queryParams['LinkedInventoryDescription'] = ObjectSerializer::toQueryValue($linked_inventory_description);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($alternate_child_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AlternateChildID' . '}',
                ObjectSerializer::toPathValue($alternate_child_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGet
     *
     * Retrieves an inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $alternate_child_id alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAlternateChild
     */
    public function inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGet($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetWithHttpInfo
     *
     * Retrieves an inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAlternateChild, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateChild';
        $request = $this->inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetAsync
     *
     * Retrieves an inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetAsync($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null)
    {
        return $this->inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetAsyncWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetAsyncWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateChild';
        $request = $this->inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGetRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGet'
            );
        }
        // verify the required parameter 'alternate_child_id' is set
        if ($alternate_child_id === null || (is_array($alternate_child_id) && count($alternate_child_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alternate_child_id when calling inventoryAlternateChildGETRequestInventoryIDAlternateChildrenAlternateChildIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AlternateChildren/{AlternateChildID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($alternate_child_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AlternateChildID' . '}',
                ObjectSerializer::toPathValue($alternate_child_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdate
     *
     * Updates a inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $alternate_child_id alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description linked_inventory_description (optional)
     * @param  string $notes notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAlternateChild
     */
    public function inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdate($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        list($response) = $this->inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes, $body);
        return $response;
    }

    /**
     * Operation inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateWithHttpInfo
     *
     * Updates a inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAlternateChild, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateChild';
        $request = $this->inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateAsync
     *
     * Updates a inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateAsync($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        return $this->inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateAsyncWithHttpInfo
     *
     * Updates a inventory alternate child.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateChild';
        $request = $this->inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $alternate_child_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdateRequest($accept, $inventory_id, $alternate_child_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdate'
            );
        }
        // verify the required parameter 'alternate_child_id' is set
        if ($alternate_child_id === null || (is_array($alternate_child_id) && count($alternate_child_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alternate_child_id when calling inventoryAlternateChildPATCHRequestInventoryIDAlternateChildrenAlternateChildIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AlternateChildren/{AlternateChildID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($linked_inventory_id !== null) {
            $queryParams['LinkedInventoryID'] = ObjectSerializer::toQueryValue($linked_inventory_id);
        }
        // query params
        if ($linked_inventory_part_no !== null) {
            $queryParams['LinkedInventoryPartNo'] = ObjectSerializer::toQueryValue($linked_inventory_part_no);
        }
        // query params
        if ($linked_inventory_description !== null) {
            $queryParams['LinkedInventoryDescription'] = ObjectSerializer::toQueryValue($linked_inventory_description);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($alternate_child_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AlternateChildID' . '}',
                ObjectSerializer::toPathValue($alternate_child_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPost
     *
     * Appends an alternate child to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description linked_inventory_description (optional)
     * @param  string $notes notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAlternateChild
     */
    public function inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPost($accept, $inventory_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        list($response) = $this->inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes, $body);
        return $response;
    }

    /**
     * Operation inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostWithHttpInfo
     *
     * Appends an alternate child to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAlternateChild, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateChild';
        $request = $this->inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostRequest($accept, $inventory_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostAsync
     *
     * Appends an alternate child to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostAsync($accept, $inventory_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        return $this->inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostAsyncWithHttpInfo
     *
     * Appends an alternate child to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateChild';
        $request = $this->inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostRequest($accept, $inventory_id, $jiwa_stateful, $linked_inventory_id, $linked_inventory_part_no, $linked_inventory_description, $notes, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $linked_inventory_id (optional)
     * @param  string $linked_inventory_part_no (optional)
     * @param  string $linked_inventory_description (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAlternateChildPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPostRequest($accept, $inventory_id, $jiwa_stateful = null, $linked_inventory_id = null, $linked_inventory_part_no = null, $linked_inventory_description = null, $notes = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAlternateChildPOSTRequestInventoryIDAlternateChildrenPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AlternateChildren';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($linked_inventory_id !== null) {
            $queryParams['LinkedInventoryID'] = ObjectSerializer::toQueryValue($linked_inventory_id);
        }
        // query params
        if ($linked_inventory_part_no !== null) {
            $queryParams['LinkedInventoryPartNo'] = ObjectSerializer::toQueryValue($linked_inventory_part_no);
        }
        // query params
        if ($linked_inventory_description !== null) {
            $queryParams['LinkedInventoryDescription'] = ObjectSerializer::toQueryValue($linked_inventory_description);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGet
     *
     * Retrieves a list of inventory alternate children.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAlternateChild[]
     */
    public function inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetWithHttpInfo
     *
     * Retrieves a list of inventory alternate children.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAlternateChild[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateChild[]';
        $request = $this->inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateChild[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetAsync
     *
     * Retrieves a list of inventory alternate children.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory alternate children.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateChild[]';
        $request = $this->inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAlternateChildrenGETManyRequestInventoryIDAlternateChildrenGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AlternateChildren';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGet
     *
     * Retrieves an inventory alternate parent.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $linked_inventory_id linked_inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAlternateParent
     */
    public function inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGet($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetWithHttpInfo($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetWithHttpInfo
     *
     * Retrieves an inventory alternate parent.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $linked_inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAlternateParent, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetWithHttpInfo($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateParent';
        $request = $this->inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetRequest($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateParent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateParent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateParent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateParent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetAsync
     *
     * Retrieves an inventory alternate parent.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $linked_inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetAsync($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetAsyncWithHttpInfo($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory alternate parent.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $linked_inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetAsyncWithHttpInfo($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateParent';
        $request = $this->inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetRequest($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $linked_inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGetRequest($accept, $inventory_id, $linked_inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGet'
            );
        }
        // verify the required parameter 'linked_inventory_id' is set
        if ($linked_inventory_id === null || (is_array($linked_inventory_id) && count($linked_inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linked_inventory_id when calling inventoryAlternateParentGETRequestInventoryIDAlternateParentsLinkedInventoryIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AlternateParents/{LinkedInventoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($linked_inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'LinkedInventoryID' . '}',
                ObjectSerializer::toPathValue($linked_inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGet
     *
     * Retrieves a list of inventory alternate parents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAlternateParent[]
     */
    public function inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetWithHttpInfo
     *
     * Retrieves a list of inventory alternate parents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAlternateParent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateParent[]';
        $request = $this->inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateParent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateParent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateParent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAlternateParent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetAsync
     *
     * Retrieves a list of inventory alternate parents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory alternate parents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAlternateParent[]';
        $request = $this->inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAlternateParentsGETManyRequestInventoryIDAlternateParentsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AlternateParents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDelete
     *
     * Deletes a inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $attribute_group_id attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template template (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $description description (optional)
     * @param  string $attributes attributes (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDelete($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null)
    {
        list($response) = $this->inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteWithHttpInfo
     *
     * Deletes a inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteAsync
     *
     * Deletes a inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteAsync($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null)
    {
        return $this->inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteAsyncWithHttpInfo
     *
     * Deletes a inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDeleteRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDelete'
            );
        }
        // verify the required parameter 'attribute_group_id' is set
        if ($attribute_group_id === null || (is_array($attribute_group_id) && count($attribute_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_id when calling inventoryAttributeGroupDELETERequestInventoryIDAttributeGroupsAttributeGroupIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AttributeGroups/{AttributeGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template !== null) {
            $queryParams['Template'] = ObjectSerializer::toQueryValue($template);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($attributes !== null) {
            $queryParams['Attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupID' . '}',
                ObjectSerializer::toPathValue($attribute_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGet
     *
     * Retrieves an inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $attribute_group_id attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroup
     */
    public function inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGet($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetWithHttpInfo
     *
     * Retrieves an inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroup';
        $request = $this->inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetAsync
     *
     * Retrieves an inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetAsync($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null)
    {
        return $this->inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroup';
        $request = $this->inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGetRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGet'
            );
        }
        // verify the required parameter 'attribute_group_id' is set
        if ($attribute_group_id === null || (is_array($attribute_group_id) && count($attribute_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_id when calling inventoryAttributeGroupGETRequestInventoryIDAttributeGroupsAttributeGroupIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AttributeGroups/{AttributeGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupID' . '}',
                ObjectSerializer::toPathValue($attribute_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdate
     *
     * Updates a inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $attribute_group_id attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template template (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $description description (optional)
     * @param  string $attributes attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroup
     */
    public function inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdate($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        list($response) = $this->inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes, $body);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateWithHttpInfo
     *
     * Updates a inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroup';
        $request = $this->inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateAsync
     *
     * Updates a inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateAsync($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        return $this->inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateAsyncWithHttpInfo
     *
     * Updates a inventory attribute group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroup';
        $request = $this->inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdateRequest($accept, $inventory_id, $attribute_group_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdate'
            );
        }
        // verify the required parameter 'attribute_group_id' is set
        if ($attribute_group_id === null || (is_array($attribute_group_id) && count($attribute_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_id when calling inventoryAttributeGroupPATCHRequestInventoryIDAttributeGroupsAttributeGroupIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AttributeGroups/{AttributeGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template !== null) {
            $queryParams['Template'] = ObjectSerializer::toQueryValue($template);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($attributes !== null) {
            $queryParams['Attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupID' . '}',
                ObjectSerializer::toPathValue($attribute_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPost
     *
     * Appends an attribute group to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template template (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $description description (optional)
     * @param  string $attributes attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroup
     */
    public function inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPost($accept, $inventory_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        list($response) = $this->inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes, $body);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostWithHttpInfo
     *
     * Appends an attribute group to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroup';
        $request = $this->inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostRequest($accept, $inventory_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostAsync
     *
     * Appends an attribute group to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostAsync($accept, $inventory_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        return $this->inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostAsyncWithHttpInfo
     *
     * Appends an attribute group to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroup';
        $request = $this->inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostRequest($accept, $inventory_id, $jiwa_stateful, $template, $last_saved_date_time, $description, $attributes, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $description (optional)
     * @param  string $attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPostRequest($accept, $inventory_id, $jiwa_stateful = null, $template = null, $last_saved_date_time = null, $description = null, $attributes = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAttributeGroupPOSTRequestInventoryIDAttributeGroupsPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AttributeGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template !== null) {
            $queryParams['Template'] = ObjectSerializer::toQueryValue($template);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($attributes !== null) {
            $queryParams['Attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDelete
     *
     * Abandons a stateful inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id attribute_group_template_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDelete($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteWithHttpInfo($accept, $jiwa_stateful, $attribute_group_template_id);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteWithHttpInfo
     *
     * Abandons a stateful inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteWithHttpInfo($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteRequest($accept, $jiwa_stateful, $attribute_group_template_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteAsync
     *
     * Abandons a stateful inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteAsync($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        return $this->inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful, $attribute_group_template_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteAsyncWithHttpInfo
     *
     * Abandons a stateful inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteRequest($accept, $jiwa_stateful, $attribute_group_template_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDeleteRequest($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateABANDONRequestAttributeGroupTemplatesAbandonDelete'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/Abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($attribute_group_template_id !== null) {
            $queryParams['AttributeGroupTemplateID'] = ObjectSerializer::toQueryValue($attribute_group_template_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDelete
     *
     * Deletes an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id template_attribute_id (required)
     * @param  string $attribute_group_template_id attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type attribute_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $name name (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDelete($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteWithHttpInfo($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful, $attribute_type, $item_no, $name);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteWithHttpInfo
     *
     * Deletes an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteWithHttpInfo($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteRequest($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful, $attribute_type, $item_no, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteAsync
     *
     * Deletes an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteAsync($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null)
    {
        return $this->inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteAsyncWithHttpInfo($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful, $attribute_type, $item_no, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteAsyncWithHttpInfo($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteRequest($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful, $attribute_type, $item_no, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDeleteRequest($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDelete'
            );
        }
        // verify the required parameter 'template_attribute_id' is set
        if ($template_attribute_id === null || (is_array($template_attribute_id) && count($template_attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_attribute_id when calling inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDelete'
            );
        }
        // verify the required parameter 'attribute_group_template_id' is set
        if ($attribute_group_template_id === null || (is_array($attribute_group_template_id) && count($attribute_group_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_template_id when calling inventoryAttributeGroupTemplateAttributeDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDDelete'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/{AttributeGroupTemplateID}/Attributes/{TemplateAttributeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($attribute_type !== null) {
            $queryParams['AttributeType'] = ObjectSerializer::toQueryValue($attribute_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($template_attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'TemplateAttributeID' . '}',
                ObjectSerializer::toPathValue($template_attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_group_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupTemplateID' . '}',
                ObjectSerializer::toPathValue($attribute_group_template_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGet
     *
     * Retrieves an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id attribute_group_template_id (required)
     * @param  string $template_attribute_id template_attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute
     */
    public function inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGet($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetWithHttpInfo($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetWithHttpInfo
     *
     * Retrieves an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  string $template_attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetWithHttpInfo($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute';
        $request = $this->inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetRequest($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetAsync
     *
     * Retrieves an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  string $template_attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetAsync($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful = null)
    {
        return $this->inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetAsyncWithHttpInfo($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  string $template_attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetAsyncWithHttpInfo($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute';
        $request = $this->inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetRequest($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  string $template_attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGetRequest($accept, $attribute_group_template_id, $template_attribute_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGet'
            );
        }
        // verify the required parameter 'attribute_group_template_id' is set
        if ($attribute_group_template_id === null || (is_array($attribute_group_template_id) && count($attribute_group_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_template_id when calling inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGet'
            );
        }
        // verify the required parameter 'template_attribute_id' is set
        if ($template_attribute_id === null || (is_array($template_attribute_id) && count($template_attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_attribute_id when calling inventoryAttributeGroupTemplateAttributeGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDGet'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/{AttributeGroupTemplateID}/Attributes/{TemplateAttributeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($attribute_group_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupTemplateID' . '}',
                ObjectSerializer::toPathValue($attribute_group_template_id),
                $resourcePath
            );
        }
        // path params
        if ($template_attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'TemplateAttributeID' . '}',
                ObjectSerializer::toPathValue($template_attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdate
     *
     * Updates an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id template_attribute_id (required)
     * @param  string $attribute_group_template_id attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type attribute_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $name name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute
     */
    public function inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdate($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateWithHttpInfo($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful, $attribute_type, $item_no, $name, $body);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateWithHttpInfo
     *
     * Updates an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateWithHttpInfo($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute';
        $request = $this->inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateRequest($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful, $attribute_type, $item_no, $name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateAsync
     *
     * Updates an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateAsync($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        return $this->inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateAsyncWithHttpInfo($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful, $attribute_type, $item_no, $name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory attribute group template attribute.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateAsyncWithHttpInfo($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute';
        $request = $this->inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateRequest($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful, $attribute_type, $item_no, $name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $template_attribute_id (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdateRequest($accept, $template_attribute_id, $attribute_group_template_id, $jiwa_stateful = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdate'
            );
        }
        // verify the required parameter 'template_attribute_id' is set
        if ($template_attribute_id === null || (is_array($template_attribute_id) && count($template_attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_attribute_id when calling inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdate'
            );
        }
        // verify the required parameter 'attribute_group_template_id' is set
        if ($attribute_group_template_id === null || (is_array($attribute_group_template_id) && count($attribute_group_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_template_id when calling inventoryAttributeGroupTemplateAttributePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesTemplateAttributeIDUpdate'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/{AttributeGroupTemplateID}/Attributes/{TemplateAttributeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($attribute_type !== null) {
            $queryParams['AttributeType'] = ObjectSerializer::toQueryValue($attribute_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($template_attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'TemplateAttributeID' . '}',
                ObjectSerializer::toPathValue($template_attribute_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_group_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupTemplateID' . '}',
                ObjectSerializer::toPathValue($attribute_group_template_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePost
     *
     * Appends an inventory attribute group template attribute to an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute_id template_attribute_id (optional)
     * @param  int $attribute_type attribute_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $name name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute
     */
    public function inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePost($accept, $attribute_group_template_id, $jiwa_stateful = null, $template_attribute_id = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful, $template_attribute_id, $attribute_type, $item_no, $name, $body);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostWithHttpInfo
     *
     * Appends an inventory attribute group template attribute to an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute_id (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null, $template_attribute_id = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute';
        $request = $this->inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostRequest($accept, $attribute_group_template_id, $jiwa_stateful, $template_attribute_id, $attribute_type, $item_no, $name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostAsync
     *
     * Appends an inventory attribute group template attribute to an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute_id (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostAsync($accept, $attribute_group_template_id, $jiwa_stateful = null, $template_attribute_id = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        return $this->inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful, $template_attribute_id, $attribute_type, $item_no, $name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostAsyncWithHttpInfo
     *
     * Appends an inventory attribute group template attribute to an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute_id (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null, $template_attribute_id = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute';
        $request = $this->inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostRequest($accept, $attribute_group_template_id, $jiwa_stateful, $template_attribute_id, $attribute_type, $item_no, $name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute_id (optional)
     * @param  int $attribute_type (optional)
     * @param  int $item_no (optional)
     * @param  string $name (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttributePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePostRequest($accept, $attribute_group_template_id, $jiwa_stateful = null, $template_attribute_id = null, $attribute_type = null, $item_no = null, $name = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePost'
            );
        }
        // verify the required parameter 'attribute_group_template_id' is set
        if ($attribute_group_template_id === null || (is_array($attribute_group_template_id) && count($attribute_group_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_template_id when calling inventoryAttributeGroupTemplateAttributePOSTRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributePost'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/{AttributeGroupTemplateID}/Attribute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template_attribute_id !== null) {
            $queryParams['TemplateAttributeID'] = ObjectSerializer::toQueryValue($template_attribute_id);
        }
        // query params
        if ($attribute_type !== null) {
            $queryParams['AttributeType'] = ObjectSerializer::toQueryValue($attribute_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($attribute_group_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupTemplateID' . '}',
                ObjectSerializer::toPathValue($attribute_group_template_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGet
     *
     * Retrieves a list of inventory attribute group template attributes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute[]
     */
    public function inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGet($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetWithHttpInfo
     *
     * Retrieves a list of inventory attribute group template attributes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute[]';
        $request = $this->inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetRequest($accept, $attribute_group_template_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetAsync
     *
     * Retrieves a list of inventory attribute group template attributes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetAsync($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        return $this->inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory attribute group template attributes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplateAttribute[]';
        $request = $this->inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetRequest($accept, $attribute_group_template_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGetRequest($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGet'
            );
        }
        // verify the required parameter 'attribute_group_template_id' is set
        if ($attribute_group_template_id === null || (is_array($attribute_group_template_id) && count($attribute_group_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_template_id when calling inventoryAttributeGroupTemplateAttributesGETManyRequestAttributeGroupTemplatesAttributeGroupTemplateIDAttributesGet'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/{AttributeGroupTemplateID}/Attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($attribute_group_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupTemplateID' . '}',
                ObjectSerializer::toPathValue($attribute_group_template_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDelete
     *
     * Deletes an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDelete($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteWithHttpInfo
     *
     * Deletes an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteRequest($accept, $attribute_group_template_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteAsync
     *
     * Deletes an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteAsync($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        return $this->inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteRequest($accept, $attribute_group_template_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDeleteRequest($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDelete'
            );
        }
        // verify the required parameter 'attribute_group_template_id' is set
        if ($attribute_group_template_id === null || (is_array($attribute_group_template_id) && count($attribute_group_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_template_id when calling inventoryAttributeGroupTemplateDELETERequestAttributeGroupTemplatesAttributeGroupTemplateIDDelete'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/{AttributeGroupTemplateID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($attribute_group_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupTemplateID' . '}',
                ObjectSerializer::toPathValue($attribute_group_template_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGet
     *
     * Retrieves an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupTemplate
     */
    public function inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGet($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetWithHttpInfo
     *
     * Retrieves an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate';
        $request = $this->inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetRequest($accept, $attribute_group_template_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetAsync
     *
     * Retrieves an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetAsync($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        return $this->inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate';
        $request = $this->inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetRequest($accept, $attribute_group_template_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGetRequest($accept, $attribute_group_template_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGet'
            );
        }
        // verify the required parameter 'attribute_group_template_id' is set
        if ($attribute_group_template_id === null || (is_array($attribute_group_template_id) && count($attribute_group_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_template_id when calling inventoryAttributeGroupTemplateGETRequestAttributeGroupTemplatesAttributeGroupTemplateIDGet'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/{AttributeGroupTemplateID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($attribute_group_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupTemplateID' . '}',
                ObjectSerializer::toPathValue($attribute_group_template_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdate
     *
     * Updates an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name name (optional)
     * @param  bool $is_enabled is_enabled (optional)
     * @param  string $template_attributes template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupTemplate
     */
    public function inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdate($accept, $attribute_group_template_id, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful, $name, $is_enabled, $template_attributes, $body);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateWithHttpInfo
     *
     * Updates an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name (optional)
     * @param  bool $is_enabled (optional)
     * @param  string $template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate';
        $request = $this->inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateRequest($accept, $attribute_group_template_id, $jiwa_stateful, $name, $is_enabled, $template_attributes, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateAsync
     *
     * Updates an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name (optional)
     * @param  bool $is_enabled (optional)
     * @param  string $template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateAsync($accept, $attribute_group_template_id, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        return $this->inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful, $name, $is_enabled, $template_attributes, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name (optional)
     * @param  bool $is_enabled (optional)
     * @param  string $template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateAsyncWithHttpInfo($accept, $attribute_group_template_id, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate';
        $request = $this->inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateRequest($accept, $attribute_group_template_id, $jiwa_stateful, $name, $is_enabled, $template_attributes, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $attribute_group_template_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name (optional)
     * @param  bool $is_enabled (optional)
     * @param  string $template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdateRequest($accept, $attribute_group_template_id, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdate'
            );
        }
        // verify the required parameter 'attribute_group_template_id' is set
        if ($attribute_group_template_id === null || (is_array($attribute_group_template_id) && count($attribute_group_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_template_id when calling inventoryAttributeGroupTemplatePATCHRequestAttributeGroupTemplatesAttributeGroupTemplateIDUpdate'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/{AttributeGroupTemplateID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($is_enabled !== null) {
            $queryParams['IsEnabled'] = ObjectSerializer::toQueryValue($is_enabled);
        }
        // query params
        if ($template_attributes !== null) {
            $queryParams['TemplateAttributes'] = ObjectSerializer::toQueryValue($template_attributes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($attribute_group_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupTemplateID' . '}',
                ObjectSerializer::toPathValue($attribute_group_template_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPost
     *
     * Creates a new inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name name (optional)
     * @param  bool $is_enabled is_enabled (optional)
     * @param  string $template_attributes template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupTemplate
     */
    public function inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPost($accept, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostWithHttpInfo($accept, $jiwa_stateful, $name, $is_enabled, $template_attributes, $body);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostWithHttpInfo
     *
     * Creates a new inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name (optional)
     * @param  bool $is_enabled (optional)
     * @param  string $template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostWithHttpInfo($accept, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate';
        $request = $this->inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostRequest($accept, $jiwa_stateful, $name, $is_enabled, $template_attributes, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostAsync
     *
     * Creates a new inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name (optional)
     * @param  bool $is_enabled (optional)
     * @param  string $template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostAsync($accept, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        return $this->inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $name, $is_enabled, $template_attributes, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostAsyncWithHttpInfo
     *
     * Creates a new inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name (optional)
     * @param  bool $is_enabled (optional)
     * @param  string $template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate';
        $request = $this->inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostRequest($accept, $jiwa_stateful, $name, $is_enabled, $template_attributes, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $name (optional)
     * @param  bool $is_enabled (optional)
     * @param  string $template_attributes (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeGroupTemplatePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPostRequest($accept, $jiwa_stateful = null, $name = null, $is_enabled = null, $template_attributes = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplatePOSTRequestAttributeGroupTemplatesPost'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($is_enabled !== null) {
            $queryParams['IsEnabled'] = ObjectSerializer::toQueryValue($is_enabled);
        }
        // query params
        if ($template_attributes !== null) {
            $queryParams['TemplateAttributes'] = ObjectSerializer::toQueryValue($template_attributes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGet
     *
     * Saves a stateful inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id attribute_group_template_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupTemplate
     */
    public function inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGet($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        list($response) = $this->inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetWithHttpInfo($accept, $jiwa_stateful, $attribute_group_template_id);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetWithHttpInfo
     *
     * Saves a stateful inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetWithHttpInfo($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate';
        $request = $this->inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetRequest($accept, $jiwa_stateful, $attribute_group_template_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetAsync
     *
     * Saves a stateful inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetAsync($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        return $this->inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful, $attribute_group_template_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetAsyncWithHttpInfo
     *
     * Saves a stateful inventory attribute group template.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupTemplate';
        $request = $this->inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetRequest($accept, $jiwa_stateful, $attribute_group_template_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $attribute_group_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGetRequest($accept, $jiwa_stateful = null, $attribute_group_template_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupTemplateSAVERequestAttributeGroupTemplatesSaveGet'
            );
        }

        $resourcePath = '/Inventory/AttributeGroupTemplates/Save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($attribute_group_template_id !== null) {
            $queryParams['AttributeGroupTemplateID'] = ObjectSerializer::toQueryValue($attribute_group_template_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGet
     *
     * Retrieves a list of inventory attribute groups.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroup[]
     */
    public function inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetWithHttpInfo
     *
     * Retrieves a list of inventory attribute groups.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroup[]';
        $request = $this->inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetAsync
     *
     * Retrieves a list of inventory attribute groups.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory attribute groups.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroup[]';
        $request = $this->inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAttributeGroupsGETManyRequestInventoryIDAttributeGroupsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AttributeGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGet
     *
     * Retrieves an inventory attribute value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $attribute_group_id attribute_group_id (required)
     * @param  string $attribute_id attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupAttribute
     */
    public function inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGet($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetWithHttpInfo($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetWithHttpInfo
     *
     * Retrieves an inventory attribute value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  string $attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetWithHttpInfo($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute';
        $request = $this->inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetRequest($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetAsync
     *
     * Retrieves an inventory attribute value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  string $attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetAsync($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null)
    {
        return $this->inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory attribute value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  string $attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute';
        $request = $this->inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetRequest($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  string $attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGetRequest($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGet'
            );
        }
        // verify the required parameter 'attribute_group_id' is set
        if ($attribute_group_id === null || (is_array($attribute_group_id) && count($attribute_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_id when calling inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGet'
            );
        }
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling inventoryAttributeValueGETRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AttributeGroups/{AttributeGroupID}/AttributeValues/{AttributeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupID' . '}',
                ObjectSerializer::toPathValue($attribute_group_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeID' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdate
     *
     * Updates an inventory attribute value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $attribute_group_id attribute_group_id (required)
     * @param  string $attribute_id attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute template_attribute (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $contents contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeValuePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryAttributeGroupAttribute
     */
    public function inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdate($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null, $template_attribute = null, $last_saved_date_time = null, $contents = null, $body = null)
    {
        list($response) = $this->inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateWithHttpInfo($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful, $template_attribute, $last_saved_date_time, $contents, $body);
        return $response;
    }

    /**
     * Operation inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateWithHttpInfo
     *
     * Updates an inventory attribute value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  string $attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeValuePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryAttributeGroupAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateWithHttpInfo($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null, $template_attribute = null, $last_saved_date_time = null, $contents = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute';
        $request = $this->inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateRequest($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful, $template_attribute, $last_saved_date_time, $contents, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateAsync
     *
     * Updates an inventory attribute value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  string $attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateAsync($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null, $template_attribute = null, $last_saved_date_time = null, $contents = null, $body = null)
    {
        return $this->inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful, $template_attribute, $last_saved_date_time, $contents, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory attribute value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  string $attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null, $template_attribute = null, $last_saved_date_time = null, $contents = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryAttributeGroupAttribute';
        $request = $this->inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateRequest($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful, $template_attribute, $last_saved_date_time, $contents, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $attribute_group_id (required)
     * @param  string $attribute_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $template_attribute (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryAttributeValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdateRequest($accept, $inventory_id, $attribute_group_id, $attribute_id, $jiwa_stateful = null, $template_attribute = null, $last_saved_date_time = null, $contents = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdate'
            );
        }
        // verify the required parameter 'attribute_group_id' is set
        if ($attribute_group_id === null || (is_array($attribute_group_id) && count($attribute_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_group_id when calling inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdate'
            );
        }
        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling inventoryAttributeValuePATCHRequestInventoryIDAttributeGroupsAttributeGroupIDAttributeValuesAttributeIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/AttributeGroups/{AttributeGroupID}/AttributeValues/{AttributeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template_attribute !== null) {
            $queryParams['TemplateAttribute'] = ObjectSerializer::toQueryValue($template_attribute);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($contents !== null) {
            $queryParams['Contents'] = ObjectSerializer::toQueryValue($contents);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeGroupID' . '}',
                ObjectSerializer::toPathValue($attribute_group_id),
                $resourcePath
            );
        }
        // path params
        if ($attribute_id !== null) {
            $resourcePath = str_replace(
                '{' . 'AttributeID' . '}',
                ObjectSerializer::toPathValue($attribute_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGet
     *
     * Retrieves a budget from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $logical_warehouse_id logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index month_index (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryBudget
     */
    public function inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGet($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null)
    {
        list($response) = $this->inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $month_index);
        return $response;
    }

    /**
     * Operation inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetWithHttpInfo
     *
     * Retrieves a budget from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryBudget, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryBudget';
        $request = $this->inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $month_index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetAsync
     *
     * Retrieves a budget from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetAsync($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null)
    {
        return $this->inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetAsyncWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $month_index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetAsyncWithHttpInfo
     *
     * Retrieves a budget from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetAsyncWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryBudget';
        $request = $this->inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $month_index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGetRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGet'
            );
        }
        // verify the required parameter 'logical_warehouse_id' is set
        if ($logical_warehouse_id === null || (is_array($logical_warehouse_id) && count($logical_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logical_warehouse_id when calling inventoryBudgetGETRequestInventoryIDBudgetsLogicalWarehouseIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Budgets/{LogicalWarehouseID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($month_index !== null) {
            $queryParams['MonthIndex'] = ObjectSerializer::toQueryValue($month_index);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($logical_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'LogicalWarehouseID' . '}',
                ObjectSerializer::toPathValue($logical_warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdate
     *
     * Updates a budget.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $logical_warehouse_id logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index month_index (optional)
     * @param  \DateTime $month_start_date month_start_date (optional)
     * @param  \DateTime $month_end_date month_end_date (optional)
     * @param  double $budget_units budget_units (optional)
     * @param  double $budget_value budget_value (optional)
     * @param  string $logical_warehouse_description logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryBudgetPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryBudget
     */
    public function inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdate($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null, $month_start_date = null, $month_end_date = null, $budget_units = null, $budget_value = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        list($response) = $this->inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $month_index, $month_start_date, $month_end_date, $budget_units, $budget_value, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);
        return $response;
    }

    /**
     * Operation inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateWithHttpInfo
     *
     * Updates a budget.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index (optional)
     * @param  \DateTime $month_start_date (optional)
     * @param  \DateTime $month_end_date (optional)
     * @param  double $budget_units (optional)
     * @param  double $budget_value (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryBudgetPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryBudget, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null, $month_start_date = null, $month_end_date = null, $budget_units = null, $budget_value = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryBudget';
        $request = $this->inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $month_index, $month_start_date, $month_end_date, $budget_units, $budget_value, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateAsync
     *
     * Updates a budget.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index (optional)
     * @param  \DateTime $month_start_date (optional)
     * @param  \DateTime $month_end_date (optional)
     * @param  double $budget_units (optional)
     * @param  double $budget_value (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryBudgetPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateAsync($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null, $month_start_date = null, $month_end_date = null, $budget_units = null, $budget_value = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        return $this->inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $month_index, $month_start_date, $month_end_date, $budget_units, $budget_value, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateAsyncWithHttpInfo
     *
     * Updates a budget.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index (optional)
     * @param  \DateTime $month_start_date (optional)
     * @param  \DateTime $month_end_date (optional)
     * @param  double $budget_units (optional)
     * @param  double $budget_value (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryBudgetPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null, $month_start_date = null, $month_end_date = null, $budget_units = null, $budget_value = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryBudget';
        $request = $this->inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $month_index, $month_start_date, $month_end_date, $budget_units, $budget_value, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $month_index (optional)
     * @param  \DateTime $month_start_date (optional)
     * @param  \DateTime $month_end_date (optional)
     * @param  double $budget_units (optional)
     * @param  double $budget_value (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryBudgetPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdateRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $month_index = null, $month_start_date = null, $month_end_date = null, $budget_units = null, $budget_value = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdate'
            );
        }
        // verify the required parameter 'logical_warehouse_id' is set
        if ($logical_warehouse_id === null || (is_array($logical_warehouse_id) && count($logical_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logical_warehouse_id when calling inventoryBudgetPATCHRequestInventoryIDBudgetsLogicalWarehouseIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Budgets/{LogicalWarehouseID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($month_index !== null) {
            $queryParams['MonthIndex'] = ObjectSerializer::toQueryValue($month_index);
        }
        // query params
        if ($month_start_date !== null) {
            $queryParams['MonthStartDate'] = ObjectSerializer::toQueryValue($month_start_date);
        }
        // query params
        if ($month_end_date !== null) {
            $queryParams['MonthEndDate'] = ObjectSerializer::toQueryValue($month_end_date);
        }
        // query params
        if ($budget_units !== null) {
            $queryParams['BudgetUnits'] = ObjectSerializer::toQueryValue($budget_units);
        }
        // query params
        if ($budget_value !== null) {
            $queryParams['BudgetValue'] = ObjectSerializer::toQueryValue($budget_value);
        }
        // query params
        if ($logical_warehouse_description !== null) {
            $queryParams['LogicalWarehouseDescription'] = ObjectSerializer::toQueryValue($logical_warehouse_description);
        }
        // query params
        if ($physical_warehouse_id !== null) {
            $queryParams['PhysicalWarehouseID'] = ObjectSerializer::toQueryValue($physical_warehouse_id);
        }
        // query params
        if ($physical_warehouse_description !== null) {
            $queryParams['PhysicalWarehouseDescription'] = ObjectSerializer::toQueryValue($physical_warehouse_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($logical_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'LogicalWarehouseID' . '}',
                ObjectSerializer::toPathValue($logical_warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryBudgetsGETManyRequestInventoryIDBudgetsGet
     *
     * Retrieves a list of budgets for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $logical_warehouse_id logical_warehouse_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryBudget[]
     */
    public function inventoryBudgetsGETManyRequestInventoryIDBudgetsGet($accept, $inventory_id, $jiwa_stateful = null, $logical_warehouse_id = null)
    {
        list($response) = $this->inventoryBudgetsGETManyRequestInventoryIDBudgetsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $logical_warehouse_id);
        return $response;
    }

    /**
     * Operation inventoryBudgetsGETManyRequestInventoryIDBudgetsGetWithHttpInfo
     *
     * Retrieves a list of budgets for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $logical_warehouse_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryBudget[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryBudgetsGETManyRequestInventoryIDBudgetsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $logical_warehouse_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryBudget[]';
        $request = $this->inventoryBudgetsGETManyRequestInventoryIDBudgetsGetRequest($accept, $inventory_id, $jiwa_stateful, $logical_warehouse_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryBudget[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryBudgetsGETManyRequestInventoryIDBudgetsGetAsync
     *
     * Retrieves a list of budgets for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $logical_warehouse_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryBudgetsGETManyRequestInventoryIDBudgetsGetAsync($accept, $inventory_id, $jiwa_stateful = null, $logical_warehouse_id = null)
    {
        return $this->inventoryBudgetsGETManyRequestInventoryIDBudgetsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $logical_warehouse_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryBudgetsGETManyRequestInventoryIDBudgetsGetAsyncWithHttpInfo
     *
     * Retrieves a list of budgets for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $logical_warehouse_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryBudgetsGETManyRequestInventoryIDBudgetsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $logical_warehouse_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryBudget[]';
        $request = $this->inventoryBudgetsGETManyRequestInventoryIDBudgetsGetRequest($accept, $inventory_id, $jiwa_stateful, $logical_warehouse_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryBudgetsGETManyRequestInventoryIDBudgetsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $logical_warehouse_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryBudgetsGETManyRequestInventoryIDBudgetsGetRequest($accept, $inventory_id, $jiwa_stateful = null, $logical_warehouse_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryBudgetsGETManyRequestInventoryIDBudgetsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryBudgetsGETManyRequestInventoryIDBudgetsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Budgets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($logical_warehouse_id !== null) {
            $queryParams['LogicalWarehouseID'] = ObjectSerializer::toQueryValue($logical_warehouse_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCategoriesABANDONRequestCategoriesAbandonDelete
     *
     * Abandons a stateful inventory categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryCategoriesABANDONRequestCategoriesAbandonDelete($accept, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryCategoriesABANDONRequestCategoriesAbandonDeleteWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryCategoriesABANDONRequestCategoriesAbandonDeleteWithHttpInfo
     *
     * Abandons a stateful inventory categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCategoriesABANDONRequestCategoriesAbandonDeleteWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryCategoriesABANDONRequestCategoriesAbandonDeleteRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCategoriesABANDONRequestCategoriesAbandonDeleteAsync
     *
     * Abandons a stateful inventory categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoriesABANDONRequestCategoriesAbandonDeleteAsync($accept, $jiwa_stateful = null)
    {
        return $this->inventoryCategoriesABANDONRequestCategoriesAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCategoriesABANDONRequestCategoriesAbandonDeleteAsyncWithHttpInfo
     *
     * Abandons a stateful inventory categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoriesABANDONRequestCategoriesAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryCategoriesABANDONRequestCategoriesAbandonDeleteRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCategoriesABANDONRequestCategoriesAbandonDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCategoriesABANDONRequestCategoriesAbandonDeleteRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCategoriesABANDONRequestCategoriesAbandonDelete'
            );
        }

        $resourcePath = '/Inventory/Categories/Abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCategoriesSAVERequestCategoriesSaveGet
     *
     * Saves a stateful inventory categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryCategory[]
     */
    public function inventoryCategoriesSAVERequestCategoriesSaveGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryCategoriesSAVERequestCategoriesSaveGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryCategoriesSAVERequestCategoriesSaveGetWithHttpInfo
     *
     * Saves a stateful inventory categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryCategory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCategoriesSAVERequestCategoriesSaveGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryCategory[]';
        $request = $this->inventoryCategoriesSAVERequestCategoriesSaveGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCategoriesSAVERequestCategoriesSaveGetAsync
     *
     * Saves a stateful inventory categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoriesSAVERequestCategoriesSaveGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->inventoryCategoriesSAVERequestCategoriesSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCategoriesSAVERequestCategoriesSaveGetAsyncWithHttpInfo
     *
     * Saves a stateful inventory categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoriesSAVERequestCategoriesSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryCategory[]';
        $request = $this->inventoryCategoriesSAVERequestCategoriesSaveGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCategoriesSAVERequestCategoriesSaveGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCategoriesSAVERequestCategoriesSaveGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCategoriesSAVERequestCategoriesSaveGet'
            );
        }

        $resourcePath = '/Inventory/Categories/Save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCategoryDELETERequestCategoriesCategoryIDDelete
     *
     * Deletes an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryCategoryDELETERequestCategoriesCategoryIDDelete($accept, $category_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryCategoryDELETERequestCategoriesCategoryIDDeleteWithHttpInfo($accept, $category_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryCategoryDELETERequestCategoriesCategoryIDDeleteWithHttpInfo
     *
     * Deletes an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCategoryDELETERequestCategoriesCategoryIDDeleteWithHttpInfo($accept, $category_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryCategoryDELETERequestCategoriesCategoryIDDeleteRequest($accept, $category_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCategoryDELETERequestCategoriesCategoryIDDeleteAsync
     *
     * Deletes an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoryDELETERequestCategoriesCategoryIDDeleteAsync($accept, $category_id, $jiwa_stateful = null)
    {
        return $this->inventoryCategoryDELETERequestCategoriesCategoryIDDeleteAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCategoryDELETERequestCategoriesCategoryIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoryDELETERequestCategoriesCategoryIDDeleteAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryCategoryDELETERequestCategoriesCategoryIDDeleteRequest($accept, $category_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCategoryDELETERequestCategoriesCategoryIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCategoryDELETERequestCategoriesCategoryIDDeleteRequest($accept, $category_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCategoryDELETERequestCategoriesCategoryIDDelete'
            );
        }
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling inventoryCategoryDELETERequestCategoriesCategoryIDDelete'
            );
        }

        $resourcePath = '/Inventory/Categories/{CategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'CategoryID' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCategoryGETRequestCategoriesCategoryIDGet
     *
     * Retrieves an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryCategory
     */
    public function inventoryCategoryGETRequestCategoriesCategoryIDGet($accept, $category_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryCategoryGETRequestCategoriesCategoryIDGetWithHttpInfo($accept, $category_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryCategoryGETRequestCategoriesCategoryIDGetWithHttpInfo
     *
     * Retrieves an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCategoryGETRequestCategoriesCategoryIDGetWithHttpInfo($accept, $category_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryCategory';
        $request = $this->inventoryCategoryGETRequestCategoriesCategoryIDGetRequest($accept, $category_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCategoryGETRequestCategoriesCategoryIDGetAsync
     *
     * Retrieves an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoryGETRequestCategoriesCategoryIDGetAsync($accept, $category_id, $jiwa_stateful = null)
    {
        return $this->inventoryCategoryGETRequestCategoriesCategoryIDGetAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCategoryGETRequestCategoriesCategoryIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoryGETRequestCategoriesCategoryIDGetAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryCategory';
        $request = $this->inventoryCategoryGETRequestCategoriesCategoryIDGetRequest($accept, $category_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCategoryGETRequestCategoriesCategoryIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCategoryGETRequestCategoriesCategoryIDGetRequest($accept, $category_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCategoryGETRequestCategoriesCategoryIDGet'
            );
        }
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling inventoryCategoryGETRequestCategoriesCategoryIDGet'
            );
        }

        $resourcePath = '/Inventory/Categories/{CategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'CategoryID' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCategoryPATCHRequestCategoriesCategoryIDUpdate
     *
     * Updates an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no category_no (optional)
     * @param  string $description description (optional)
     * @param  bool $is_default is_default (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $picture picture (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryCategory
     */
    public function inventoryCategoryPATCHRequestCategoriesCategoryIDUpdate($accept, $category_id, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $last_saved_date_time = null, $picture = null, $custom_field_values = null, $body = null)
    {
        list($response) = $this->inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateWithHttpInfo($accept, $category_id, $jiwa_stateful, $category_no, $description, $is_default, $last_saved_date_time, $picture, $custom_field_values, $body);
        return $response;
    }

    /**
     * Operation inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateWithHttpInfo
     *
     * Updates an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $picture (optional)
     * @param  string $custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateWithHttpInfo($accept, $category_id, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $last_saved_date_time = null, $picture = null, $custom_field_values = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryCategory';
        $request = $this->inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateRequest($accept, $category_id, $jiwa_stateful, $category_no, $description, $is_default, $last_saved_date_time, $picture, $custom_field_values, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateAsync
     *
     * Updates an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $picture (optional)
     * @param  string $custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateAsync($accept, $category_id, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $last_saved_date_time = null, $picture = null, $custom_field_values = null, $body = null)
    {
        return $this->inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful, $category_no, $description, $is_default, $last_saved_date_time, $picture, $custom_field_values, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $picture (optional)
     * @param  string $custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $last_saved_date_time = null, $picture = null, $custom_field_values = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryCategory';
        $request = $this->inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateRequest($accept, $category_id, $jiwa_stateful, $category_no, $description, $is_default, $last_saved_date_time, $picture, $custom_field_values, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCategoryPATCHRequestCategoriesCategoryIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $picture (optional)
     * @param  string $custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCategoryPATCHRequestCategoriesCategoryIDUpdateRequest($accept, $category_id, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $last_saved_date_time = null, $picture = null, $custom_field_values = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCategoryPATCHRequestCategoriesCategoryIDUpdate'
            );
        }
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling inventoryCategoryPATCHRequestCategoriesCategoryIDUpdate'
            );
        }

        $resourcePath = '/Inventory/Categories/{CategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category_no !== null) {
            $queryParams['CategoryNo'] = ObjectSerializer::toQueryValue($category_no);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($picture !== null) {
            $queryParams['Picture'] = ObjectSerializer::toQueryValue($picture);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'CategoryID' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCategoryPOSTRequestCategoriesPost
     *
     * Creates an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no category_no (optional)
     * @param  string $description description (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $picture picture (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryCategory
     */
    public function inventoryCategoryPOSTRequestCategoriesPost($accept, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $picture = null, $custom_field_values = null, $body = null)
    {
        list($response) = $this->inventoryCategoryPOSTRequestCategoriesPostWithHttpInfo($accept, $jiwa_stateful, $category_no, $description, $is_default, $picture, $custom_field_values, $body);
        return $response;
    }

    /**
     * Operation inventoryCategoryPOSTRequestCategoriesPostWithHttpInfo
     *
     * Creates an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  string $picture (optional)
     * @param  string $custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCategoryPOSTRequestCategoriesPostWithHttpInfo($accept, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $picture = null, $custom_field_values = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryCategory';
        $request = $this->inventoryCategoryPOSTRequestCategoriesPostRequest($accept, $jiwa_stateful, $category_no, $description, $is_default, $picture, $custom_field_values, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCategoryPOSTRequestCategoriesPostAsync
     *
     * Creates an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  string $picture (optional)
     * @param  string $custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoryPOSTRequestCategoriesPostAsync($accept, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $picture = null, $custom_field_values = null, $body = null)
    {
        return $this->inventoryCategoryPOSTRequestCategoriesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $category_no, $description, $is_default, $picture, $custom_field_values, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCategoryPOSTRequestCategoriesPostAsyncWithHttpInfo
     *
     * Creates an inventory category.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  string $picture (optional)
     * @param  string $custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCategoryPOSTRequestCategoriesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $picture = null, $custom_field_values = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryCategory';
        $request = $this->inventoryCategoryPOSTRequestCategoriesPostRequest($accept, $jiwa_stateful, $category_no, $description, $is_default, $picture, $custom_field_values, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCategoryPOSTRequestCategoriesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  int $category_no (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  string $picture (optional)
     * @param  string $custom_field_values (optional)
     * @param  \Jiwa\JiwaModel\InventoryCategoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCategoryPOSTRequestCategoriesPostRequest($accept, $jiwa_stateful = null, $category_no = null, $description = null, $is_default = null, $picture = null, $custom_field_values = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCategoryPOSTRequestCategoriesPost'
            );
        }

        $resourcePath = '/Inventory/Categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category_no !== null) {
            $queryParams['CategoryNo'] = ObjectSerializer::toQueryValue($category_no);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($picture !== null) {
            $queryParams['Picture'] = ObjectSerializer::toQueryValue($picture);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryClassificationABANDONRequestClassificationsAbandonDelete
     *
     * Abandons a stateful inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id rec_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryClassificationABANDONRequestClassificationsAbandonDelete($accept, $jiwa_stateful = null, $rec_id = null)
    {
        list($response) = $this->inventoryClassificationABANDONRequestClassificationsAbandonDeleteWithHttpInfo($accept, $jiwa_stateful, $rec_id);
        return $response;
    }

    /**
     * Operation inventoryClassificationABANDONRequestClassificationsAbandonDeleteWithHttpInfo
     *
     * Abandons a stateful inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryClassificationABANDONRequestClassificationsAbandonDeleteWithHttpInfo($accept, $jiwa_stateful = null, $rec_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryClassificationABANDONRequestClassificationsAbandonDeleteRequest($accept, $jiwa_stateful, $rec_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryClassificationABANDONRequestClassificationsAbandonDeleteAsync
     *
     * Abandons a stateful inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationABANDONRequestClassificationsAbandonDeleteAsync($accept, $jiwa_stateful = null, $rec_id = null)
    {
        return $this->inventoryClassificationABANDONRequestClassificationsAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful, $rec_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryClassificationABANDONRequestClassificationsAbandonDeleteAsyncWithHttpInfo
     *
     * Abandons a stateful inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationABANDONRequestClassificationsAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful = null, $rec_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryClassificationABANDONRequestClassificationsAbandonDeleteRequest($accept, $jiwa_stateful, $rec_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryClassificationABANDONRequestClassificationsAbandonDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryClassificationABANDONRequestClassificationsAbandonDeleteRequest($accept, $jiwa_stateful = null, $rec_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryClassificationABANDONRequestClassificationsAbandonDelete'
            );
        }

        $resourcePath = '/Inventory/Classifications/Abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($rec_id !== null) {
            $queryParams['RecID'] = ObjectSerializer::toQueryValue($rec_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryClassificationDELETERequestClassificationsClassificationIDDelete
     *
     * Deletes an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryClassificationDELETERequestClassificationsClassificationIDDelete($accept, $classification_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryClassificationDELETERequestClassificationsClassificationIDDeleteWithHttpInfo($accept, $classification_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryClassificationDELETERequestClassificationsClassificationIDDeleteWithHttpInfo
     *
     * Deletes an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryClassificationDELETERequestClassificationsClassificationIDDeleteWithHttpInfo($accept, $classification_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryClassificationDELETERequestClassificationsClassificationIDDeleteRequest($accept, $classification_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryClassificationDELETERequestClassificationsClassificationIDDeleteAsync
     *
     * Deletes an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationDELETERequestClassificationsClassificationIDDeleteAsync($accept, $classification_id, $jiwa_stateful = null)
    {
        return $this->inventoryClassificationDELETERequestClassificationsClassificationIDDeleteAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryClassificationDELETERequestClassificationsClassificationIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationDELETERequestClassificationsClassificationIDDeleteAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryClassificationDELETERequestClassificationsClassificationIDDeleteRequest($accept, $classification_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryClassificationDELETERequestClassificationsClassificationIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryClassificationDELETERequestClassificationsClassificationIDDeleteRequest($accept, $classification_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryClassificationDELETERequestClassificationsClassificationIDDelete'
            );
        }
        // verify the required parameter 'classification_id' is set
        if ($classification_id === null || (is_array($classification_id) && count($classification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $classification_id when calling inventoryClassificationDELETERequestClassificationsClassificationIDDelete'
            );
        }

        $resourcePath = '/Inventory/Classifications/{ClassificationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($classification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ClassificationID' . '}',
                ObjectSerializer::toPathValue($classification_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryClassificationGETRequestClassificationsClassificationIDGet
     *
     * Retrieves an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryClassification
     */
    public function inventoryClassificationGETRequestClassificationsClassificationIDGet($accept, $classification_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryClassificationGETRequestClassificationsClassificationIDGetWithHttpInfo($accept, $classification_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryClassificationGETRequestClassificationsClassificationIDGetWithHttpInfo
     *
     * Retrieves an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryClassification, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryClassificationGETRequestClassificationsClassificationIDGetWithHttpInfo($accept, $classification_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryClassification';
        $request = $this->inventoryClassificationGETRequestClassificationsClassificationIDGetRequest($accept, $classification_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryClassificationGETRequestClassificationsClassificationIDGetAsync
     *
     * Retrieves an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationGETRequestClassificationsClassificationIDGetAsync($accept, $classification_id, $jiwa_stateful = null)
    {
        return $this->inventoryClassificationGETRequestClassificationsClassificationIDGetAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryClassificationGETRequestClassificationsClassificationIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationGETRequestClassificationsClassificationIDGetAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryClassification';
        $request = $this->inventoryClassificationGETRequestClassificationsClassificationIDGetRequest($accept, $classification_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryClassificationGETRequestClassificationsClassificationIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryClassificationGETRequestClassificationsClassificationIDGetRequest($accept, $classification_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryClassificationGETRequestClassificationsClassificationIDGet'
            );
        }
        // verify the required parameter 'classification_id' is set
        if ($classification_id === null || (is_array($classification_id) && count($classification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $classification_id when calling inventoryClassificationGETRequestClassificationsClassificationIDGet'
            );
        }

        $resourcePath = '/Inventory/Classifications/{ClassificationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($classification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ClassificationID' . '}',
                ObjectSerializer::toPathValue($classification_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryClassificationPATCHRequestClassificationsClassificationIDUpdate
     *
     * Updates an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  bool $web_enabled web_enabled (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $gst_inwards_tax_rate_id gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers inventory_ledgers (optional)
     * @param  string $pricing_group_id pricing_group_id (optional)
     * @param  string $pricing_group_description pricing_group_description (optional)
     * @param  string $custom_fields custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryClassification
     */
    public function inventoryClassificationPATCHRequestClassificationsClassificationIDUpdate($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        list($response) = $this->inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateWithHttpInfo($accept, $classification_id, $jiwa_stateful, $description, $last_saved_date_time, $web_enabled, $is_default, $gst_inwards_tax_rate_id, $gst_inwards_tax_rate_description, $gst_inwards_tax_rate, $gst_outwards_tax_rate_id, $gst_outwards_tax_rate_description, $gst_outwards_tax_rate, $gst_adjustments_in_tax_rate_id, $gst_adjustments_in_tax_rate_description, $gst_adjustments_in_tax_rate, $gst_adjustments_out_tax_rate_id, $gst_adjustments_out_tax_rate_description, $gst_adjustments_out_tax_rate, $inventory_ledgers, $pricing_group_id, $pricing_group_description, $custom_fields, $body);
        return $response;
    }

    /**
     * Operation inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateWithHttpInfo
     *
     * Updates an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $is_default (optional)
     * @param  string $gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryClassification, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateWithHttpInfo($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryClassification';
        $request = $this->inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateRequest($accept, $classification_id, $jiwa_stateful, $description, $last_saved_date_time, $web_enabled, $is_default, $gst_inwards_tax_rate_id, $gst_inwards_tax_rate_description, $gst_inwards_tax_rate, $gst_outwards_tax_rate_id, $gst_outwards_tax_rate_description, $gst_outwards_tax_rate, $gst_adjustments_in_tax_rate_id, $gst_adjustments_in_tax_rate_description, $gst_adjustments_in_tax_rate, $gst_adjustments_out_tax_rate_id, $gst_adjustments_out_tax_rate_description, $gst_adjustments_out_tax_rate, $inventory_ledgers, $pricing_group_id, $pricing_group_description, $custom_fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateAsync
     *
     * Updates an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $is_default (optional)
     * @param  string $gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateAsync($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        return $this->inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful, $description, $last_saved_date_time, $web_enabled, $is_default, $gst_inwards_tax_rate_id, $gst_inwards_tax_rate_description, $gst_inwards_tax_rate, $gst_outwards_tax_rate_id, $gst_outwards_tax_rate_description, $gst_outwards_tax_rate, $gst_adjustments_in_tax_rate_id, $gst_adjustments_in_tax_rate_description, $gst_adjustments_in_tax_rate, $gst_adjustments_out_tax_rate_id, $gst_adjustments_out_tax_rate_description, $gst_adjustments_out_tax_rate, $inventory_ledgers, $pricing_group_id, $pricing_group_description, $custom_fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $is_default (optional)
     * @param  string $gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryClassification';
        $request = $this->inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateRequest($accept, $classification_id, $jiwa_stateful, $description, $last_saved_date_time, $web_enabled, $is_default, $gst_inwards_tax_rate_id, $gst_inwards_tax_rate_description, $gst_inwards_tax_rate, $gst_outwards_tax_rate_id, $gst_outwards_tax_rate_description, $gst_outwards_tax_rate, $gst_adjustments_in_tax_rate_id, $gst_adjustments_in_tax_rate_description, $gst_adjustments_in_tax_rate, $gst_adjustments_out_tax_rate_id, $gst_adjustments_out_tax_rate_description, $gst_adjustments_out_tax_rate, $inventory_ledgers, $pricing_group_id, $pricing_group_description, $custom_fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryClassificationPATCHRequestClassificationsClassificationIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $is_default (optional)
     * @param  string $gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryClassificationPATCHRequestClassificationsClassificationIDUpdateRequest($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryClassificationPATCHRequestClassificationsClassificationIDUpdate'
            );
        }
        // verify the required parameter 'classification_id' is set
        if ($classification_id === null || (is_array($classification_id) && count($classification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $classification_id when calling inventoryClassificationPATCHRequestClassificationsClassificationIDUpdate'
            );
        }

        $resourcePath = '/Inventory/Classifications/{ClassificationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($web_enabled !== null) {
            $queryParams['WebEnabled'] = ObjectSerializer::toQueryValue($web_enabled);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($gst_inwards_tax_rate_id !== null) {
            $queryParams['GSTInwardsTaxRateID'] = ObjectSerializer::toQueryValue($gst_inwards_tax_rate_id);
        }
        // query params
        if ($gst_inwards_tax_rate_description !== null) {
            $queryParams['GSTInwardsTaxRateDescription'] = ObjectSerializer::toQueryValue($gst_inwards_tax_rate_description);
        }
        // query params
        if ($gst_inwards_tax_rate !== null) {
            $queryParams['GSTInwardsTaxRate'] = ObjectSerializer::toQueryValue($gst_inwards_tax_rate);
        }
        // query params
        if ($gst_outwards_tax_rate_id !== null) {
            $queryParams['GSTOutwardsTaxRateID'] = ObjectSerializer::toQueryValue($gst_outwards_tax_rate_id);
        }
        // query params
        if ($gst_outwards_tax_rate_description !== null) {
            $queryParams['GSTOutwardsTaxRateDescription'] = ObjectSerializer::toQueryValue($gst_outwards_tax_rate_description);
        }
        // query params
        if ($gst_outwards_tax_rate !== null) {
            $queryParams['GSTOutwardsTaxRate'] = ObjectSerializer::toQueryValue($gst_outwards_tax_rate);
        }
        // query params
        if ($gst_adjustments_in_tax_rate_id !== null) {
            $queryParams['GSTAdjustmentsINTaxRateID'] = ObjectSerializer::toQueryValue($gst_adjustments_in_tax_rate_id);
        }
        // query params
        if ($gst_adjustments_in_tax_rate_description !== null) {
            $queryParams['GSTAdjustmentsINTaxRateDescription'] = ObjectSerializer::toQueryValue($gst_adjustments_in_tax_rate_description);
        }
        // query params
        if ($gst_adjustments_in_tax_rate !== null) {
            $queryParams['GSTAdjustmentsINTaxRate'] = ObjectSerializer::toQueryValue($gst_adjustments_in_tax_rate);
        }
        // query params
        if ($gst_adjustments_out_tax_rate_id !== null) {
            $queryParams['GSTAdjustmentsOUTTaxRateID'] = ObjectSerializer::toQueryValue($gst_adjustments_out_tax_rate_id);
        }
        // query params
        if ($gst_adjustments_out_tax_rate_description !== null) {
            $queryParams['GSTAdjustmentsOUTTaxRateDescription'] = ObjectSerializer::toQueryValue($gst_adjustments_out_tax_rate_description);
        }
        // query params
        if ($gst_adjustments_out_tax_rate !== null) {
            $queryParams['GSTAdjustmentsOUTTaxRate'] = ObjectSerializer::toQueryValue($gst_adjustments_out_tax_rate);
        }
        // query params
        if ($inventory_ledgers !== null) {
            $queryParams['InventoryLedgers'] = ObjectSerializer::toQueryValue($inventory_ledgers);
        }
        // query params
        if ($pricing_group_id !== null) {
            $queryParams['PricingGroupID'] = ObjectSerializer::toQueryValue($pricing_group_id);
        }
        // query params
        if ($pricing_group_description !== null) {
            $queryParams['PricingGroupDescription'] = ObjectSerializer::toQueryValue($pricing_group_description);
        }
        // query params
        if ($custom_fields !== null) {
            $queryParams['CustomFields'] = ObjectSerializer::toQueryValue($custom_fields);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($classification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ClassificationID' . '}',
                ObjectSerializer::toPathValue($classification_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryClassificationPOSTRequestClassificationsPost
     *
     * Creates an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $web_enabled web_enabled (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $gst_inwards_tax_rate_id gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers inventory_ledgers (optional)
     * @param  string $pricing_group_id pricing_group_id (optional)
     * @param  string $pricing_group_description pricing_group_description (optional)
     * @param  string $custom_fields custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryClassification
     */
    public function inventoryClassificationPOSTRequestClassificationsPost($accept, $jiwa_stateful = null, $description = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        list($response) = $this->inventoryClassificationPOSTRequestClassificationsPostWithHttpInfo($accept, $jiwa_stateful, $description, $web_enabled, $is_default, $gst_inwards_tax_rate_id, $gst_inwards_tax_rate_description, $gst_inwards_tax_rate, $gst_outwards_tax_rate_id, $gst_outwards_tax_rate_description, $gst_outwards_tax_rate, $gst_adjustments_in_tax_rate_id, $gst_adjustments_in_tax_rate_description, $gst_adjustments_in_tax_rate, $gst_adjustments_out_tax_rate_id, $gst_adjustments_out_tax_rate_description, $gst_adjustments_out_tax_rate, $inventory_ledgers, $pricing_group_id, $pricing_group_description, $custom_fields, $body);
        return $response;
    }

    /**
     * Operation inventoryClassificationPOSTRequestClassificationsPostWithHttpInfo
     *
     * Creates an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $is_default (optional)
     * @param  string $gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryClassification, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryClassificationPOSTRequestClassificationsPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryClassification';
        $request = $this->inventoryClassificationPOSTRequestClassificationsPostRequest($accept, $jiwa_stateful, $description, $web_enabled, $is_default, $gst_inwards_tax_rate_id, $gst_inwards_tax_rate_description, $gst_inwards_tax_rate, $gst_outwards_tax_rate_id, $gst_outwards_tax_rate_description, $gst_outwards_tax_rate, $gst_adjustments_in_tax_rate_id, $gst_adjustments_in_tax_rate_description, $gst_adjustments_in_tax_rate, $gst_adjustments_out_tax_rate_id, $gst_adjustments_out_tax_rate_description, $gst_adjustments_out_tax_rate, $inventory_ledgers, $pricing_group_id, $pricing_group_description, $custom_fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryClassificationPOSTRequestClassificationsPostAsync
     *
     * Creates an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $is_default (optional)
     * @param  string $gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationPOSTRequestClassificationsPostAsync($accept, $jiwa_stateful = null, $description = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        return $this->inventoryClassificationPOSTRequestClassificationsPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $web_enabled, $is_default, $gst_inwards_tax_rate_id, $gst_inwards_tax_rate_description, $gst_inwards_tax_rate, $gst_outwards_tax_rate_id, $gst_outwards_tax_rate_description, $gst_outwards_tax_rate, $gst_adjustments_in_tax_rate_id, $gst_adjustments_in_tax_rate_description, $gst_adjustments_in_tax_rate, $gst_adjustments_out_tax_rate_id, $gst_adjustments_out_tax_rate_description, $gst_adjustments_out_tax_rate, $inventory_ledgers, $pricing_group_id, $pricing_group_description, $custom_fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryClassificationPOSTRequestClassificationsPostAsyncWithHttpInfo
     *
     * Creates an inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $is_default (optional)
     * @param  string $gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationPOSTRequestClassificationsPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryClassification';
        $request = $this->inventoryClassificationPOSTRequestClassificationsPostRequest($accept, $jiwa_stateful, $description, $web_enabled, $is_default, $gst_inwards_tax_rate_id, $gst_inwards_tax_rate_description, $gst_inwards_tax_rate, $gst_outwards_tax_rate_id, $gst_outwards_tax_rate_description, $gst_outwards_tax_rate, $gst_adjustments_in_tax_rate_id, $gst_adjustments_in_tax_rate_description, $gst_adjustments_in_tax_rate, $gst_adjustments_out_tax_rate_id, $gst_adjustments_out_tax_rate_description, $gst_adjustments_out_tax_rate, $inventory_ledgers, $pricing_group_id, $pricing_group_description, $custom_fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryClassificationPOSTRequestClassificationsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $is_default (optional)
     * @param  string $gst_inwards_tax_rate_id (optional)
     * @param  string $gst_inwards_tax_rate_description (optional)
     * @param  double $gst_inwards_tax_rate (optional)
     * @param  string $gst_outwards_tax_rate_id (optional)
     * @param  string $gst_outwards_tax_rate_description (optional)
     * @param  double $gst_outwards_tax_rate (optional)
     * @param  string $gst_adjustments_in_tax_rate_id (optional)
     * @param  string $gst_adjustments_in_tax_rate_description (optional)
     * @param  double $gst_adjustments_in_tax_rate (optional)
     * @param  string $gst_adjustments_out_tax_rate_id (optional)
     * @param  string $gst_adjustments_out_tax_rate_description (optional)
     * @param  double $gst_adjustments_out_tax_rate (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $custom_fields (optional)
     * @param  \Jiwa\JiwaModel\InventoryClassificationPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryClassificationPOSTRequestClassificationsPostRequest($accept, $jiwa_stateful = null, $description = null, $web_enabled = null, $is_default = null, $gst_inwards_tax_rate_id = null, $gst_inwards_tax_rate_description = null, $gst_inwards_tax_rate = null, $gst_outwards_tax_rate_id = null, $gst_outwards_tax_rate_description = null, $gst_outwards_tax_rate = null, $gst_adjustments_in_tax_rate_id = null, $gst_adjustments_in_tax_rate_description = null, $gst_adjustments_in_tax_rate = null, $gst_adjustments_out_tax_rate_id = null, $gst_adjustments_out_tax_rate_description = null, $gst_adjustments_out_tax_rate = null, $inventory_ledgers = null, $pricing_group_id = null, $pricing_group_description = null, $custom_fields = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryClassificationPOSTRequestClassificationsPost'
            );
        }

        $resourcePath = '/Inventory/Classifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($web_enabled !== null) {
            $queryParams['WebEnabled'] = ObjectSerializer::toQueryValue($web_enabled);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($gst_inwards_tax_rate_id !== null) {
            $queryParams['GSTInwardsTaxRateID'] = ObjectSerializer::toQueryValue($gst_inwards_tax_rate_id);
        }
        // query params
        if ($gst_inwards_tax_rate_description !== null) {
            $queryParams['GSTInwardsTaxRateDescription'] = ObjectSerializer::toQueryValue($gst_inwards_tax_rate_description);
        }
        // query params
        if ($gst_inwards_tax_rate !== null) {
            $queryParams['GSTInwardsTaxRate'] = ObjectSerializer::toQueryValue($gst_inwards_tax_rate);
        }
        // query params
        if ($gst_outwards_tax_rate_id !== null) {
            $queryParams['GSTOutwardsTaxRateID'] = ObjectSerializer::toQueryValue($gst_outwards_tax_rate_id);
        }
        // query params
        if ($gst_outwards_tax_rate_description !== null) {
            $queryParams['GSTOutwardsTaxRateDescription'] = ObjectSerializer::toQueryValue($gst_outwards_tax_rate_description);
        }
        // query params
        if ($gst_outwards_tax_rate !== null) {
            $queryParams['GSTOutwardsTaxRate'] = ObjectSerializer::toQueryValue($gst_outwards_tax_rate);
        }
        // query params
        if ($gst_adjustments_in_tax_rate_id !== null) {
            $queryParams['GSTAdjustmentsINTaxRateID'] = ObjectSerializer::toQueryValue($gst_adjustments_in_tax_rate_id);
        }
        // query params
        if ($gst_adjustments_in_tax_rate_description !== null) {
            $queryParams['GSTAdjustmentsINTaxRateDescription'] = ObjectSerializer::toQueryValue($gst_adjustments_in_tax_rate_description);
        }
        // query params
        if ($gst_adjustments_in_tax_rate !== null) {
            $queryParams['GSTAdjustmentsINTaxRate'] = ObjectSerializer::toQueryValue($gst_adjustments_in_tax_rate);
        }
        // query params
        if ($gst_adjustments_out_tax_rate_id !== null) {
            $queryParams['GSTAdjustmentsOUTTaxRateID'] = ObjectSerializer::toQueryValue($gst_adjustments_out_tax_rate_id);
        }
        // query params
        if ($gst_adjustments_out_tax_rate_description !== null) {
            $queryParams['GSTAdjustmentsOUTTaxRateDescription'] = ObjectSerializer::toQueryValue($gst_adjustments_out_tax_rate_description);
        }
        // query params
        if ($gst_adjustments_out_tax_rate !== null) {
            $queryParams['GSTAdjustmentsOUTTaxRate'] = ObjectSerializer::toQueryValue($gst_adjustments_out_tax_rate);
        }
        // query params
        if ($inventory_ledgers !== null) {
            $queryParams['InventoryLedgers'] = ObjectSerializer::toQueryValue($inventory_ledgers);
        }
        // query params
        if ($pricing_group_id !== null) {
            $queryParams['PricingGroupID'] = ObjectSerializer::toQueryValue($pricing_group_id);
        }
        // query params
        if ($pricing_group_description !== null) {
            $queryParams['PricingGroupDescription'] = ObjectSerializer::toQueryValue($pricing_group_description);
        }
        // query params
        if ($custom_fields !== null) {
            $queryParams['CustomFields'] = ObjectSerializer::toQueryValue($custom_fields);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryClassificationSAVERequestClassificationsSaveGet
     *
     * Saves a stateful inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id rec_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryClassification
     */
    public function inventoryClassificationSAVERequestClassificationsSaveGet($accept, $jiwa_stateful = null, $rec_id = null)
    {
        list($response) = $this->inventoryClassificationSAVERequestClassificationsSaveGetWithHttpInfo($accept, $jiwa_stateful, $rec_id);
        return $response;
    }

    /**
     * Operation inventoryClassificationSAVERequestClassificationsSaveGetWithHttpInfo
     *
     * Saves a stateful inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryClassification, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryClassificationSAVERequestClassificationsSaveGetWithHttpInfo($accept, $jiwa_stateful = null, $rec_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryClassification';
        $request = $this->inventoryClassificationSAVERequestClassificationsSaveGetRequest($accept, $jiwa_stateful, $rec_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryClassificationSAVERequestClassificationsSaveGetAsync
     *
     * Saves a stateful inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationSAVERequestClassificationsSaveGetAsync($accept, $jiwa_stateful = null, $rec_id = null)
    {
        return $this->inventoryClassificationSAVERequestClassificationsSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful, $rec_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryClassificationSAVERequestClassificationsSaveGetAsyncWithHttpInfo
     *
     * Saves a stateful inventory classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryClassificationSAVERequestClassificationsSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful = null, $rec_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryClassification';
        $request = $this->inventoryClassificationSAVERequestClassificationsSaveGetRequest($accept, $jiwa_stateful, $rec_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryClassificationSAVERequestClassificationsSaveGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryClassificationSAVERequestClassificationsSaveGetRequest($accept, $jiwa_stateful = null, $rec_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryClassificationSAVERequestClassificationsSaveGet'
            );
        }

        $resourcePath = '/Inventory/Classifications/Save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($rec_id !== null) {
            $queryParams['RecID'] = ObjectSerializer::toQueryValue($rec_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryComponentDELETERequestInventoryIDComponentsComponentIDDelete
     *
     * Deletes a component.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $component_id component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity component_quantity (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $component_inventory_id component_inventory_id (optional)
     * @param  string $component_inventory_part_no component_inventory_part_no (optional)
     * @param  string $component_inventory_description component_inventory_description (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryComponentDELETERequestInventoryIDComponentsComponentIDDelete($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null)
    {
        list($response) = $this->inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description);
        return $response;
    }

    /**
     * Operation inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteWithHttpInfo
     *
     * Deletes a component.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteRequest($accept, $inventory_id, $component_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteAsync
     *
     * Deletes a component.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteAsync($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null)
    {
        return $this->inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteAsyncWithHttpInfo
     *
     * Deletes a component.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteRequest($accept, $inventory_id, $component_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryComponentDELETERequestInventoryIDComponentsComponentIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryComponentDELETERequestInventoryIDComponentsComponentIDDeleteRequest($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryComponentDELETERequestInventoryIDComponentsComponentIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryComponentDELETERequestInventoryIDComponentsComponentIDDelete'
            );
        }
        // verify the required parameter 'component_id' is set
        if ($component_id === null || (is_array($component_id) && count($component_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $component_id when calling inventoryComponentDELETERequestInventoryIDComponentsComponentIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Components/{ComponentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($component_quantity !== null) {
            $queryParams['ComponentQuantity'] = ObjectSerializer::toQueryValue($component_quantity);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($component_inventory_id !== null) {
            $queryParams['ComponentInventoryID'] = ObjectSerializer::toQueryValue($component_inventory_id);
        }
        // query params
        if ($component_inventory_part_no !== null) {
            $queryParams['ComponentInventoryPartNo'] = ObjectSerializer::toQueryValue($component_inventory_part_no);
        }
        // query params
        if ($component_inventory_description !== null) {
            $queryParams['ComponentInventoryDescription'] = ObjectSerializer::toQueryValue($component_inventory_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($component_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ComponentID' . '}',
                ObjectSerializer::toPathValue($component_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryComponentGETRequestInventoryIDComponentsComponentIDGet
     *
     * Retrieves a component from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $component_id component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryComponent
     */
    public function inventoryComponentGETRequestInventoryIDComponentsComponentIDGet($accept, $inventory_id, $component_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryComponentGETRequestInventoryIDComponentsComponentIDGetWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryComponentGETRequestInventoryIDComponentsComponentIDGetWithHttpInfo
     *
     * Retrieves a component from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryComponent, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryComponentGETRequestInventoryIDComponentsComponentIDGetWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryComponent';
        $request = $this->inventoryComponentGETRequestInventoryIDComponentsComponentIDGetRequest($accept, $inventory_id, $component_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryComponentGETRequestInventoryIDComponentsComponentIDGetAsync
     *
     * Retrieves a component from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentGETRequestInventoryIDComponentsComponentIDGetAsync($accept, $inventory_id, $component_id, $jiwa_stateful = null)
    {
        return $this->inventoryComponentGETRequestInventoryIDComponentsComponentIDGetAsyncWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryComponentGETRequestInventoryIDComponentsComponentIDGetAsyncWithHttpInfo
     *
     * Retrieves a component from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentGETRequestInventoryIDComponentsComponentIDGetAsyncWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryComponent';
        $request = $this->inventoryComponentGETRequestInventoryIDComponentsComponentIDGetRequest($accept, $inventory_id, $component_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryComponentGETRequestInventoryIDComponentsComponentIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryComponentGETRequestInventoryIDComponentsComponentIDGetRequest($accept, $inventory_id, $component_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryComponentGETRequestInventoryIDComponentsComponentIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryComponentGETRequestInventoryIDComponentsComponentIDGet'
            );
        }
        // verify the required parameter 'component_id' is set
        if ($component_id === null || (is_array($component_id) && count($component_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $component_id when calling inventoryComponentGETRequestInventoryIDComponentsComponentIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Components/{ComponentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($component_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ComponentID' . '}',
                ObjectSerializer::toPathValue($component_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdate
     *
     * Updates a component.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $component_id component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity component_quantity (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $component_inventory_id component_inventory_id (optional)
     * @param  string $component_inventory_part_no component_inventory_part_no (optional)
     * @param  string $component_inventory_description component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryComponent
     */
    public function inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdate($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        list($response) = $this->inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description, $body);
        return $response;
    }

    /**
     * Operation inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateWithHttpInfo
     *
     * Updates a component.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryComponent, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryComponent';
        $request = $this->inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateRequest($accept, $inventory_id, $component_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateAsync
     *
     * Updates a component.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateAsync($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        return $this->inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateAsyncWithHttpInfo
     *
     * Updates a component.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryComponent';
        $request = $this->inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateRequest($accept, $inventory_id, $component_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $component_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdateRequest($accept, $inventory_id, $component_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdate'
            );
        }
        // verify the required parameter 'component_id' is set
        if ($component_id === null || (is_array($component_id) && count($component_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $component_id when calling inventoryComponentPATCHRequestInventoryIDComponentsComponentIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Components/{ComponentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($component_quantity !== null) {
            $queryParams['ComponentQuantity'] = ObjectSerializer::toQueryValue($component_quantity);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($component_inventory_id !== null) {
            $queryParams['ComponentInventoryID'] = ObjectSerializer::toQueryValue($component_inventory_id);
        }
        // query params
        if ($component_inventory_part_no !== null) {
            $queryParams['ComponentInventoryPartNo'] = ObjectSerializer::toQueryValue($component_inventory_part_no);
        }
        // query params
        if ($component_inventory_description !== null) {
            $queryParams['ComponentInventoryDescription'] = ObjectSerializer::toQueryValue($component_inventory_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($component_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ComponentID' . '}',
                ObjectSerializer::toPathValue($component_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryComponentPOSTRequestInventoryIDComponentsPost
     *
     * Appends a component to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity component_quantity (optional)
     * @param  int $item_no item_no (optional)
     * @param  string $component_inventory_id component_inventory_id (optional)
     * @param  string $component_inventory_part_no component_inventory_part_no (optional)
     * @param  string $component_inventory_description component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryComponent
     */
    public function inventoryComponentPOSTRequestInventoryIDComponentsPost($accept, $inventory_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        list($response) = $this->inventoryComponentPOSTRequestInventoryIDComponentsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description, $body);
        return $response;
    }

    /**
     * Operation inventoryComponentPOSTRequestInventoryIDComponentsPostWithHttpInfo
     *
     * Appends a component to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryComponent, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryComponentPOSTRequestInventoryIDComponentsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryComponent';
        $request = $this->inventoryComponentPOSTRequestInventoryIDComponentsPostRequest($accept, $inventory_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryComponentPOSTRequestInventoryIDComponentsPostAsync
     *
     * Appends a component to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentPOSTRequestInventoryIDComponentsPostAsync($accept, $inventory_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        return $this->inventoryComponentPOSTRequestInventoryIDComponentsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryComponentPOSTRequestInventoryIDComponentsPostAsyncWithHttpInfo
     *
     * Appends a component to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentPOSTRequestInventoryIDComponentsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryComponent';
        $request = $this->inventoryComponentPOSTRequestInventoryIDComponentsPostRequest($accept, $inventory_id, $jiwa_stateful, $component_quantity, $item_no, $component_inventory_id, $component_inventory_part_no, $component_inventory_description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryComponentPOSTRequestInventoryIDComponentsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $component_quantity (optional)
     * @param  int $item_no (optional)
     * @param  string $component_inventory_id (optional)
     * @param  string $component_inventory_part_no (optional)
     * @param  string $component_inventory_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryComponentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryComponentPOSTRequestInventoryIDComponentsPostRequest($accept, $inventory_id, $jiwa_stateful = null, $component_quantity = null, $item_no = null, $component_inventory_id = null, $component_inventory_part_no = null, $component_inventory_description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryComponentPOSTRequestInventoryIDComponentsPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryComponentPOSTRequestInventoryIDComponentsPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Components';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($component_quantity !== null) {
            $queryParams['ComponentQuantity'] = ObjectSerializer::toQueryValue($component_quantity);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($component_inventory_id !== null) {
            $queryParams['ComponentInventoryID'] = ObjectSerializer::toQueryValue($component_inventory_id);
        }
        // query params
        if ($component_inventory_part_no !== null) {
            $queryParams['ComponentInventoryPartNo'] = ObjectSerializer::toQueryValue($component_inventory_part_no);
        }
        // query params
        if ($component_inventory_description !== null) {
            $queryParams['ComponentInventoryDescription'] = ObjectSerializer::toQueryValue($component_inventory_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryComponentsGETManyRequestInventoryIDComponentsGet
     *
     * Retrieves a list of components for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryComponent[]
     */
    public function inventoryComponentsGETManyRequestInventoryIDComponentsGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryComponentsGETManyRequestInventoryIDComponentsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryComponentsGETManyRequestInventoryIDComponentsGetWithHttpInfo
     *
     * Retrieves a list of components for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryComponent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryComponentsGETManyRequestInventoryIDComponentsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryComponent[]';
        $request = $this->inventoryComponentsGETManyRequestInventoryIDComponentsGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryComponent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryComponentsGETManyRequestInventoryIDComponentsGetAsync
     *
     * Retrieves a list of components for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentsGETManyRequestInventoryIDComponentsGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryComponentsGETManyRequestInventoryIDComponentsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryComponentsGETManyRequestInventoryIDComponentsGetAsyncWithHttpInfo
     *
     * Retrieves a list of components for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryComponentsGETManyRequestInventoryIDComponentsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryComponent[]';
        $request = $this->inventoryComponentsGETManyRequestInventoryIDComponentsGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryComponentsGETManyRequestInventoryIDComponentsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryComponentsGETManyRequestInventoryIDComponentsGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryComponentsGETManyRequestInventoryIDComponentsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryComponentsGETManyRequestInventoryIDComponentsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Components';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGet
     *
     * Retrieves an inventory custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $setting_id setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\CustomFieldValue
     */
    public function inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGet($accept, $inventory_id, $setting_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetWithHttpInfo($accept, $inventory_id, $setting_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetWithHttpInfo
     *
     * Retrieves an inventory custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\CustomFieldValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetWithHttpInfo($accept, $inventory_id, $setting_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\CustomFieldValue';
        $request = $this->inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetRequest($accept, $inventory_id, $setting_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetAsync
     *
     * Retrieves an inventory custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetAsync($accept, $inventory_id, $setting_id, $jiwa_stateful = null)
    {
        return $this->inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetAsyncWithHttpInfo($accept, $inventory_id, $setting_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetAsyncWithHttpInfo($accept, $inventory_id, $setting_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\CustomFieldValue';
        $request = $this->inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetRequest($accept, $inventory_id, $setting_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGetRequest($accept, $inventory_id, $setting_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGet'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling inventoryCustomFieldValueGETRequestInventoryIDCustomFieldValuesSettingIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/CustomFieldValues/{SettingID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SettingID' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdate
     *
     * Updates an inventory custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $setting_id setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryCustomFieldValuePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\CustomFieldValue
     */
    public function inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdate($accept, $inventory_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        list($response) = $this->inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateWithHttpInfo($accept, $inventory_id, $setting_id, $jiwa_stateful, $contents, $body);
        return $response;
    }

    /**
     * Operation inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateWithHttpInfo
     *
     * Updates an inventory custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryCustomFieldValuePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\CustomFieldValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateWithHttpInfo($accept, $inventory_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\CustomFieldValue';
        $request = $this->inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateRequest($accept, $inventory_id, $setting_id, $jiwa_stateful, $contents, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateAsync
     *
     * Updates an inventory custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryCustomFieldValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateAsync($accept, $inventory_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        return $this->inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $setting_id, $jiwa_stateful, $contents, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryCustomFieldValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\CustomFieldValue';
        $request = $this->inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateRequest($accept, $inventory_id, $setting_id, $jiwa_stateful, $contents, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\JiwaModel\InventoryCustomFieldValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdateRequest($accept, $inventory_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdate'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling inventoryCustomFieldValuePATCHRequestInventoryIDCustomFieldValuesSettingIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/CustomFieldValues/{SettingID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contents !== null) {
            $queryParams['Contents'] = ObjectSerializer::toQueryValue($contents);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SettingID' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGet
     *
     * Retrieves a list of custom field values for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\CustomFieldValue[]
     */
    public function inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetWithHttpInfo
     *
     * Retrieves a list of custom field values for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\CustomFieldValue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\CustomFieldValue[]';
        $request = $this->inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomFieldValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetAsync
     *
     * Retrieves a list of custom field values for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetAsyncWithHttpInfo
     *
     * Retrieves a list of custom field values for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\CustomFieldValue[]';
        $request = $this->inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryCustomFieldValuesGETManyRequestInventoryIDCustomFieldValuesGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/CustomFieldValues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCustomFieldsGETManyRequestCustomFieldsGet
     *
     * Retrieves a list of inventory custom fields.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\CustomField[]
     */
    public function inventoryCustomFieldsGETManyRequestCustomFieldsGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryCustomFieldsGETManyRequestCustomFieldsGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryCustomFieldsGETManyRequestCustomFieldsGetWithHttpInfo
     *
     * Retrieves a list of inventory custom fields.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\CustomField[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCustomFieldsGETManyRequestCustomFieldsGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\CustomField[]';
        $request = $this->inventoryCustomFieldsGETManyRequestCustomFieldsGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCustomFieldsGETManyRequestCustomFieldsGetAsync
     *
     * Retrieves a list of inventory custom fields.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCustomFieldsGETManyRequestCustomFieldsGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->inventoryCustomFieldsGETManyRequestCustomFieldsGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCustomFieldsGETManyRequestCustomFieldsGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory custom fields.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCustomFieldsGETManyRequestCustomFieldsGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\CustomField[]';
        $request = $this->inventoryCustomFieldsGETManyRequestCustomFieldsGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCustomFieldsGETManyRequestCustomFieldsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCustomFieldsGETManyRequestCustomFieldsGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryCustomFieldsGETManyRequestCustomFieldsGet'
            );
        }

        $resourcePath = '/Inventory/CustomFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDELETERequestInventoryIDDelete
     *
     * Deletes an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryDELETERequestInventoryIDDelete($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDELETERequestInventoryIDDeleteWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDELETERequestInventoryIDDeleteWithHttpInfo
     *
     * Deletes an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDELETERequestInventoryIDDeleteWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDELETERequestInventoryIDDeleteRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDELETERequestInventoryIDDeleteAsync
     *
     * Deletes an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDELETERequestInventoryIDDeleteAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryDELETERequestInventoryIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDELETERequestInventoryIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDELETERequestInventoryIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDELETERequestInventoryIDDeleteRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDELETERequestInventoryIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDELETERequestInventoryIDDeleteRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDELETERequestInventoryIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDELETERequestInventoryIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDelete
     *
     * Deletes a debtor classification price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_classification_price_id debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_classification_id debtor_classification_id (optional)
     * @param  string $debtor_classification_description debtor_classification_description (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDelete($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null)
    {
        list($response) = $this->inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note);
        return $response;
    }

    /**
     * Operation inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteWithHttpInfo
     *
     * Deletes a debtor classification price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteAsync
     *
     * Deletes a debtor classification price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteAsync($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null)
    {
        return $this->inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor classification price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDeleteRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDelete'
            );
        }
        // verify the required parameter 'debtor_classification_price_id' is set
        if ($debtor_classification_price_id === null || (is_array($debtor_classification_price_id) && count($debtor_classification_price_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_classification_price_id when calling inventoryDebtorClassificationPriceDELETERequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorClassificationPrices/{DebtorClassificationPriceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_classification_id !== null) {
            $queryParams['DebtorClassificationID'] = ObjectSerializer::toQueryValue($debtor_classification_id);
        }
        // query params
        if ($debtor_classification_description !== null) {
            $queryParams['DebtorClassificationDescription'] = ObjectSerializer::toQueryValue($debtor_classification_description);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_classification_price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorClassificationPriceID' . '}',
                ObjectSerializer::toPathValue($debtor_classification_price_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGet
     *
     * Retrieves a debtor classification price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_classification_price_id debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorClassificationPrice
     */
    public function inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGet($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetWithHttpInfo
     *
     * Retrieves a debtor classification price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorClassificationPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice';
        $request = $this->inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetAsync
     *
     * Retrieves a debtor classification price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetAsync($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null)
    {
        return $this->inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetAsyncWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor classification price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetAsyncWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice';
        $request = $this->inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGetRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGet'
            );
        }
        // verify the required parameter 'debtor_classification_price_id' is set
        if ($debtor_classification_price_id === null || (is_array($debtor_classification_price_id) && count($debtor_classification_price_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_classification_price_id when calling inventoryDebtorClassificationPriceGETRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorClassificationPrices/{DebtorClassificationPriceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_classification_price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorClassificationPriceID' . '}',
                ObjectSerializer::toPathValue($debtor_classification_price_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdate
     *
     * Updates a debtor classification price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_classification_price_id debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_classification_id debtor_classification_id (optional)
     * @param  string $debtor_classification_description debtor_classification_description (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorClassificationPrice
     */
    public function inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdate($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        list($response) = $this->inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note, $body);
        return $response;
    }

    /**
     * Operation inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateWithHttpInfo
     *
     * Updates a debtor classification price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorClassificationPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice';
        $request = $this->inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateAsync
     *
     * Updates a debtor classification price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateAsync($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        return $this->inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor classification price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice';
        $request = $this->inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_classification_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdateRequest($accept, $inventory_id, $debtor_classification_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdate'
            );
        }
        // verify the required parameter 'debtor_classification_price_id' is set
        if ($debtor_classification_price_id === null || (is_array($debtor_classification_price_id) && count($debtor_classification_price_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_classification_price_id when calling inventoryDebtorClassificationPricePATCHRequestInventoryIDDebtorClassificationPricesDebtorClassificationPriceIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorClassificationPrices/{DebtorClassificationPriceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_classification_id !== null) {
            $queryParams['DebtorClassificationID'] = ObjectSerializer::toQueryValue($debtor_classification_id);
        }
        // query params
        if ($debtor_classification_description !== null) {
            $queryParams['DebtorClassificationDescription'] = ObjectSerializer::toQueryValue($debtor_classification_description);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_classification_price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorClassificationPriceID' . '}',
                ObjectSerializer::toPathValue($debtor_classification_price_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPost
     *
     * Adds a debtor classification price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_classification_price_id debtor_classification_price_id (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_classification_id debtor_classification_id (optional)
     * @param  string $debtor_classification_description debtor_classification_description (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorClassificationPrice
     */
    public function inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPost($accept, $inventory_id, $jiwa_stateful = null, $debtor_classification_price_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        list($response) = $this->inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $debtor_classification_price_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note, $body);
        return $response;
    }

    /**
     * Operation inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostWithHttpInfo
     *
     * Adds a debtor classification price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_classification_price_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorClassificationPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $debtor_classification_price_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice';
        $request = $this->inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostRequest($accept, $inventory_id, $jiwa_stateful, $debtor_classification_price_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostAsync
     *
     * Adds a debtor classification price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_classification_price_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostAsync($accept, $inventory_id, $jiwa_stateful = null, $debtor_classification_price_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        return $this->inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $debtor_classification_price_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostAsyncWithHttpInfo
     *
     * Adds a debtor classification price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_classification_price_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $debtor_classification_price_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice';
        $request = $this->inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostRequest($accept, $inventory_id, $jiwa_stateful, $debtor_classification_price_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_classification_id, $debtor_classification_description, $price, $note, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_classification_price_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_classification_id (optional)
     * @param  string $debtor_classification_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorClassificationPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPostRequest($accept, $inventory_id, $jiwa_stateful = null, $debtor_classification_price_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_classification_id = null, $debtor_classification_description = null, $price = null, $note = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorClassificationPricePOSTRequestInventoryIDDebtorClassificationPricesPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorClassificationPrices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($debtor_classification_price_id !== null) {
            $queryParams['DebtorClassificationPriceID'] = ObjectSerializer::toQueryValue($debtor_classification_price_id);
        }
        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_classification_id !== null) {
            $queryParams['DebtorClassificationID'] = ObjectSerializer::toQueryValue($debtor_classification_id);
        }
        // query params
        if ($debtor_classification_description !== null) {
            $queryParams['DebtorClassificationDescription'] = ObjectSerializer::toQueryValue($debtor_classification_description);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGet
     *
     * Retrieves a list of debtor classification prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorClassificationPrice[]
     */
    public function inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetWithHttpInfo
     *
     * Retrieves a list of debtor classification prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorClassificationPrice[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice[]';
        $request = $this->inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetAsync
     *
     * Retrieves a list of debtor classification prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor classification prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorClassificationPrice[]';
        $request = $this->inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorClassificationPricesGETManyRequestInventoryIDDebtorClassificationPricesGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorClassificationPrices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDelete
     *
     * Deletes a debtor price group price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_price_group_id debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description debtor_price_group_description (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDelete($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null)
    {
        list($response) = $this->inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note);
        return $response;
    }

    /**
     * Operation inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteWithHttpInfo
     *
     * Deletes a debtor price group price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteAsync
     *
     * Deletes a debtor price group price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteAsync($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null)
    {
        return $this->inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor price group price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDeleteRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDelete'
            );
        }
        // verify the required parameter 'debtor_price_group_inventory_specific_id' is set
        if ($debtor_price_group_inventory_specific_id === null || (is_array($debtor_price_group_inventory_specific_id) && count($debtor_price_group_inventory_specific_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_price_group_inventory_specific_id when calling inventoryDebtorPriceGroupPriceDELETERequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorPriceGroupPrices/{DebtorPriceGroupInventorySpecificID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_price_group_id !== null) {
            $queryParams['DebtorPriceGroupID'] = ObjectSerializer::toQueryValue($debtor_price_group_id);
        }
        // query params
        if ($debtor_price_group_description !== null) {
            $queryParams['DebtorPriceGroupDescription'] = ObjectSerializer::toQueryValue($debtor_price_group_description);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_price_group_inventory_specific_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorPriceGroupInventorySpecificID' . '}',
                ObjectSerializer::toPathValue($debtor_price_group_inventory_specific_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGet
     *
     * Retrieves a debtor price group price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific
     */
    public function inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGet($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetWithHttpInfo
     *
     * Retrieves a debtor price group price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific';
        $request = $this->inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetAsync
     *
     * Retrieves a debtor price group price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetAsync($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null)
    {
        return $this->inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetAsyncWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor price group price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetAsyncWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific';
        $request = $this->inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGetRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGet'
            );
        }
        // verify the required parameter 'debtor_price_group_inventory_specific_id' is set
        if ($debtor_price_group_inventory_specific_id === null || (is_array($debtor_price_group_inventory_specific_id) && count($debtor_price_group_inventory_specific_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_price_group_inventory_specific_id when calling inventoryDebtorPriceGroupPriceGETRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorPriceGroupPrices/{DebtorPriceGroupInventorySpecificID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_price_group_inventory_specific_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorPriceGroupInventorySpecificID' . '}',
                ObjectSerializer::toPathValue($debtor_price_group_inventory_specific_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdate
     *
     * Updates a debtor price group price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_price_group_id debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description debtor_price_group_description (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific
     */
    public function inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdate($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        list($response) = $this->inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note, $body);
        return $response;
    }

    /**
     * Operation inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateWithHttpInfo
     *
     * Updates a debtor price group price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific';
        $request = $this->inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateAsync
     *
     * Updates a debtor price group price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateAsync($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        return $this->inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor price group price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific';
        $request = $this->inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_price_group_inventory_specific_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdateRequest($accept, $inventory_id, $debtor_price_group_inventory_specific_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdate'
            );
        }
        // verify the required parameter 'debtor_price_group_inventory_specific_id' is set
        if ($debtor_price_group_inventory_specific_id === null || (is_array($debtor_price_group_inventory_specific_id) && count($debtor_price_group_inventory_specific_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_price_group_inventory_specific_id when calling inventoryDebtorPriceGroupPricePATCHRequestInventoryIDDebtorPriceGroupPricesDebtorPriceGroupInventorySpecificIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorPriceGroupPrices/{DebtorPriceGroupInventorySpecificID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_price_group_id !== null) {
            $queryParams['DebtorPriceGroupID'] = ObjectSerializer::toQueryValue($debtor_price_group_id);
        }
        // query params
        if ($debtor_price_group_description !== null) {
            $queryParams['DebtorPriceGroupDescription'] = ObjectSerializer::toQueryValue($debtor_price_group_description);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_price_group_inventory_specific_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorPriceGroupInventorySpecificID' . '}',
                ObjectSerializer::toPathValue($debtor_price_group_inventory_specific_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPost
     *
     * Adds a debtor price group price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_price_group_inventory_specific_id debtor_price_group_inventory_specific_id (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_price_group_id debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description debtor_price_group_description (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific
     */
    public function inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPost($accept, $inventory_id, $jiwa_stateful = null, $debtor_price_group_inventory_specific_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        list($response) = $this->inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $debtor_price_group_inventory_specific_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note, $body);
        return $response;
    }

    /**
     * Operation inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostWithHttpInfo
     *
     * Adds a debtor price group price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_price_group_inventory_specific_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $debtor_price_group_inventory_specific_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific';
        $request = $this->inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostRequest($accept, $inventory_id, $jiwa_stateful, $debtor_price_group_inventory_specific_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostAsync
     *
     * Adds a debtor price group price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_price_group_inventory_specific_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostAsync($accept, $inventory_id, $jiwa_stateful = null, $debtor_price_group_inventory_specific_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        return $this->inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $debtor_price_group_inventory_specific_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostAsyncWithHttpInfo
     *
     * Adds a debtor price group price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_price_group_inventory_specific_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $debtor_price_group_inventory_specific_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific';
        $request = $this->inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostRequest($accept, $inventory_id, $jiwa_stateful, $debtor_price_group_inventory_specific_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_price_group_id, $debtor_price_group_description, $price, $note, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_price_group_inventory_specific_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_price_group_id (optional)
     * @param  string $debtor_price_group_description (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorPriceGroupPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPostRequest($accept, $inventory_id, $jiwa_stateful = null, $debtor_price_group_inventory_specific_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_price_group_id = null, $debtor_price_group_description = null, $price = null, $note = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorPriceGroupPricePOSTRequestInventoryIDDebtorPriceGroupPricesPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorPriceGroupPrices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($debtor_price_group_inventory_specific_id !== null) {
            $queryParams['DebtorPriceGroupInventorySpecificID'] = ObjectSerializer::toQueryValue($debtor_price_group_inventory_specific_id);
        }
        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_price_group_id !== null) {
            $queryParams['DebtorPriceGroupID'] = ObjectSerializer::toQueryValue($debtor_price_group_id);
        }
        // query params
        if ($debtor_price_group_description !== null) {
            $queryParams['DebtorPriceGroupDescription'] = ObjectSerializer::toQueryValue($debtor_price_group_description);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGet
     *
     * Retrieves a list of debtor price group prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific[]
     */
    public function inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetWithHttpInfo
     *
     * Retrieves a list of debtor price group prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific[]';
        $request = $this->inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetAsync
     *
     * Retrieves a list of debtor price group prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor price group prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPriceGroupInventorySpecific[]';
        $request = $this->inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorPriceGroupPricesGETManyRequestInventoryIDDebtorPriceGroupPricesGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorPriceGroupPrices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDelete
     *
     * Deletes a debtor specific price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_specific_price_id debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_id debtor_id (optional)
     * @param  string $debtor_account_no debtor_account_no (optional)
     * @param  string $debtor_name debtor_name (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDelete($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null)
    {
        list($response) = $this->inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_id, $debtor_account_no, $debtor_name, $price, $note);
        return $response;
    }

    /**
     * Operation inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteWithHttpInfo
     *
     * Deletes a debtor specific price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_id, $debtor_account_no, $debtor_name, $price, $note);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteAsync
     *
     * Deletes a debtor specific price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteAsync($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null)
    {
        return $this->inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_id, $debtor_account_no, $debtor_name, $price, $note)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor specific price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_id, $debtor_account_no, $debtor_name, $price, $note);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDeleteRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDelete'
            );
        }
        // verify the required parameter 'debtor_specific_price_id' is set
        if ($debtor_specific_price_id === null || (is_array($debtor_specific_price_id) && count($debtor_specific_price_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_specific_price_id when calling inventoryDebtorSpecificPriceDELETERequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorSpecificPrices/{DebtorSpecificPriceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_id !== null) {
            $queryParams['DebtorID'] = ObjectSerializer::toQueryValue($debtor_id);
        }
        // query params
        if ($debtor_account_no !== null) {
            $queryParams['DebtorAccountNo'] = ObjectSerializer::toQueryValue($debtor_account_no);
        }
        // query params
        if ($debtor_name !== null) {
            $queryParams['DebtorName'] = ObjectSerializer::toQueryValue($debtor_name);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_specific_price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorSpecificPriceID' . '}',
                ObjectSerializer::toPathValue($debtor_specific_price_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGet
     *
     * Retrieves a debtor specific price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_specific_price_id debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorPrice
     */
    public function inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGet($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetWithHttpInfo
     *
     * Retrieves a debtor specific price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPrice';
        $request = $this->inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetAsync
     *
     * Retrieves a debtor specific price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetAsync($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null)
    {
        return $this->inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetAsyncWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor specific price from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetAsyncWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPrice';
        $request = $this->inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGetRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGet'
            );
        }
        // verify the required parameter 'debtor_specific_price_id' is set
        if ($debtor_specific_price_id === null || (is_array($debtor_specific_price_id) && count($debtor_specific_price_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_specific_price_id when calling inventoryDebtorSpecificPriceGETRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorSpecificPrices/{DebtorSpecificPriceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_specific_price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorSpecificPriceID' . '}',
                ObjectSerializer::toPathValue($debtor_specific_price_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdate
     *
     * Updates a debtor specific price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_specific_price_id debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_id debtor_id (optional)
     * @param  string $debtor_account_no debtor_account_no (optional)
     * @param  string $debtor_name debtor_name (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorPrice
     */
    public function inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdate($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        list($response) = $this->inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_id, $debtor_account_no, $debtor_name, $price, $note, $body);
        return $response;
    }

    /**
     * Operation inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateWithHttpInfo
     *
     * Updates a debtor specific price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPrice';
        $request = $this->inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_id, $debtor_account_no, $debtor_name, $price, $note, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateAsync
     *
     * Updates a debtor specific price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateAsync($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        return $this->inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_id, $debtor_account_no, $debtor_name, $price, $note, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor specific price.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPrice';
        $request = $this->inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_id, $debtor_account_no, $debtor_name, $price, $note, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_specific_price_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdateRequest($accept, $inventory_id, $debtor_specific_price_id, $jiwa_stateful = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdate'
            );
        }
        // verify the required parameter 'debtor_specific_price_id' is set
        if ($debtor_specific_price_id === null || (is_array($debtor_specific_price_id) && count($debtor_specific_price_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_specific_price_id when calling inventoryDebtorSpecificPricePATCHRequestInventoryIDDebtorSpecificPricesDebtorSpecificPriceIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorSpecificPrices/{DebtorSpecificPriceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_id !== null) {
            $queryParams['DebtorID'] = ObjectSerializer::toQueryValue($debtor_id);
        }
        // query params
        if ($debtor_account_no !== null) {
            $queryParams['DebtorAccountNo'] = ObjectSerializer::toQueryValue($debtor_account_no);
        }
        // query params
        if ($debtor_name !== null) {
            $queryParams['DebtorName'] = ObjectSerializer::toQueryValue($debtor_name);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_specific_price_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorSpecificPriceID' . '}',
                ObjectSerializer::toPathValue($debtor_specific_price_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPost
     *
     * Adds a debtor specific price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id debtor_id (optional)
     * @param  string $source source (optional)
     * @param  string $mode mode (optional)
     * @param  double $amount amount (optional)
     * @param  \DateTime $start_date start_date (optional)
     * @param  \DateTime $end_date end_date (optional)
     * @param  bool $use_quantity_price_break use_quantity_price_break (optional)
     * @param  double $quantity_price_break quantity_price_break (optional)
     * @param  string $debtor_specific_price_id debtor_specific_price_id (optional)
     * @param  string $debtor_account_no debtor_account_no (optional)
     * @param  string $debtor_name debtor_name (optional)
     * @param  double $price price (optional)
     * @param  string $note note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorPrice
     */
    public function inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPost($accept, $inventory_id, $jiwa_stateful = null, $debtor_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_specific_price_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        list($response) = $this->inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $debtor_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_specific_price_id, $debtor_account_no, $debtor_name, $price, $note, $body);
        return $response;
    }

    /**
     * Operation inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostWithHttpInfo
     *
     * Adds a debtor specific price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_specific_price_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $debtor_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_specific_price_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPrice';
        $request = $this->inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostRequest($accept, $inventory_id, $jiwa_stateful, $debtor_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_specific_price_id, $debtor_account_no, $debtor_name, $price, $note, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostAsync
     *
     * Adds a debtor specific price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_specific_price_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostAsync($accept, $inventory_id, $jiwa_stateful = null, $debtor_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_specific_price_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        return $this->inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $debtor_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_specific_price_id, $debtor_account_no, $debtor_name, $price, $note, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostAsyncWithHttpInfo
     *
     * Adds a debtor specific price to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_specific_price_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $debtor_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_specific_price_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPrice';
        $request = $this->inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostRequest($accept, $inventory_id, $jiwa_stateful, $debtor_id, $source, $mode, $amount, $start_date, $end_date, $use_quantity_price_break, $quantity_price_break, $debtor_specific_price_id, $debtor_account_no, $debtor_name, $price, $note, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     * @param  string $source (optional)
     * @param  string $mode (optional)
     * @param  double $amount (optional)
     * @param  \DateTime $start_date (optional)
     * @param  \DateTime $end_date (optional)
     * @param  bool $use_quantity_price_break (optional)
     * @param  double $quantity_price_break (optional)
     * @param  string $debtor_specific_price_id (optional)
     * @param  string $debtor_account_no (optional)
     * @param  string $debtor_name (optional)
     * @param  double $price (optional)
     * @param  string $note (optional)
     * @param  \Jiwa\JiwaModel\InventoryDebtorSpecificPricePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPostRequest($accept, $inventory_id, $jiwa_stateful = null, $debtor_id = null, $source = null, $mode = null, $amount = null, $start_date = null, $end_date = null, $use_quantity_price_break = null, $quantity_price_break = null, $debtor_specific_price_id = null, $debtor_account_no = null, $debtor_name = null, $price = null, $note = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorSpecificPricePOSTRequestInventoryIDDebtorSpecificPricesPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorSpecificPrices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($debtor_id !== null) {
            $queryParams['DebtorID'] = ObjectSerializer::toQueryValue($debtor_id);
        }
        // query params
        if ($source !== null) {
            $queryParams['Source'] = ObjectSerializer::toQueryValue($source);
        }
        // query params
        if ($mode !== null) {
            $queryParams['Mode'] = ObjectSerializer::toQueryValue($mode);
        }
        // query params
        if ($amount !== null) {
            $queryParams['Amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['StartDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['EndDate'] = ObjectSerializer::toQueryValue($end_date);
        }
        // query params
        if ($use_quantity_price_break !== null) {
            $queryParams['UseQuantityPriceBreak'] = ObjectSerializer::toQueryValue($use_quantity_price_break);
        }
        // query params
        if ($quantity_price_break !== null) {
            $queryParams['QuantityPriceBreak'] = ObjectSerializer::toQueryValue($quantity_price_break);
        }
        // query params
        if ($debtor_specific_price_id !== null) {
            $queryParams['DebtorSpecificPriceID'] = ObjectSerializer::toQueryValue($debtor_specific_price_id);
        }
        // query params
        if ($debtor_account_no !== null) {
            $queryParams['DebtorAccountNo'] = ObjectSerializer::toQueryValue($debtor_account_no);
        }
        // query params
        if ($debtor_name !== null) {
            $queryParams['DebtorName'] = ObjectSerializer::toQueryValue($debtor_name);
        }
        // query params
        if ($price !== null) {
            $queryParams['Price'] = ObjectSerializer::toQueryValue($price);
        }
        // query params
        if ($note !== null) {
            $queryParams['Note'] = ObjectSerializer::toQueryValue($note);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGet
     *
     * Retrieves a list of debtor specific prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryDebtorPrice[]
     */
    public function inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetWithHttpInfo
     *
     * Retrieves a list of debtor specific prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryDebtorPrice[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPrice[]';
        $request = $this->inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryDebtorPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetAsync
     *
     * Retrieves a list of debtor specific prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor specific prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryDebtorPrice[]';
        $request = $this->inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDebtorSpecificPricesGETManyRequestInventoryIDDebtorSpecificPricesGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/DebtorSpecificPrices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDelete
     *
     * Deletes an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDelete($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteWithHttpInfo
     *
     * Deletes an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteRequest($accept, $inventory_id, $document_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteAsync
     *
     * Deletes an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteAsync($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        return $this->inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteRequest($accept, $inventory_id, $document_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDeleteRequest($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDelete'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling inventoryDocumentDELETERequestInventoryIDDocumentsDocumentIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGet
     *
     * Retrieves an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Document
     */
    public function inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGet($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetWithHttpInfo
     *
     * Retrieves an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetRequest($accept, $inventory_id, $document_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetAsync
     *
     * Retrieves an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetAsync($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        return $this->inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetAsyncWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetAsyncWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetRequest($accept, $inventory_id, $document_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGetRequest($accept, $inventory_id, $document_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGet'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling inventoryDocumentGETRequestInventoryIDDocumentsDocumentIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdate
     *
     * Updates an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type document_type (optional)
     * @param  string $file_id file_id (optional)
     * @param  string $physical_file_name physical_file_name (optional)
     * @param  string $full_physical_file_name full_physical_file_name (optional)
     * @param  string $description description (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $file_binary file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Document
     */
    public function inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdate($accept, $inventory_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        list($response) = $this->inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);
        return $response;
    }

    /**
     * Operation inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateWithHttpInfo
     *
     * Updates an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateRequest($accept, $inventory_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateAsync
     *
     * Updates an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateAsync($accept, $inventory_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        return $this->inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateRequest($accept, $inventory_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdateRequest($accept, $inventory_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdate'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling inventoryDocumentPATCHRequestInventoryIDDocumentsDocumentIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_type !== null) {
            $queryParams['DocumentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($file_id !== null) {
            $queryParams['FileID'] = ObjectSerializer::toQueryValue($file_id);
        }
        // query params
        if ($physical_file_name !== null) {
            $queryParams['PhysicalFileName'] = ObjectSerializer::toQueryValue($physical_file_name);
        }
        // query params
        if ($full_physical_file_name !== null) {
            $queryParams['FullPhysicalFileName'] = ObjectSerializer::toQueryValue($full_physical_file_name);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($file_binary !== null) {
            $queryParams['FileBinary'] = ObjectSerializer::toQueryValue($file_binary);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentPOSTRequestInventoryIDDocumentsPost
     *
     * Appends a document to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type document_type (optional)
     * @param  string $file_id file_id (optional)
     * @param  string $physical_file_name physical_file_name (optional)
     * @param  string $full_physical_file_name full_physical_file_name (optional)
     * @param  string $description description (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $file_binary file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Document
     */
    public function inventoryDocumentPOSTRequestInventoryIDDocumentsPost($accept, $inventory_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        list($response) = $this->inventoryDocumentPOSTRequestInventoryIDDocumentsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);
        return $response;
    }

    /**
     * Operation inventoryDocumentPOSTRequestInventoryIDDocumentsPostWithHttpInfo
     *
     * Appends a document to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentPOSTRequestInventoryIDDocumentsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->inventoryDocumentPOSTRequestInventoryIDDocumentsPostRequest($accept, $inventory_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentPOSTRequestInventoryIDDocumentsPostAsync
     *
     * Appends a document to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentPOSTRequestInventoryIDDocumentsPostAsync($accept, $inventory_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        return $this->inventoryDocumentPOSTRequestInventoryIDDocumentsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentPOSTRequestInventoryIDDocumentsPostAsyncWithHttpInfo
     *
     * Appends a document to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentPOSTRequestInventoryIDDocumentsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document';
        $request = $this->inventoryDocumentPOSTRequestInventoryIDDocumentsPostRequest($accept, $inventory_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentPOSTRequestInventoryIDDocumentsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentPOSTRequestInventoryIDDocumentsPostRequest($accept, $inventory_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentPOSTRequestInventoryIDDocumentsPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDocumentPOSTRequestInventoryIDDocumentsPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_type !== null) {
            $queryParams['DocumentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($file_id !== null) {
            $queryParams['FileID'] = ObjectSerializer::toQueryValue($file_id);
        }
        // query params
        if ($physical_file_name !== null) {
            $queryParams['PhysicalFileName'] = ObjectSerializer::toQueryValue($physical_file_name);
        }
        // query params
        if ($full_physical_file_name !== null) {
            $queryParams['FullPhysicalFileName'] = ObjectSerializer::toQueryValue($full_physical_file_name);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($file_binary !== null) {
            $queryParams['FileBinary'] = ObjectSerializer::toQueryValue($file_binary);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete
     *
     * Deletes an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete($accept, $document_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo($accept, $document_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo
     *
     * Deletes an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsync
     *
     * Deletes an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsync($accept, $document_type_id, $jiwa_stateful = null)
    {
        return $this->inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling inventoryDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
            );
        }

        $resourcePath = '/Inventory/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet
     *
     * Retrieves an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\DocumentType
     */
    public function inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet($accept, $document_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo($accept, $document_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo
     *
     * Retrieves an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsync
     *
     * Retrieves an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsync($accept, $document_type_id, $jiwa_stateful = null)
    {
        return $this->inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling inventoryDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
            );
        }

        $resourcePath = '/Inventory/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate
     *
     * Updates an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\DocumentType
     */
    public function inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo
     *
     * Updates an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsync
     *
     * Updates an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsync($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling inventoryDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
            );
        }

        $resourcePath = '/Inventory/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentTypePOSTRequestDocumentTypesPost
     *
     * Creates a new inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\DocumentType
     */
    public function inventoryDocumentTypePOSTRequestDocumentTypesPost($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->inventoryDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation inventoryDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo
     *
     * Creates a new inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->inventoryDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentTypePOSTRequestDocumentTypesPostAsync
     *
     * Creates a new inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypePOSTRequestDocumentTypesPostAsync($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->inventoryDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo
     *
     * Creates a new inventory document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType';
        $request = $this->inventoryDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentTypePOSTRequestDocumentTypesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentTypePOSTRequestDocumentTypesPost'
            );
        }

        $resourcePath = '/Inventory/DocumentTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentTypesGETManyRequestDocumentTypesGet
     *
     * Retrieves a list of inventory document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\DocumentType[]
     */
    public function inventoryDocumentTypesGETManyRequestDocumentTypesGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo
     *
     * Retrieves a list of inventory document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\DocumentType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType[]';
        $request = $this->inventoryDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentTypesGETManyRequestDocumentTypesGetAsync
     *
     * Retrieves a list of inventory document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypesGETManyRequestDocumentTypesGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->inventoryDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\DocumentType[]';
        $request = $this->inventoryDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentTypesGETManyRequestDocumentTypesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentTypesGETManyRequestDocumentTypesGet'
            );
        }

        $resourcePath = '/Inventory/DocumentTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryDocumentsGETManyRequestInventoryIDDocumentsGet
     *
     * Retrieves a list of inventory documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Document[]
     */
    public function inventoryDocumentsGETManyRequestInventoryIDDocumentsGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryDocumentsGETManyRequestInventoryIDDocumentsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryDocumentsGETManyRequestInventoryIDDocumentsGetWithHttpInfo
     *
     * Retrieves a list of inventory documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Document[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryDocumentsGETManyRequestInventoryIDDocumentsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document[]';
        $request = $this->inventoryDocumentsGETManyRequestInventoryIDDocumentsGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryDocumentsGETManyRequestInventoryIDDocumentsGetAsync
     *
     * Retrieves a list of inventory documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentsGETManyRequestInventoryIDDocumentsGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryDocumentsGETManyRequestInventoryIDDocumentsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryDocumentsGETManyRequestInventoryIDDocumentsGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryDocumentsGETManyRequestInventoryIDDocumentsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Document[]';
        $request = $this->inventoryDocumentsGETManyRequestInventoryIDDocumentsGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryDocumentsGETManyRequestInventoryIDDocumentsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryDocumentsGETManyRequestInventoryIDDocumentsGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryDocumentsGETManyRequestInventoryIDDocumentsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryDocumentsGETManyRequestInventoryIDDocumentsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGETRequestInventoryIDGet
     *
     * Retrieves an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryItem
     */
    public function inventoryGETRequestInventoryIDGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryGETRequestInventoryIDGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryGETRequestInventoryIDGetWithHttpInfo
     *
     * Retrieves an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGETRequestInventoryIDGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryItem';
        $request = $this->inventoryGETRequestInventoryIDGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGETRequestInventoryIDGetAsync
     *
     * Retrieves an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGETRequestInventoryIDGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryGETRequestInventoryIDGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGETRequestInventoryIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGETRequestInventoryIDGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryItem';
        $request = $this->inventoryGETRequestInventoryIDGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGETRequestInventoryIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGETRequestInventoryIDGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryGETRequestInventoryIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryGETRequestInventoryIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryLedgerGETRequestInventoryIDLedgersNameGet
     *
     * Retrieves an inventory ledger.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $name name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryLedger
     */
    public function inventoryLedgerGETRequestInventoryIDLedgersNameGet($accept, $inventory_id, $name, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryLedgerGETRequestInventoryIDLedgersNameGetWithHttpInfo($accept, $inventory_id, $name, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryLedgerGETRequestInventoryIDLedgersNameGetWithHttpInfo
     *
     * Retrieves an inventory ledger.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryLedger, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryLedgerGETRequestInventoryIDLedgersNameGetWithHttpInfo($accept, $inventory_id, $name, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryLedger';
        $request = $this->inventoryLedgerGETRequestInventoryIDLedgersNameGetRequest($accept, $inventory_id, $name, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryLedgerGETRequestInventoryIDLedgersNameGetAsync
     *
     * Retrieves an inventory ledger.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLedgerGETRequestInventoryIDLedgersNameGetAsync($accept, $inventory_id, $name, $jiwa_stateful = null)
    {
        return $this->inventoryLedgerGETRequestInventoryIDLedgersNameGetAsyncWithHttpInfo($accept, $inventory_id, $name, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryLedgerGETRequestInventoryIDLedgersNameGetAsyncWithHttpInfo
     *
     * Retrieves an inventory ledger.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLedgerGETRequestInventoryIDLedgersNameGetAsyncWithHttpInfo($accept, $inventory_id, $name, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryLedger';
        $request = $this->inventoryLedgerGETRequestInventoryIDLedgersNameGetRequest($accept, $inventory_id, $name, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryLedgerGETRequestInventoryIDLedgersNameGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryLedgerGETRequestInventoryIDLedgersNameGetRequest($accept, $inventory_id, $name, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryLedgerGETRequestInventoryIDLedgersNameGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryLedgerGETRequestInventoryIDLedgersNameGet'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling inventoryLedgerGETRequestInventoryIDLedgersNameGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Ledgers/{Name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'Name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdate
     *
     * Updates a inventory ledger.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $name name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $ledger_id ledger_id (optional)
     * @param  string $ledger_account_id ledger_account_id (optional)
     * @param  string $ledger_account_no ledger_account_no (optional)
     * @param  string $ledger_account_description ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryLedgerPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryLedger
     */
    public function inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdate($accept, $inventory_id, $name, $jiwa_stateful = null, $ledger_id = null, $ledger_account_id = null, $ledger_account_no = null, $ledger_account_description = null, $body = null)
    {
        list($response) = $this->inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateWithHttpInfo($accept, $inventory_id, $name, $jiwa_stateful, $ledger_id, $ledger_account_id, $ledger_account_no, $ledger_account_description, $body);
        return $response;
    }

    /**
     * Operation inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateWithHttpInfo
     *
     * Updates a inventory ledger.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $ledger_id (optional)
     * @param  string $ledger_account_id (optional)
     * @param  string $ledger_account_no (optional)
     * @param  string $ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryLedgerPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryLedger, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateWithHttpInfo($accept, $inventory_id, $name, $jiwa_stateful = null, $ledger_id = null, $ledger_account_id = null, $ledger_account_no = null, $ledger_account_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryLedger';
        $request = $this->inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateRequest($accept, $inventory_id, $name, $jiwa_stateful, $ledger_id, $ledger_account_id, $ledger_account_no, $ledger_account_description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateAsync
     *
     * Updates a inventory ledger.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $ledger_id (optional)
     * @param  string $ledger_account_id (optional)
     * @param  string $ledger_account_no (optional)
     * @param  string $ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryLedgerPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateAsync($accept, $inventory_id, $name, $jiwa_stateful = null, $ledger_id = null, $ledger_account_id = null, $ledger_account_no = null, $ledger_account_description = null, $body = null)
    {
        return $this->inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateAsyncWithHttpInfo($accept, $inventory_id, $name, $jiwa_stateful, $ledger_id, $ledger_account_id, $ledger_account_no, $ledger_account_description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateAsyncWithHttpInfo
     *
     * Updates a inventory ledger.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $ledger_id (optional)
     * @param  string $ledger_account_id (optional)
     * @param  string $ledger_account_no (optional)
     * @param  string $ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryLedgerPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateAsyncWithHttpInfo($accept, $inventory_id, $name, $jiwa_stateful = null, $ledger_id = null, $ledger_account_id = null, $ledger_account_no = null, $ledger_account_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryLedger';
        $request = $this->inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateRequest($accept, $inventory_id, $name, $jiwa_stateful, $ledger_id, $ledger_account_id, $ledger_account_no, $ledger_account_description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $ledger_id (optional)
     * @param  string $ledger_account_id (optional)
     * @param  string $ledger_account_no (optional)
     * @param  string $ledger_account_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryLedgerPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdateRequest($accept, $inventory_id, $name, $jiwa_stateful = null, $ledger_id = null, $ledger_account_id = null, $ledger_account_no = null, $ledger_account_description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdate'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling inventoryLedgerPATCHRequestInventoryIDLedgersNameUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Ledgers/{Name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ledger_id !== null) {
            $queryParams['LedgerID'] = ObjectSerializer::toQueryValue($ledger_id);
        }
        // query params
        if ($ledger_account_id !== null) {
            $queryParams['LedgerAccountID'] = ObjectSerializer::toQueryValue($ledger_account_id);
        }
        // query params
        if ($ledger_account_no !== null) {
            $queryParams['LedgerAccountNo'] = ObjectSerializer::toQueryValue($ledger_account_no);
        }
        // query params
        if ($ledger_account_description !== null) {
            $queryParams['LedgerAccountDescription'] = ObjectSerializer::toQueryValue($ledger_account_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'Name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryLedgersGETManyRequestInventoryIDLedgersGet
     *
     * Retrieves a list of inventory ledgers.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryLedger[]
     */
    public function inventoryLedgersGETManyRequestInventoryIDLedgersGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryLedgersGETManyRequestInventoryIDLedgersGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryLedgersGETManyRequestInventoryIDLedgersGetWithHttpInfo
     *
     * Retrieves a list of inventory ledgers.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryLedger[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryLedgersGETManyRequestInventoryIDLedgersGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryLedger[]';
        $request = $this->inventoryLedgersGETManyRequestInventoryIDLedgersGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryLedger[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryLedgersGETManyRequestInventoryIDLedgersGetAsync
     *
     * Retrieves a list of inventory ledgers.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLedgersGETManyRequestInventoryIDLedgersGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryLedgersGETManyRequestInventoryIDLedgersGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryLedgersGETManyRequestInventoryIDLedgersGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory ledgers.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLedgersGETManyRequestInventoryIDLedgersGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryLedger[]';
        $request = $this->inventoryLedgersGETManyRequestInventoryIDLedgersGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryLedgersGETManyRequestInventoryIDLedgersGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryLedgersGETManyRequestInventoryIDLedgersGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryLedgersGETManyRequestInventoryIDLedgersGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryLedgersGETManyRequestInventoryIDLedgersGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Ledgers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNoteDELETERequestInventoryIDNotesNoteIDDelete
     *
     * Deletes an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryNoteDELETERequestInventoryIDNotesNoteIDDelete($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteWithHttpInfo
     *
     * Deletes an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteRequest($accept, $inventory_id, $note_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteAsync
     *
     * Deletes an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteAsync($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        return $this->inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteRequest($accept, $inventory_id, $note_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNoteDELETERequestInventoryIDNotesNoteIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNoteDELETERequestInventoryIDNotesNoteIDDeleteRequest($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNoteDELETERequestInventoryIDNotesNoteIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryNoteDELETERequestInventoryIDNotesNoteIDDelete'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling inventoryNoteDELETERequestInventoryIDNotesNoteIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNoteGETRequestInventoryIDNotesNoteIDGet
     *
     * Retrieves an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Note
     */
    public function inventoryNoteGETRequestInventoryIDNotesNoteIDGet($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryNoteGETRequestInventoryIDNotesNoteIDGetWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryNoteGETRequestInventoryIDNotesNoteIDGetWithHttpInfo
     *
     * Retrieves an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNoteGETRequestInventoryIDNotesNoteIDGetWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->inventoryNoteGETRequestInventoryIDNotesNoteIDGetRequest($accept, $inventory_id, $note_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNoteGETRequestInventoryIDNotesNoteIDGetAsync
     *
     * Retrieves an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteGETRequestInventoryIDNotesNoteIDGetAsync($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        return $this->inventoryNoteGETRequestInventoryIDNotesNoteIDGetAsyncWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNoteGETRequestInventoryIDNotesNoteIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteGETRequestInventoryIDNotesNoteIDGetAsyncWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->inventoryNoteGETRequestInventoryIDNotesNoteIDGetRequest($accept, $inventory_id, $note_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNoteGETRequestInventoryIDNotesNoteIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNoteGETRequestInventoryIDNotesNoteIDGetRequest($accept, $inventory_id, $note_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNoteGETRequestInventoryIDNotesNoteIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryNoteGETRequestInventoryIDNotesNoteIDGet'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling inventoryNoteGETRequestInventoryIDNotesNoteIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdate
     *
     * Updates an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type note_type (optional)
     * @param  int $line_no line_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $note_text note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Note
     */
    public function inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdate($accept, $inventory_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        list($response) = $this->inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);
        return $response;
    }

    /**
     * Operation inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateWithHttpInfo
     *
     * Updates an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateRequest($accept, $inventory_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateAsync
     *
     * Updates an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateAsync($accept, $inventory_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        return $this->inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateRequest($accept, $inventory_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdateRequest($accept, $inventory_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdate'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling inventoryNotePATCHRequestInventoryIDNotesNoteIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($note_type !== null) {
            $queryParams['NoteType'] = ObjectSerializer::toQueryValue($note_type);
        }
        // query params
        if ($line_no !== null) {
            $queryParams['LineNo'] = ObjectSerializer::toQueryValue($line_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($note_text !== null) {
            $queryParams['NoteText'] = ObjectSerializer::toQueryValue($note_text);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNotePOSTRequestInventoryIDNotesPost
     *
     * Appends a note to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type note_type (optional)
     * @param  int $line_no line_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $note_text note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Note
     */
    public function inventoryNotePOSTRequestInventoryIDNotesPost($accept, $inventory_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        list($response) = $this->inventoryNotePOSTRequestInventoryIDNotesPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);
        return $response;
    }

    /**
     * Operation inventoryNotePOSTRequestInventoryIDNotesPostWithHttpInfo
     *
     * Appends a note to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNotePOSTRequestInventoryIDNotesPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->inventoryNotePOSTRequestInventoryIDNotesPostRequest($accept, $inventory_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNotePOSTRequestInventoryIDNotesPostAsync
     *
     * Appends a note to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNotePOSTRequestInventoryIDNotesPostAsync($accept, $inventory_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        return $this->inventoryNotePOSTRequestInventoryIDNotesPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNotePOSTRequestInventoryIDNotesPostAsyncWithHttpInfo
     *
     * Appends a note to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNotePOSTRequestInventoryIDNotesPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note';
        $request = $this->inventoryNotePOSTRequestInventoryIDNotesPostRequest($accept, $inventory_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNotePOSTRequestInventoryIDNotesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\JiwaModel\InventoryNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNotePOSTRequestInventoryIDNotesPostRequest($accept, $inventory_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNotePOSTRequestInventoryIDNotesPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryNotePOSTRequestInventoryIDNotesPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($note_type !== null) {
            $queryParams['NoteType'] = ObjectSerializer::toQueryValue($note_type);
        }
        // query params
        if ($line_no !== null) {
            $queryParams['LineNo'] = ObjectSerializer::toQueryValue($line_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($note_text !== null) {
            $queryParams['NoteText'] = ObjectSerializer::toQueryValue($note_text);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDelete
     *
     * Deletes an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDelete($accept, $note_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo($accept, $note_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo
     *
     * Deletes an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsync
     *
     * Deletes an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsync($accept, $note_type_id, $jiwa_stateful = null)
    {
        return $this->inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling inventoryNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
            );
        }

        $resourcePath = '/Inventory/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGet
     *
     * Retrieves an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\NoteType
     */
    public function inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGet($accept, $note_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo($accept, $note_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo
     *
     * Retrieves an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetAsync
     *
     * Retrieves an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetAsync($accept, $note_type_id, $jiwa_stateful = null)
    {
        return $this->inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGet'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling inventoryNoteTypeGETRequestNoteTypesNoteTypeIDGet'
            );
        }

        $resourcePath = '/Inventory/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate
     *
     * Updates an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\NoteType
     */
    public function inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo
     *
     * Updates an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsync
     *
     * Updates an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsync($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling inventoryNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
            );
        }

        $resourcePath = '/Inventory/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNoteTypePOSTRequestNoteTypesPost
     *
     * Creates a new inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\NoteType
     */
    public function inventoryNoteTypePOSTRequestNoteTypesPost($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->inventoryNoteTypePOSTRequestNoteTypesPostWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation inventoryNoteTypePOSTRequestNoteTypesPostWithHttpInfo
     *
     * Creates a new inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNoteTypePOSTRequestNoteTypesPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->inventoryNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNoteTypePOSTRequestNoteTypesPostAsync
     *
     * Creates a new inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypePOSTRequestNoteTypesPostAsync($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->inventoryNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo
     *
     * Creates a new inventory note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType';
        $request = $this->inventoryNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNoteTypePOSTRequestNoteTypesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNoteTypePOSTRequestNoteTypesPost'
            );
        }

        $resourcePath = '/Inventory/NoteTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNoteTypesGETManyRequestNoteTypesGet
     *
     * Retrieves a list of inventory note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\NoteType[]
     */
    public function inventoryNoteTypesGETManyRequestNoteTypesGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryNoteTypesGETManyRequestNoteTypesGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryNoteTypesGETManyRequestNoteTypesGetWithHttpInfo
     *
     * Retrieves a list of inventory note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\NoteType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNoteTypesGETManyRequestNoteTypesGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType[]';
        $request = $this->inventoryNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNoteTypesGETManyRequestNoteTypesGetAsync
     *
     * Retrieves a list of inventory note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypesGETManyRequestNoteTypesGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->inventoryNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\NoteType[]';
        $request = $this->inventoryNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNoteTypesGETManyRequestNoteTypesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNoteTypesGETManyRequestNoteTypesGet'
            );
        }

        $resourcePath = '/Inventory/NoteTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryNotesGETManyRequestInventoryIDNotesGet
     *
     * Retrieves a list of inventory notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Note[]
     */
    public function inventoryNotesGETManyRequestInventoryIDNotesGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryNotesGETManyRequestInventoryIDNotesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryNotesGETManyRequestInventoryIDNotesGetWithHttpInfo
     *
     * Retrieves a list of inventory notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Note[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryNotesGETManyRequestInventoryIDNotesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note[]';
        $request = $this->inventoryNotesGETManyRequestInventoryIDNotesGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryNotesGETManyRequestInventoryIDNotesGetAsync
     *
     * Retrieves a list of inventory notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNotesGETManyRequestInventoryIDNotesGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryNotesGETManyRequestInventoryIDNotesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryNotesGETManyRequestInventoryIDNotesGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryNotesGETManyRequestInventoryIDNotesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Note[]';
        $request = $this->inventoryNotesGETManyRequestInventoryIDNotesGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryNotesGETManyRequestInventoryIDNotesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryNotesGETManyRequestInventoryIDNotesGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryNotesGETManyRequestInventoryIDNotesGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryNotesGETManyRequestInventoryIDNotesGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGet
     *
     * Retrieves a order level from an inventory item for a particular logical warehouse.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id logical_warehouse_id (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  int $period_no period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryOrderLevel
     */
    public function inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGet($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetWithHttpInfo($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetWithHttpInfo
     *
     * Retrieves a order level from an inventory item for a particular logical warehouse.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id (required)
     * @param  string $inventory_id (required)
     * @param  int $period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryOrderLevel, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetWithHttpInfo($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOrderLevel';
        $request = $this->inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetRequest($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetAsync
     *
     * Retrieves a order level from an inventory item for a particular logical warehouse.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id (required)
     * @param  string $inventory_id (required)
     * @param  int $period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetAsync($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null)
    {
        return $this->inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetAsyncWithHttpInfo($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetAsyncWithHttpInfo
     *
     * Retrieves a order level from an inventory item for a particular logical warehouse.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id (required)
     * @param  string $inventory_id (required)
     * @param  int $period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetAsyncWithHttpInfo($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOrderLevel';
        $request = $this->inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetRequest($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id (required)
     * @param  string $inventory_id (required)
     * @param  int $period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGetRequest($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGet'
            );
        }
        // verify the required parameter 'logical_warehouse_id' is set
        if ($logical_warehouse_id === null || (is_array($logical_warehouse_id) && count($logical_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logical_warehouse_id when calling inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGet'
            );
        }
        // verify the required parameter 'period_no' is set
        if ($period_no === null || (is_array($period_no) && count($period_no) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period_no when calling inventoryOrderLevelGETRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/OrderLevels/{LogicalWarehouseID}/Periods/{PeriodNo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($logical_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'LogicalWarehouseID' . '}',
                ObjectSerializer::toPathValue($logical_warehouse_id),
                $resourcePath
            );
        }
        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($period_no !== null) {
            $resourcePath = str_replace(
                '{' . 'PeriodNo' . '}',
                ObjectSerializer::toPathValue($period_no),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdate
     *
     * Updates an order level.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id logical_warehouse_id (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  int $period_no period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  \DateTime $month_start_date month_start_date (optional)
     * @param  \DateTime $month_end_date month_end_date (optional)
     * @param  double $min_soh_units min_soh_units (optional)
     * @param  double $min_safety_soh_units min_safety_soh_units (optional)
     * @param  double $max_safety_soh_units max_safety_soh_units (optional)
     * @param  string $logical_warehouse_description logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOrderLevelPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryOrderLevel
     */
    public function inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdate($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null, $month_start_date = null, $month_end_date = null, $min_soh_units = null, $min_safety_soh_units = null, $max_safety_soh_units = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        list($response) = $this->inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateWithHttpInfo($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful, $month_start_date, $month_end_date, $min_soh_units, $min_safety_soh_units, $max_safety_soh_units, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);
        return $response;
    }

    /**
     * Operation inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateWithHttpInfo
     *
     * Updates an order level.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id (required)
     * @param  string $inventory_id (required)
     * @param  int $period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  \DateTime $month_start_date (optional)
     * @param  \DateTime $month_end_date (optional)
     * @param  double $min_soh_units (optional)
     * @param  double $min_safety_soh_units (optional)
     * @param  double $max_safety_soh_units (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOrderLevelPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryOrderLevel, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateWithHttpInfo($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null, $month_start_date = null, $month_end_date = null, $min_soh_units = null, $min_safety_soh_units = null, $max_safety_soh_units = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOrderLevel';
        $request = $this->inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateRequest($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful, $month_start_date, $month_end_date, $min_soh_units, $min_safety_soh_units, $max_safety_soh_units, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateAsync
     *
     * Updates an order level.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id (required)
     * @param  string $inventory_id (required)
     * @param  int $period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  \DateTime $month_start_date (optional)
     * @param  \DateTime $month_end_date (optional)
     * @param  double $min_soh_units (optional)
     * @param  double $min_safety_soh_units (optional)
     * @param  double $max_safety_soh_units (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOrderLevelPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateAsync($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null, $month_start_date = null, $month_end_date = null, $min_soh_units = null, $min_safety_soh_units = null, $max_safety_soh_units = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        return $this->inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateAsyncWithHttpInfo($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful, $month_start_date, $month_end_date, $min_soh_units, $min_safety_soh_units, $max_safety_soh_units, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateAsyncWithHttpInfo
     *
     * Updates an order level.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id (required)
     * @param  string $inventory_id (required)
     * @param  int $period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  \DateTime $month_start_date (optional)
     * @param  \DateTime $month_end_date (optional)
     * @param  double $min_soh_units (optional)
     * @param  double $min_safety_soh_units (optional)
     * @param  double $max_safety_soh_units (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOrderLevelPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateAsyncWithHttpInfo($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null, $month_start_date = null, $month_end_date = null, $min_soh_units = null, $min_safety_soh_units = null, $max_safety_soh_units = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOrderLevel';
        $request = $this->inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateRequest($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful, $month_start_date, $month_end_date, $min_soh_units, $min_safety_soh_units, $max_safety_soh_units, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $logical_warehouse_id (required)
     * @param  string $inventory_id (required)
     * @param  int $period_no (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  \DateTime $month_start_date (optional)
     * @param  \DateTime $month_end_date (optional)
     * @param  double $min_soh_units (optional)
     * @param  double $min_safety_soh_units (optional)
     * @param  double $max_safety_soh_units (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOrderLevelPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdateRequest($accept, $logical_warehouse_id, $inventory_id, $period_no, $jiwa_stateful = null, $month_start_date = null, $month_end_date = null, $min_soh_units = null, $min_safety_soh_units = null, $max_safety_soh_units = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdate'
            );
        }
        // verify the required parameter 'logical_warehouse_id' is set
        if ($logical_warehouse_id === null || (is_array($logical_warehouse_id) && count($logical_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logical_warehouse_id when calling inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdate'
            );
        }
        // verify the required parameter 'period_no' is set
        if ($period_no === null || (is_array($period_no) && count($period_no) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period_no when calling inventoryOrderLevelPATCHRequestInventoryIDOrderLevelsLogicalWarehouseIDPeriodsPeriodNoUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/OrderLevels/{LogicalWarehouseID}/Periods/{PeriodNo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($month_start_date !== null) {
            $queryParams['MonthStartDate'] = ObjectSerializer::toQueryValue($month_start_date);
        }
        // query params
        if ($month_end_date !== null) {
            $queryParams['MonthEndDate'] = ObjectSerializer::toQueryValue($month_end_date);
        }
        // query params
        if ($min_soh_units !== null) {
            $queryParams['MinSOHUnits'] = ObjectSerializer::toQueryValue($min_soh_units);
        }
        // query params
        if ($min_safety_soh_units !== null) {
            $queryParams['MinSafetySOHUnits'] = ObjectSerializer::toQueryValue($min_safety_soh_units);
        }
        // query params
        if ($max_safety_soh_units !== null) {
            $queryParams['MaxSafetySOHUnits'] = ObjectSerializer::toQueryValue($max_safety_soh_units);
        }
        // query params
        if ($logical_warehouse_description !== null) {
            $queryParams['LogicalWarehouseDescription'] = ObjectSerializer::toQueryValue($logical_warehouse_description);
        }
        // query params
        if ($physical_warehouse_id !== null) {
            $queryParams['PhysicalWarehouseID'] = ObjectSerializer::toQueryValue($physical_warehouse_id);
        }
        // query params
        if ($physical_warehouse_description !== null) {
            $queryParams['PhysicalWarehouseDescription'] = ObjectSerializer::toQueryValue($physical_warehouse_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($logical_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'LogicalWarehouseID' . '}',
                ObjectSerializer::toPathValue($logical_warehouse_id),
                $resourcePath
            );
        }
        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($period_no !== null) {
            $resourcePath = str_replace(
                '{' . 'PeriodNo' . '}',
                ObjectSerializer::toPathValue($period_no),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGet
     *
     * Retrieves a list of order levels for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryOrderLevel[]
     */
    public function inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetWithHttpInfo
     *
     * Retrieves a list of order levels for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryOrderLevel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOrderLevel[]';
        $request = $this->inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOrderLevel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetAsync
     *
     * Retrieves a list of order levels for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetAsyncWithHttpInfo
     *
     * Retrieves a list of order levels for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOrderLevel[]';
        $request = $this->inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryOrderLevelsGETManyRequestInventoryIDOrderLevelsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/OrderLevels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDelete
     *
     * Deletes an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $other_description_id other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDelete($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null)
    {
        list($response) = $this->inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful, $description);
        return $response;
    }

    /**
     * Operation inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteWithHttpInfo
     *
     * Deletes an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful, $description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteAsync
     *
     * Deletes an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteAsync($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null)
    {
        return $this->inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful, $description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful, $description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDeleteRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDelete'
            );
        }
        // verify the required parameter 'other_description_id' is set
        if ($other_description_id === null || (is_array($other_description_id) && count($other_description_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $other_description_id when calling inventoryOtherDescriptionDELETERequestInventoryIDOtherDescriptionsOtherDescriptionIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/OtherDescriptions/{OtherDescriptionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($other_description_id !== null) {
            $resourcePath = str_replace(
                '{' . 'OtherDescriptionID' . '}',
                ObjectSerializer::toPathValue($other_description_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGet
     *
     * Retrieves an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $other_description_id other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryOtherDescription
     */
    public function inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGet($accept, $inventory_id, $other_description_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetWithHttpInfo
     *
     * Retrieves an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryOtherDescription, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOtherDescription';
        $request = $this->inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetAsync
     *
     * Retrieves an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetAsync($accept, $inventory_id, $other_description_id, $jiwa_stateful = null)
    {
        return $this->inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetAsyncWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetAsyncWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOtherDescription';
        $request = $this->inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGetRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGet'
            );
        }
        // verify the required parameter 'other_description_id' is set
        if ($other_description_id === null || (is_array($other_description_id) && count($other_description_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $other_description_id when calling inventoryOtherDescriptionGETRequestInventoryIDOtherDescriptionsOtherDescriptionIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/OtherDescriptions/{OtherDescriptionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($other_description_id !== null) {
            $resourcePath = str_replace(
                '{' . 'OtherDescriptionID' . '}',
                ObjectSerializer::toPathValue($other_description_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdate
     *
     * Updates an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $other_description_id other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryOtherDescription
     */
    public function inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdate($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        list($response) = $this->inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful, $description, $body);
        return $response;
    }

    /**
     * Operation inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateWithHttpInfo
     *
     * Updates an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryOtherDescription, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOtherDescription';
        $request = $this->inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful, $description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateAsync
     *
     * Updates an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateAsync($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        return $this->inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful, $description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory other description.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOtherDescription';
        $request = $this->inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful, $description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $other_description_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdateRequest($accept, $inventory_id, $other_description_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdate'
            );
        }
        // verify the required parameter 'other_description_id' is set
        if ($other_description_id === null || (is_array($other_description_id) && count($other_description_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $other_description_id when calling inventoryOtherDescriptionPATCHRequestInventoryIDOtherDescriptionsOtherDescriptionIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/OtherDescriptions/{OtherDescriptionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($other_description_id !== null) {
            $resourcePath = str_replace(
                '{' . 'OtherDescriptionID' . '}',
                ObjectSerializer::toPathValue($other_description_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPost
     *
     * Appends an other description to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryOtherDescription
     */
    public function inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPost($accept, $inventory_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        list($response) = $this->inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $description, $body);
        return $response;
    }

    /**
     * Operation inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostWithHttpInfo
     *
     * Appends an other description to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryOtherDescription, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOtherDescription';
        $request = $this->inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostRequest($accept, $inventory_id, $jiwa_stateful, $description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostAsync
     *
     * Appends an other description to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostAsync($accept, $inventory_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        return $this->inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostAsyncWithHttpInfo
     *
     * Appends an other description to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOtherDescription';
        $request = $this->inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostRequest($accept, $inventory_id, $jiwa_stateful, $description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \Jiwa\JiwaModel\InventoryOtherDescriptionPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPostRequest($accept, $inventory_id, $jiwa_stateful = null, $description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryOtherDescriptionPOSTRequestInventoryIDOtherDescriptionsPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/OtherDescriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGet
     *
     * Retrieves a list of inventory other descriptions.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryOtherDescription[]
     */
    public function inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetWithHttpInfo
     *
     * Retrieves a list of inventory other descriptions.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryOtherDescription[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOtherDescription[]';
        $request = $this->inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryOtherDescription[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetAsync
     *
     * Retrieves a list of inventory other descriptions.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory other descriptions.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryOtherDescription[]';
        $request = $this->inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryOtherDescriptionsGETManyRequestInventoryIDOtherDescriptionsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/OtherDescriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPATCHRequestInventoryIDUpdate
     *
     * Updates an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item physical_item (optional)
     * @param  bool $ship_with_physical_item ship_with_physical_item (optional)
     * @param  bool $discountable discountable (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  double $direct_tax direct_tax (optional)
     * @param  string $status status (optional)
     * @param  double $default_price default_price (optional)
     * @param  double $rrp_price rrp_price (optional)
     * @param  double $l_cost l_cost (optional)
     * @param  double $s_cost s_cost (optional)
     * @param  int $decimal_places decimal_places (optional)
     * @param  double $minimum_gp minimum_gp (optional)
     * @param  double $weight weight (optional)
     * @param  double $cubic cubic (optional)
     * @param  bool $use_serial_no use_serial_no (optional)
     * @param  bool $back_orderable back_orderable (optional)
     * @param  double $sales_man_cost sales_man_cost (optional)
     * @param  double $secondary_cost secondary_cost (optional)
     * @param  string $bom_object bom_object (optional)
     * @param  bool $use_expiry_date use_expiry_date (optional)
     * @param  bool $use_standard_cost use_standard_cost (optional)
     * @param  double $standard_cost standard_cost (optional)
     * @param  bool $web_enabled web_enabled (optional)
     * @param  bool $sell_price_inc_tax sell_price_inc_tax (optional)
     * @param  string $style style (optional)
     * @param  string $colour colour (optional)
     * @param  string $size size (optional)
     * @param  int $part_encode_order part_encode_order (optional)
     * @param  string $part_no part_no (optional)
     * @param  string $picture picture (optional)
     * @param  string $description description (optional)
     * @param  string $unit_measure unit_measure (optional)
     * @param  string $classification classification (optional)
     * @param  string $category1 category1 (optional)
     * @param  string $category2 category2 (optional)
     * @param  string $category3 category3 (optional)
     * @param  string $category4 category4 (optional)
     * @param  string $category5 category5 (optional)
     * @param  string $aux1 aux1 (optional)
     * @param  string $aux2 aux2 (optional)
     * @param  string $aux3 aux3 (optional)
     * @param  string $aux4 aux4 (optional)
     * @param  string $aux5 aux5 (optional)
     * @param  string $gst_inwards_id gst_inwards_id (optional)
     * @param  string $gst_inwards_description gst_inwards_description (optional)
     * @param  double $gst_inwards_rate gst_inwards_rate (optional)
     * @param  string $gst_outwards_id gst_outwards_id (optional)
     * @param  string $gst_outwards_description gst_outwards_description (optional)
     * @param  double $gst_outwards_rate gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate gst_adjustments_out_rate (optional)
     * @param  string $matrix_description matrix_description (optional)
     * @param  string $pricing_group_id pricing_group_id (optional)
     * @param  string $pricing_group_description pricing_group_description (optional)
     * @param  string $inventory_ledgers inventory_ledgers (optional)
     * @param  string $notes notes (optional)
     * @param  string $documents documents (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $regions regions (optional)
     * @param  string $debtor_prices debtor_prices (optional)
     * @param  string $debtor_class_prices debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children alternate_children (optional)
     * @param  string $alternate_parents alternate_parents (optional)
     * @param  string $components components (optional)
     * @param  string $warehouse_so_hs warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers debtor_part_numbers (optional)
     * @param  string $group_memberships group_memberships (optional)
     * @param  string $other_descriptions other_descriptions (optional)
     * @param  string $order_levels order_levels (optional)
     * @param  string $budgets budgets (optional)
     * @param  string $logical_orders logical_orders (optional)
     * @param  string $default_bin_locations default_bin_locations (optional)
     * @param  string $product_availabilities product_availabilities (optional)
     * @param  string $selling_prices selling_prices (optional)
     * @param  string $up_sells up_sells (optional)
     * @param  string $attribute_groups attribute_groups (optional)
     * @param  string $unit_of_measures unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryItem
     */
    public function inventoryPATCHRequestInventoryIDUpdate($accept, $inventory_id, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $last_saved_date_time = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        list($response) = $this->inventoryPATCHRequestInventoryIDUpdateWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $physical_item, $ship_with_physical_item, $discountable, $last_saved_date_time, $direct_tax, $status, $default_price, $rrp_price, $l_cost, $s_cost, $decimal_places, $minimum_gp, $weight, $cubic, $use_serial_no, $back_orderable, $sales_man_cost, $secondary_cost, $bom_object, $use_expiry_date, $use_standard_cost, $standard_cost, $web_enabled, $sell_price_inc_tax, $style, $colour, $size, $part_encode_order, $part_no, $picture, $description, $unit_measure, $classification, $category1, $category2, $category3, $category4, $category5, $aux1, $aux2, $aux3, $aux4, $aux5, $gst_inwards_id, $gst_inwards_description, $gst_inwards_rate, $gst_outwards_id, $gst_outwards_description, $gst_outwards_rate, $gst_adjustments_inid, $gst_adjustments_in_description, $gst_adjustments_in_rate, $gst_adjustments_outid, $gst_adjustments_out_description, $gst_adjustments_out_rate, $matrix_description, $pricing_group_id, $pricing_group_description, $inventory_ledgers, $notes, $documents, $custom_field_values, $regions, $debtor_prices, $debtor_class_prices, $debtor_price_group_inventory_specific_prices, $alternate_children, $alternate_parents, $components, $warehouse_so_hs, $debtor_part_numbers, $group_memberships, $other_descriptions, $order_levels, $budgets, $logical_orders, $default_bin_locations, $product_availabilities, $selling_prices, $up_sells, $attribute_groups, $unit_of_measures, $body);
        return $response;
    }

    /**
     * Operation inventoryPATCHRequestInventoryIDUpdateWithHttpInfo
     *
     * Updates an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item (optional)
     * @param  bool $ship_with_physical_item (optional)
     * @param  bool $discountable (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  double $direct_tax (optional)
     * @param  string $status (optional)
     * @param  double $default_price (optional)
     * @param  double $rrp_price (optional)
     * @param  double $l_cost (optional)
     * @param  double $s_cost (optional)
     * @param  int $decimal_places (optional)
     * @param  double $minimum_gp (optional)
     * @param  double $weight (optional)
     * @param  double $cubic (optional)
     * @param  bool $use_serial_no (optional)
     * @param  bool $back_orderable (optional)
     * @param  double $sales_man_cost (optional)
     * @param  double $secondary_cost (optional)
     * @param  string $bom_object (optional)
     * @param  bool $use_expiry_date (optional)
     * @param  bool $use_standard_cost (optional)
     * @param  double $standard_cost (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $sell_price_inc_tax (optional)
     * @param  string $style (optional)
     * @param  string $colour (optional)
     * @param  string $size (optional)
     * @param  int $part_encode_order (optional)
     * @param  string $part_no (optional)
     * @param  string $picture (optional)
     * @param  string $description (optional)
     * @param  string $unit_measure (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $aux1 (optional)
     * @param  string $aux2 (optional)
     * @param  string $aux3 (optional)
     * @param  string $aux4 (optional)
     * @param  string $aux5 (optional)
     * @param  string $gst_inwards_id (optional)
     * @param  string $gst_inwards_description (optional)
     * @param  double $gst_inwards_rate (optional)
     * @param  string $gst_outwards_id (optional)
     * @param  string $gst_outwards_description (optional)
     * @param  double $gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate (optional)
     * @param  string $matrix_description (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $regions (optional)
     * @param  string $debtor_prices (optional)
     * @param  string $debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children (optional)
     * @param  string $alternate_parents (optional)
     * @param  string $components (optional)
     * @param  string $warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $group_memberships (optional)
     * @param  string $other_descriptions (optional)
     * @param  string $order_levels (optional)
     * @param  string $budgets (optional)
     * @param  string $logical_orders (optional)
     * @param  string $default_bin_locations (optional)
     * @param  string $product_availabilities (optional)
     * @param  string $selling_prices (optional)
     * @param  string $up_sells (optional)
     * @param  string $attribute_groups (optional)
     * @param  string $unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPATCHRequestInventoryIDUpdateWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $last_saved_date_time = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryItem';
        $request = $this->inventoryPATCHRequestInventoryIDUpdateRequest($accept, $inventory_id, $jiwa_stateful, $physical_item, $ship_with_physical_item, $discountable, $last_saved_date_time, $direct_tax, $status, $default_price, $rrp_price, $l_cost, $s_cost, $decimal_places, $minimum_gp, $weight, $cubic, $use_serial_no, $back_orderable, $sales_man_cost, $secondary_cost, $bom_object, $use_expiry_date, $use_standard_cost, $standard_cost, $web_enabled, $sell_price_inc_tax, $style, $colour, $size, $part_encode_order, $part_no, $picture, $description, $unit_measure, $classification, $category1, $category2, $category3, $category4, $category5, $aux1, $aux2, $aux3, $aux4, $aux5, $gst_inwards_id, $gst_inwards_description, $gst_inwards_rate, $gst_outwards_id, $gst_outwards_description, $gst_outwards_rate, $gst_adjustments_inid, $gst_adjustments_in_description, $gst_adjustments_in_rate, $gst_adjustments_outid, $gst_adjustments_out_description, $gst_adjustments_out_rate, $matrix_description, $pricing_group_id, $pricing_group_description, $inventory_ledgers, $notes, $documents, $custom_field_values, $regions, $debtor_prices, $debtor_class_prices, $debtor_price_group_inventory_specific_prices, $alternate_children, $alternate_parents, $components, $warehouse_so_hs, $debtor_part_numbers, $group_memberships, $other_descriptions, $order_levels, $budgets, $logical_orders, $default_bin_locations, $product_availabilities, $selling_prices, $up_sells, $attribute_groups, $unit_of_measures, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPATCHRequestInventoryIDUpdateAsync
     *
     * Updates an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item (optional)
     * @param  bool $ship_with_physical_item (optional)
     * @param  bool $discountable (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  double $direct_tax (optional)
     * @param  string $status (optional)
     * @param  double $default_price (optional)
     * @param  double $rrp_price (optional)
     * @param  double $l_cost (optional)
     * @param  double $s_cost (optional)
     * @param  int $decimal_places (optional)
     * @param  double $minimum_gp (optional)
     * @param  double $weight (optional)
     * @param  double $cubic (optional)
     * @param  bool $use_serial_no (optional)
     * @param  bool $back_orderable (optional)
     * @param  double $sales_man_cost (optional)
     * @param  double $secondary_cost (optional)
     * @param  string $bom_object (optional)
     * @param  bool $use_expiry_date (optional)
     * @param  bool $use_standard_cost (optional)
     * @param  double $standard_cost (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $sell_price_inc_tax (optional)
     * @param  string $style (optional)
     * @param  string $colour (optional)
     * @param  string $size (optional)
     * @param  int $part_encode_order (optional)
     * @param  string $part_no (optional)
     * @param  string $picture (optional)
     * @param  string $description (optional)
     * @param  string $unit_measure (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $aux1 (optional)
     * @param  string $aux2 (optional)
     * @param  string $aux3 (optional)
     * @param  string $aux4 (optional)
     * @param  string $aux5 (optional)
     * @param  string $gst_inwards_id (optional)
     * @param  string $gst_inwards_description (optional)
     * @param  double $gst_inwards_rate (optional)
     * @param  string $gst_outwards_id (optional)
     * @param  string $gst_outwards_description (optional)
     * @param  double $gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate (optional)
     * @param  string $matrix_description (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $regions (optional)
     * @param  string $debtor_prices (optional)
     * @param  string $debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children (optional)
     * @param  string $alternate_parents (optional)
     * @param  string $components (optional)
     * @param  string $warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $group_memberships (optional)
     * @param  string $other_descriptions (optional)
     * @param  string $order_levels (optional)
     * @param  string $budgets (optional)
     * @param  string $logical_orders (optional)
     * @param  string $default_bin_locations (optional)
     * @param  string $product_availabilities (optional)
     * @param  string $selling_prices (optional)
     * @param  string $up_sells (optional)
     * @param  string $attribute_groups (optional)
     * @param  string $unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPATCHRequestInventoryIDUpdateAsync($accept, $inventory_id, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $last_saved_date_time = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        return $this->inventoryPATCHRequestInventoryIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $physical_item, $ship_with_physical_item, $discountable, $last_saved_date_time, $direct_tax, $status, $default_price, $rrp_price, $l_cost, $s_cost, $decimal_places, $minimum_gp, $weight, $cubic, $use_serial_no, $back_orderable, $sales_man_cost, $secondary_cost, $bom_object, $use_expiry_date, $use_standard_cost, $standard_cost, $web_enabled, $sell_price_inc_tax, $style, $colour, $size, $part_encode_order, $part_no, $picture, $description, $unit_measure, $classification, $category1, $category2, $category3, $category4, $category5, $aux1, $aux2, $aux3, $aux4, $aux5, $gst_inwards_id, $gst_inwards_description, $gst_inwards_rate, $gst_outwards_id, $gst_outwards_description, $gst_outwards_rate, $gst_adjustments_inid, $gst_adjustments_in_description, $gst_adjustments_in_rate, $gst_adjustments_outid, $gst_adjustments_out_description, $gst_adjustments_out_rate, $matrix_description, $pricing_group_id, $pricing_group_description, $inventory_ledgers, $notes, $documents, $custom_field_values, $regions, $debtor_prices, $debtor_class_prices, $debtor_price_group_inventory_specific_prices, $alternate_children, $alternate_parents, $components, $warehouse_so_hs, $debtor_part_numbers, $group_memberships, $other_descriptions, $order_levels, $budgets, $logical_orders, $default_bin_locations, $product_availabilities, $selling_prices, $up_sells, $attribute_groups, $unit_of_measures, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPATCHRequestInventoryIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item (optional)
     * @param  bool $ship_with_physical_item (optional)
     * @param  bool $discountable (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  double $direct_tax (optional)
     * @param  string $status (optional)
     * @param  double $default_price (optional)
     * @param  double $rrp_price (optional)
     * @param  double $l_cost (optional)
     * @param  double $s_cost (optional)
     * @param  int $decimal_places (optional)
     * @param  double $minimum_gp (optional)
     * @param  double $weight (optional)
     * @param  double $cubic (optional)
     * @param  bool $use_serial_no (optional)
     * @param  bool $back_orderable (optional)
     * @param  double $sales_man_cost (optional)
     * @param  double $secondary_cost (optional)
     * @param  string $bom_object (optional)
     * @param  bool $use_expiry_date (optional)
     * @param  bool $use_standard_cost (optional)
     * @param  double $standard_cost (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $sell_price_inc_tax (optional)
     * @param  string $style (optional)
     * @param  string $colour (optional)
     * @param  string $size (optional)
     * @param  int $part_encode_order (optional)
     * @param  string $part_no (optional)
     * @param  string $picture (optional)
     * @param  string $description (optional)
     * @param  string $unit_measure (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $aux1 (optional)
     * @param  string $aux2 (optional)
     * @param  string $aux3 (optional)
     * @param  string $aux4 (optional)
     * @param  string $aux5 (optional)
     * @param  string $gst_inwards_id (optional)
     * @param  string $gst_inwards_description (optional)
     * @param  double $gst_inwards_rate (optional)
     * @param  string $gst_outwards_id (optional)
     * @param  string $gst_outwards_description (optional)
     * @param  double $gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate (optional)
     * @param  string $matrix_description (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $regions (optional)
     * @param  string $debtor_prices (optional)
     * @param  string $debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children (optional)
     * @param  string $alternate_parents (optional)
     * @param  string $components (optional)
     * @param  string $warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $group_memberships (optional)
     * @param  string $other_descriptions (optional)
     * @param  string $order_levels (optional)
     * @param  string $budgets (optional)
     * @param  string $logical_orders (optional)
     * @param  string $default_bin_locations (optional)
     * @param  string $product_availabilities (optional)
     * @param  string $selling_prices (optional)
     * @param  string $up_sells (optional)
     * @param  string $attribute_groups (optional)
     * @param  string $unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPATCHRequestInventoryIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $last_saved_date_time = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryItem';
        $request = $this->inventoryPATCHRequestInventoryIDUpdateRequest($accept, $inventory_id, $jiwa_stateful, $physical_item, $ship_with_physical_item, $discountable, $last_saved_date_time, $direct_tax, $status, $default_price, $rrp_price, $l_cost, $s_cost, $decimal_places, $minimum_gp, $weight, $cubic, $use_serial_no, $back_orderable, $sales_man_cost, $secondary_cost, $bom_object, $use_expiry_date, $use_standard_cost, $standard_cost, $web_enabled, $sell_price_inc_tax, $style, $colour, $size, $part_encode_order, $part_no, $picture, $description, $unit_measure, $classification, $category1, $category2, $category3, $category4, $category5, $aux1, $aux2, $aux3, $aux4, $aux5, $gst_inwards_id, $gst_inwards_description, $gst_inwards_rate, $gst_outwards_id, $gst_outwards_description, $gst_outwards_rate, $gst_adjustments_inid, $gst_adjustments_in_description, $gst_adjustments_in_rate, $gst_adjustments_outid, $gst_adjustments_out_description, $gst_adjustments_out_rate, $matrix_description, $pricing_group_id, $pricing_group_description, $inventory_ledgers, $notes, $documents, $custom_field_values, $regions, $debtor_prices, $debtor_class_prices, $debtor_price_group_inventory_specific_prices, $alternate_children, $alternate_parents, $components, $warehouse_so_hs, $debtor_part_numbers, $group_memberships, $other_descriptions, $order_levels, $budgets, $logical_orders, $default_bin_locations, $product_availabilities, $selling_prices, $up_sells, $attribute_groups, $unit_of_measures, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPATCHRequestInventoryIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item (optional)
     * @param  bool $ship_with_physical_item (optional)
     * @param  bool $discountable (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  double $direct_tax (optional)
     * @param  string $status (optional)
     * @param  double $default_price (optional)
     * @param  double $rrp_price (optional)
     * @param  double $l_cost (optional)
     * @param  double $s_cost (optional)
     * @param  int $decimal_places (optional)
     * @param  double $minimum_gp (optional)
     * @param  double $weight (optional)
     * @param  double $cubic (optional)
     * @param  bool $use_serial_no (optional)
     * @param  bool $back_orderable (optional)
     * @param  double $sales_man_cost (optional)
     * @param  double $secondary_cost (optional)
     * @param  string $bom_object (optional)
     * @param  bool $use_expiry_date (optional)
     * @param  bool $use_standard_cost (optional)
     * @param  double $standard_cost (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $sell_price_inc_tax (optional)
     * @param  string $style (optional)
     * @param  string $colour (optional)
     * @param  string $size (optional)
     * @param  int $part_encode_order (optional)
     * @param  string $part_no (optional)
     * @param  string $picture (optional)
     * @param  string $description (optional)
     * @param  string $unit_measure (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $aux1 (optional)
     * @param  string $aux2 (optional)
     * @param  string $aux3 (optional)
     * @param  string $aux4 (optional)
     * @param  string $aux5 (optional)
     * @param  string $gst_inwards_id (optional)
     * @param  string $gst_inwards_description (optional)
     * @param  double $gst_inwards_rate (optional)
     * @param  string $gst_outwards_id (optional)
     * @param  string $gst_outwards_description (optional)
     * @param  double $gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate (optional)
     * @param  string $matrix_description (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $regions (optional)
     * @param  string $debtor_prices (optional)
     * @param  string $debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children (optional)
     * @param  string $alternate_parents (optional)
     * @param  string $components (optional)
     * @param  string $warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $group_memberships (optional)
     * @param  string $other_descriptions (optional)
     * @param  string $order_levels (optional)
     * @param  string $budgets (optional)
     * @param  string $logical_orders (optional)
     * @param  string $default_bin_locations (optional)
     * @param  string $product_availabilities (optional)
     * @param  string $selling_prices (optional)
     * @param  string $up_sells (optional)
     * @param  string $attribute_groups (optional)
     * @param  string $unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPATCHRequestInventoryIDUpdateRequest($accept, $inventory_id, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $last_saved_date_time = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryPATCHRequestInventoryIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryPATCHRequestInventoryIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($physical_item !== null) {
            $queryParams['PhysicalItem'] = ObjectSerializer::toQueryValue($physical_item);
        }
        // query params
        if ($ship_with_physical_item !== null) {
            $queryParams['ShipWithPhysicalItem'] = ObjectSerializer::toQueryValue($ship_with_physical_item);
        }
        // query params
        if ($discountable !== null) {
            $queryParams['Discountable'] = ObjectSerializer::toQueryValue($discountable);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($direct_tax !== null) {
            $queryParams['DirectTax'] = ObjectSerializer::toQueryValue($direct_tax);
        }
        // query params
        if ($status !== null) {
            $queryParams['Status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($default_price !== null) {
            $queryParams['DefaultPrice'] = ObjectSerializer::toQueryValue($default_price);
        }
        // query params
        if ($rrp_price !== null) {
            $queryParams['RRPPrice'] = ObjectSerializer::toQueryValue($rrp_price);
        }
        // query params
        if ($l_cost !== null) {
            $queryParams['LCost'] = ObjectSerializer::toQueryValue($l_cost);
        }
        // query params
        if ($s_cost !== null) {
            $queryParams['SCost'] = ObjectSerializer::toQueryValue($s_cost);
        }
        // query params
        if ($decimal_places !== null) {
            $queryParams['DecimalPlaces'] = ObjectSerializer::toQueryValue($decimal_places);
        }
        // query params
        if ($minimum_gp !== null) {
            $queryParams['MinimumGP'] = ObjectSerializer::toQueryValue($minimum_gp);
        }
        // query params
        if ($weight !== null) {
            $queryParams['Weight'] = ObjectSerializer::toQueryValue($weight);
        }
        // query params
        if ($cubic !== null) {
            $queryParams['Cubic'] = ObjectSerializer::toQueryValue($cubic);
        }
        // query params
        if ($use_serial_no !== null) {
            $queryParams['UseSerialNo'] = ObjectSerializer::toQueryValue($use_serial_no);
        }
        // query params
        if ($back_orderable !== null) {
            $queryParams['BackOrderable'] = ObjectSerializer::toQueryValue($back_orderable);
        }
        // query params
        if ($sales_man_cost !== null) {
            $queryParams['SalesManCost'] = ObjectSerializer::toQueryValue($sales_man_cost);
        }
        // query params
        if ($secondary_cost !== null) {
            $queryParams['SecondaryCost'] = ObjectSerializer::toQueryValue($secondary_cost);
        }
        // query params
        if ($bom_object !== null) {
            $queryParams['BOMObject'] = ObjectSerializer::toQueryValue($bom_object);
        }
        // query params
        if ($use_expiry_date !== null) {
            $queryParams['UseExpiryDate'] = ObjectSerializer::toQueryValue($use_expiry_date);
        }
        // query params
        if ($use_standard_cost !== null) {
            $queryParams['UseStandardCost'] = ObjectSerializer::toQueryValue($use_standard_cost);
        }
        // query params
        if ($standard_cost !== null) {
            $queryParams['StandardCost'] = ObjectSerializer::toQueryValue($standard_cost);
        }
        // query params
        if ($web_enabled !== null) {
            $queryParams['WebEnabled'] = ObjectSerializer::toQueryValue($web_enabled);
        }
        // query params
        if ($sell_price_inc_tax !== null) {
            $queryParams['SellPriceIncTax'] = ObjectSerializer::toQueryValue($sell_price_inc_tax);
        }
        // query params
        if ($style !== null) {
            $queryParams['Style'] = ObjectSerializer::toQueryValue($style);
        }
        // query params
        if ($colour !== null) {
            $queryParams['Colour'] = ObjectSerializer::toQueryValue($colour);
        }
        // query params
        if ($size !== null) {
            $queryParams['Size'] = ObjectSerializer::toQueryValue($size);
        }
        // query params
        if ($part_encode_order !== null) {
            $queryParams['PartEncodeOrder'] = ObjectSerializer::toQueryValue($part_encode_order);
        }
        // query params
        if ($part_no !== null) {
            $queryParams['PartNo'] = ObjectSerializer::toQueryValue($part_no);
        }
        // query params
        if ($picture !== null) {
            $queryParams['Picture'] = ObjectSerializer::toQueryValue($picture);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($unit_measure !== null) {
            $queryParams['UnitMeasure'] = ObjectSerializer::toQueryValue($unit_measure);
        }
        // query params
        if ($classification !== null) {
            $queryParams['Classification'] = ObjectSerializer::toQueryValue($classification);
        }
        // query params
        if ($category1 !== null) {
            $queryParams['Category1'] = ObjectSerializer::toQueryValue($category1);
        }
        // query params
        if ($category2 !== null) {
            $queryParams['Category2'] = ObjectSerializer::toQueryValue($category2);
        }
        // query params
        if ($category3 !== null) {
            $queryParams['Category3'] = ObjectSerializer::toQueryValue($category3);
        }
        // query params
        if ($category4 !== null) {
            $queryParams['Category4'] = ObjectSerializer::toQueryValue($category4);
        }
        // query params
        if ($category5 !== null) {
            $queryParams['Category5'] = ObjectSerializer::toQueryValue($category5);
        }
        // query params
        if ($aux1 !== null) {
            $queryParams['Aux1'] = ObjectSerializer::toQueryValue($aux1);
        }
        // query params
        if ($aux2 !== null) {
            $queryParams['Aux2'] = ObjectSerializer::toQueryValue($aux2);
        }
        // query params
        if ($aux3 !== null) {
            $queryParams['Aux3'] = ObjectSerializer::toQueryValue($aux3);
        }
        // query params
        if ($aux4 !== null) {
            $queryParams['Aux4'] = ObjectSerializer::toQueryValue($aux4);
        }
        // query params
        if ($aux5 !== null) {
            $queryParams['Aux5'] = ObjectSerializer::toQueryValue($aux5);
        }
        // query params
        if ($gst_inwards_id !== null) {
            $queryParams['GSTInwardsID'] = ObjectSerializer::toQueryValue($gst_inwards_id);
        }
        // query params
        if ($gst_inwards_description !== null) {
            $queryParams['GSTInwardsDescription'] = ObjectSerializer::toQueryValue($gst_inwards_description);
        }
        // query params
        if ($gst_inwards_rate !== null) {
            $queryParams['GSTInwardsRate'] = ObjectSerializer::toQueryValue($gst_inwards_rate);
        }
        // query params
        if ($gst_outwards_id !== null) {
            $queryParams['GSTOutwardsID'] = ObjectSerializer::toQueryValue($gst_outwards_id);
        }
        // query params
        if ($gst_outwards_description !== null) {
            $queryParams['GSTOutwardsDescription'] = ObjectSerializer::toQueryValue($gst_outwards_description);
        }
        // query params
        if ($gst_outwards_rate !== null) {
            $queryParams['GSTOutwardsRate'] = ObjectSerializer::toQueryValue($gst_outwards_rate);
        }
        // query params
        if ($gst_adjustments_inid !== null) {
            $queryParams['GSTAdjustmentsINID'] = ObjectSerializer::toQueryValue($gst_adjustments_inid);
        }
        // query params
        if ($gst_adjustments_in_description !== null) {
            $queryParams['GSTAdjustmentsINDescription'] = ObjectSerializer::toQueryValue($gst_adjustments_in_description);
        }
        // query params
        if ($gst_adjustments_in_rate !== null) {
            $queryParams['GSTAdjustmentsINRate'] = ObjectSerializer::toQueryValue($gst_adjustments_in_rate);
        }
        // query params
        if ($gst_adjustments_outid !== null) {
            $queryParams['GSTAdjustmentsOUTID'] = ObjectSerializer::toQueryValue($gst_adjustments_outid);
        }
        // query params
        if ($gst_adjustments_out_description !== null) {
            $queryParams['GSTAdjustmentsOUTDescription'] = ObjectSerializer::toQueryValue($gst_adjustments_out_description);
        }
        // query params
        if ($gst_adjustments_out_rate !== null) {
            $queryParams['GSTAdjustmentsOUTRate'] = ObjectSerializer::toQueryValue($gst_adjustments_out_rate);
        }
        // query params
        if ($matrix_description !== null) {
            $queryParams['MatrixDescription'] = ObjectSerializer::toQueryValue($matrix_description);
        }
        // query params
        if ($pricing_group_id !== null) {
            $queryParams['PricingGroupID'] = ObjectSerializer::toQueryValue($pricing_group_id);
        }
        // query params
        if ($pricing_group_description !== null) {
            $queryParams['PricingGroupDescription'] = ObjectSerializer::toQueryValue($pricing_group_description);
        }
        // query params
        if ($inventory_ledgers !== null) {
            $queryParams['InventoryLedgers'] = ObjectSerializer::toQueryValue($inventory_ledgers);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($documents !== null) {
            $queryParams['Documents'] = ObjectSerializer::toQueryValue($documents);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($regions !== null) {
            $queryParams['Regions'] = ObjectSerializer::toQueryValue($regions);
        }
        // query params
        if ($debtor_prices !== null) {
            $queryParams['DebtorPrices'] = ObjectSerializer::toQueryValue($debtor_prices);
        }
        // query params
        if ($debtor_class_prices !== null) {
            $queryParams['DebtorClassPrices'] = ObjectSerializer::toQueryValue($debtor_class_prices);
        }
        // query params
        if ($debtor_price_group_inventory_specific_prices !== null) {
            $queryParams['DebtorPriceGroupInventorySpecificPrices'] = ObjectSerializer::toQueryValue($debtor_price_group_inventory_specific_prices);
        }
        // query params
        if ($alternate_children !== null) {
            $queryParams['AlternateChildren'] = ObjectSerializer::toQueryValue($alternate_children);
        }
        // query params
        if ($alternate_parents !== null) {
            $queryParams['AlternateParents'] = ObjectSerializer::toQueryValue($alternate_parents);
        }
        // query params
        if ($components !== null) {
            $queryParams['Components'] = ObjectSerializer::toQueryValue($components);
        }
        // query params
        if ($warehouse_so_hs !== null) {
            $queryParams['WarehouseSOHs'] = ObjectSerializer::toQueryValue($warehouse_so_hs);
        }
        // query params
        if ($debtor_part_numbers !== null) {
            $queryParams['DebtorPartNumbers'] = ObjectSerializer::toQueryValue($debtor_part_numbers);
        }
        // query params
        if ($group_memberships !== null) {
            $queryParams['GroupMemberships'] = ObjectSerializer::toQueryValue($group_memberships);
        }
        // query params
        if ($other_descriptions !== null) {
            $queryParams['OtherDescriptions'] = ObjectSerializer::toQueryValue($other_descriptions);
        }
        // query params
        if ($order_levels !== null) {
            $queryParams['OrderLevels'] = ObjectSerializer::toQueryValue($order_levels);
        }
        // query params
        if ($budgets !== null) {
            $queryParams['Budgets'] = ObjectSerializer::toQueryValue($budgets);
        }
        // query params
        if ($logical_orders !== null) {
            $queryParams['LogicalOrders'] = ObjectSerializer::toQueryValue($logical_orders);
        }
        // query params
        if ($default_bin_locations !== null) {
            $queryParams['DefaultBinLocations'] = ObjectSerializer::toQueryValue($default_bin_locations);
        }
        // query params
        if ($product_availabilities !== null) {
            $queryParams['ProductAvailabilities'] = ObjectSerializer::toQueryValue($product_availabilities);
        }
        // query params
        if ($selling_prices !== null) {
            $queryParams['SellingPrices'] = ObjectSerializer::toQueryValue($selling_prices);
        }
        // query params
        if ($up_sells !== null) {
            $queryParams['UpSells'] = ObjectSerializer::toQueryValue($up_sells);
        }
        // query params
        if ($attribute_groups !== null) {
            $queryParams['AttributeGroups'] = ObjectSerializer::toQueryValue($attribute_groups);
        }
        // query params
        if ($unit_of_measures !== null) {
            $queryParams['UnitOfMeasures'] = ObjectSerializer::toQueryValue($unit_of_measures);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPOSTRequestPost
     *
     * Creates an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item physical_item (optional)
     * @param  bool $ship_with_physical_item ship_with_physical_item (optional)
     * @param  bool $discountable discountable (optional)
     * @param  double $direct_tax direct_tax (optional)
     * @param  string $status status (optional)
     * @param  double $default_price default_price (optional)
     * @param  double $rrp_price rrp_price (optional)
     * @param  double $l_cost l_cost (optional)
     * @param  double $s_cost s_cost (optional)
     * @param  int $decimal_places decimal_places (optional)
     * @param  double $minimum_gp minimum_gp (optional)
     * @param  double $weight weight (optional)
     * @param  double $cubic cubic (optional)
     * @param  bool $use_serial_no use_serial_no (optional)
     * @param  bool $back_orderable back_orderable (optional)
     * @param  double $sales_man_cost sales_man_cost (optional)
     * @param  double $secondary_cost secondary_cost (optional)
     * @param  string $bom_object bom_object (optional)
     * @param  bool $use_expiry_date use_expiry_date (optional)
     * @param  bool $use_standard_cost use_standard_cost (optional)
     * @param  double $standard_cost standard_cost (optional)
     * @param  bool $web_enabled web_enabled (optional)
     * @param  bool $sell_price_inc_tax sell_price_inc_tax (optional)
     * @param  string $style style (optional)
     * @param  string $colour colour (optional)
     * @param  string $size size (optional)
     * @param  int $part_encode_order part_encode_order (optional)
     * @param  string $part_no part_no (optional)
     * @param  string $picture picture (optional)
     * @param  string $description description (optional)
     * @param  string $unit_measure unit_measure (optional)
     * @param  string $classification classification (optional)
     * @param  string $category1 category1 (optional)
     * @param  string $category2 category2 (optional)
     * @param  string $category3 category3 (optional)
     * @param  string $category4 category4 (optional)
     * @param  string $category5 category5 (optional)
     * @param  string $aux1 aux1 (optional)
     * @param  string $aux2 aux2 (optional)
     * @param  string $aux3 aux3 (optional)
     * @param  string $aux4 aux4 (optional)
     * @param  string $aux5 aux5 (optional)
     * @param  string $gst_inwards_id gst_inwards_id (optional)
     * @param  string $gst_inwards_description gst_inwards_description (optional)
     * @param  double $gst_inwards_rate gst_inwards_rate (optional)
     * @param  string $gst_outwards_id gst_outwards_id (optional)
     * @param  string $gst_outwards_description gst_outwards_description (optional)
     * @param  double $gst_outwards_rate gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate gst_adjustments_out_rate (optional)
     * @param  string $matrix_description matrix_description (optional)
     * @param  string $pricing_group_id pricing_group_id (optional)
     * @param  string $pricing_group_description pricing_group_description (optional)
     * @param  string $inventory_ledgers inventory_ledgers (optional)
     * @param  string $notes notes (optional)
     * @param  string $documents documents (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $regions regions (optional)
     * @param  string $debtor_prices debtor_prices (optional)
     * @param  string $debtor_class_prices debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children alternate_children (optional)
     * @param  string $alternate_parents alternate_parents (optional)
     * @param  string $components components (optional)
     * @param  string $warehouse_so_hs warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers debtor_part_numbers (optional)
     * @param  string $group_memberships group_memberships (optional)
     * @param  string $other_descriptions other_descriptions (optional)
     * @param  string $order_levels order_levels (optional)
     * @param  string $budgets budgets (optional)
     * @param  string $logical_orders logical_orders (optional)
     * @param  string $default_bin_locations default_bin_locations (optional)
     * @param  string $product_availabilities product_availabilities (optional)
     * @param  string $selling_prices selling_prices (optional)
     * @param  string $up_sells up_sells (optional)
     * @param  string $attribute_groups attribute_groups (optional)
     * @param  string $unit_of_measures unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryItem
     */
    public function inventoryPOSTRequestPost($accept, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        list($response) = $this->inventoryPOSTRequestPostWithHttpInfo($accept, $jiwa_stateful, $physical_item, $ship_with_physical_item, $discountable, $direct_tax, $status, $default_price, $rrp_price, $l_cost, $s_cost, $decimal_places, $minimum_gp, $weight, $cubic, $use_serial_no, $back_orderable, $sales_man_cost, $secondary_cost, $bom_object, $use_expiry_date, $use_standard_cost, $standard_cost, $web_enabled, $sell_price_inc_tax, $style, $colour, $size, $part_encode_order, $part_no, $picture, $description, $unit_measure, $classification, $category1, $category2, $category3, $category4, $category5, $aux1, $aux2, $aux3, $aux4, $aux5, $gst_inwards_id, $gst_inwards_description, $gst_inwards_rate, $gst_outwards_id, $gst_outwards_description, $gst_outwards_rate, $gst_adjustments_inid, $gst_adjustments_in_description, $gst_adjustments_in_rate, $gst_adjustments_outid, $gst_adjustments_out_description, $gst_adjustments_out_rate, $matrix_description, $pricing_group_id, $pricing_group_description, $inventory_ledgers, $notes, $documents, $custom_field_values, $regions, $debtor_prices, $debtor_class_prices, $debtor_price_group_inventory_specific_prices, $alternate_children, $alternate_parents, $components, $warehouse_so_hs, $debtor_part_numbers, $group_memberships, $other_descriptions, $order_levels, $budgets, $logical_orders, $default_bin_locations, $product_availabilities, $selling_prices, $up_sells, $attribute_groups, $unit_of_measures, $body);
        return $response;
    }

    /**
     * Operation inventoryPOSTRequestPostWithHttpInfo
     *
     * Creates an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item (optional)
     * @param  bool $ship_with_physical_item (optional)
     * @param  bool $discountable (optional)
     * @param  double $direct_tax (optional)
     * @param  string $status (optional)
     * @param  double $default_price (optional)
     * @param  double $rrp_price (optional)
     * @param  double $l_cost (optional)
     * @param  double $s_cost (optional)
     * @param  int $decimal_places (optional)
     * @param  double $minimum_gp (optional)
     * @param  double $weight (optional)
     * @param  double $cubic (optional)
     * @param  bool $use_serial_no (optional)
     * @param  bool $back_orderable (optional)
     * @param  double $sales_man_cost (optional)
     * @param  double $secondary_cost (optional)
     * @param  string $bom_object (optional)
     * @param  bool $use_expiry_date (optional)
     * @param  bool $use_standard_cost (optional)
     * @param  double $standard_cost (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $sell_price_inc_tax (optional)
     * @param  string $style (optional)
     * @param  string $colour (optional)
     * @param  string $size (optional)
     * @param  int $part_encode_order (optional)
     * @param  string $part_no (optional)
     * @param  string $picture (optional)
     * @param  string $description (optional)
     * @param  string $unit_measure (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $aux1 (optional)
     * @param  string $aux2 (optional)
     * @param  string $aux3 (optional)
     * @param  string $aux4 (optional)
     * @param  string $aux5 (optional)
     * @param  string $gst_inwards_id (optional)
     * @param  string $gst_inwards_description (optional)
     * @param  double $gst_inwards_rate (optional)
     * @param  string $gst_outwards_id (optional)
     * @param  string $gst_outwards_description (optional)
     * @param  double $gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate (optional)
     * @param  string $matrix_description (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $regions (optional)
     * @param  string $debtor_prices (optional)
     * @param  string $debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children (optional)
     * @param  string $alternate_parents (optional)
     * @param  string $components (optional)
     * @param  string $warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $group_memberships (optional)
     * @param  string $other_descriptions (optional)
     * @param  string $order_levels (optional)
     * @param  string $budgets (optional)
     * @param  string $logical_orders (optional)
     * @param  string $default_bin_locations (optional)
     * @param  string $product_availabilities (optional)
     * @param  string $selling_prices (optional)
     * @param  string $up_sells (optional)
     * @param  string $attribute_groups (optional)
     * @param  string $unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPOSTRequestPostWithHttpInfo($accept, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryItem';
        $request = $this->inventoryPOSTRequestPostRequest($accept, $jiwa_stateful, $physical_item, $ship_with_physical_item, $discountable, $direct_tax, $status, $default_price, $rrp_price, $l_cost, $s_cost, $decimal_places, $minimum_gp, $weight, $cubic, $use_serial_no, $back_orderable, $sales_man_cost, $secondary_cost, $bom_object, $use_expiry_date, $use_standard_cost, $standard_cost, $web_enabled, $sell_price_inc_tax, $style, $colour, $size, $part_encode_order, $part_no, $picture, $description, $unit_measure, $classification, $category1, $category2, $category3, $category4, $category5, $aux1, $aux2, $aux3, $aux4, $aux5, $gst_inwards_id, $gst_inwards_description, $gst_inwards_rate, $gst_outwards_id, $gst_outwards_description, $gst_outwards_rate, $gst_adjustments_inid, $gst_adjustments_in_description, $gst_adjustments_in_rate, $gst_adjustments_outid, $gst_adjustments_out_description, $gst_adjustments_out_rate, $matrix_description, $pricing_group_id, $pricing_group_description, $inventory_ledgers, $notes, $documents, $custom_field_values, $regions, $debtor_prices, $debtor_class_prices, $debtor_price_group_inventory_specific_prices, $alternate_children, $alternate_parents, $components, $warehouse_so_hs, $debtor_part_numbers, $group_memberships, $other_descriptions, $order_levels, $budgets, $logical_orders, $default_bin_locations, $product_availabilities, $selling_prices, $up_sells, $attribute_groups, $unit_of_measures, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPOSTRequestPostAsync
     *
     * Creates an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item (optional)
     * @param  bool $ship_with_physical_item (optional)
     * @param  bool $discountable (optional)
     * @param  double $direct_tax (optional)
     * @param  string $status (optional)
     * @param  double $default_price (optional)
     * @param  double $rrp_price (optional)
     * @param  double $l_cost (optional)
     * @param  double $s_cost (optional)
     * @param  int $decimal_places (optional)
     * @param  double $minimum_gp (optional)
     * @param  double $weight (optional)
     * @param  double $cubic (optional)
     * @param  bool $use_serial_no (optional)
     * @param  bool $back_orderable (optional)
     * @param  double $sales_man_cost (optional)
     * @param  double $secondary_cost (optional)
     * @param  string $bom_object (optional)
     * @param  bool $use_expiry_date (optional)
     * @param  bool $use_standard_cost (optional)
     * @param  double $standard_cost (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $sell_price_inc_tax (optional)
     * @param  string $style (optional)
     * @param  string $colour (optional)
     * @param  string $size (optional)
     * @param  int $part_encode_order (optional)
     * @param  string $part_no (optional)
     * @param  string $picture (optional)
     * @param  string $description (optional)
     * @param  string $unit_measure (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $aux1 (optional)
     * @param  string $aux2 (optional)
     * @param  string $aux3 (optional)
     * @param  string $aux4 (optional)
     * @param  string $aux5 (optional)
     * @param  string $gst_inwards_id (optional)
     * @param  string $gst_inwards_description (optional)
     * @param  double $gst_inwards_rate (optional)
     * @param  string $gst_outwards_id (optional)
     * @param  string $gst_outwards_description (optional)
     * @param  double $gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate (optional)
     * @param  string $matrix_description (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $regions (optional)
     * @param  string $debtor_prices (optional)
     * @param  string $debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children (optional)
     * @param  string $alternate_parents (optional)
     * @param  string $components (optional)
     * @param  string $warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $group_memberships (optional)
     * @param  string $other_descriptions (optional)
     * @param  string $order_levels (optional)
     * @param  string $budgets (optional)
     * @param  string $logical_orders (optional)
     * @param  string $default_bin_locations (optional)
     * @param  string $product_availabilities (optional)
     * @param  string $selling_prices (optional)
     * @param  string $up_sells (optional)
     * @param  string $attribute_groups (optional)
     * @param  string $unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPOSTRequestPostAsync($accept, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        return $this->inventoryPOSTRequestPostAsyncWithHttpInfo($accept, $jiwa_stateful, $physical_item, $ship_with_physical_item, $discountable, $direct_tax, $status, $default_price, $rrp_price, $l_cost, $s_cost, $decimal_places, $minimum_gp, $weight, $cubic, $use_serial_no, $back_orderable, $sales_man_cost, $secondary_cost, $bom_object, $use_expiry_date, $use_standard_cost, $standard_cost, $web_enabled, $sell_price_inc_tax, $style, $colour, $size, $part_encode_order, $part_no, $picture, $description, $unit_measure, $classification, $category1, $category2, $category3, $category4, $category5, $aux1, $aux2, $aux3, $aux4, $aux5, $gst_inwards_id, $gst_inwards_description, $gst_inwards_rate, $gst_outwards_id, $gst_outwards_description, $gst_outwards_rate, $gst_adjustments_inid, $gst_adjustments_in_description, $gst_adjustments_in_rate, $gst_adjustments_outid, $gst_adjustments_out_description, $gst_adjustments_out_rate, $matrix_description, $pricing_group_id, $pricing_group_description, $inventory_ledgers, $notes, $documents, $custom_field_values, $regions, $debtor_prices, $debtor_class_prices, $debtor_price_group_inventory_specific_prices, $alternate_children, $alternate_parents, $components, $warehouse_so_hs, $debtor_part_numbers, $group_memberships, $other_descriptions, $order_levels, $budgets, $logical_orders, $default_bin_locations, $product_availabilities, $selling_prices, $up_sells, $attribute_groups, $unit_of_measures, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPOSTRequestPostAsyncWithHttpInfo
     *
     * Creates an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item (optional)
     * @param  bool $ship_with_physical_item (optional)
     * @param  bool $discountable (optional)
     * @param  double $direct_tax (optional)
     * @param  string $status (optional)
     * @param  double $default_price (optional)
     * @param  double $rrp_price (optional)
     * @param  double $l_cost (optional)
     * @param  double $s_cost (optional)
     * @param  int $decimal_places (optional)
     * @param  double $minimum_gp (optional)
     * @param  double $weight (optional)
     * @param  double $cubic (optional)
     * @param  bool $use_serial_no (optional)
     * @param  bool $back_orderable (optional)
     * @param  double $sales_man_cost (optional)
     * @param  double $secondary_cost (optional)
     * @param  string $bom_object (optional)
     * @param  bool $use_expiry_date (optional)
     * @param  bool $use_standard_cost (optional)
     * @param  double $standard_cost (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $sell_price_inc_tax (optional)
     * @param  string $style (optional)
     * @param  string $colour (optional)
     * @param  string $size (optional)
     * @param  int $part_encode_order (optional)
     * @param  string $part_no (optional)
     * @param  string $picture (optional)
     * @param  string $description (optional)
     * @param  string $unit_measure (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $aux1 (optional)
     * @param  string $aux2 (optional)
     * @param  string $aux3 (optional)
     * @param  string $aux4 (optional)
     * @param  string $aux5 (optional)
     * @param  string $gst_inwards_id (optional)
     * @param  string $gst_inwards_description (optional)
     * @param  double $gst_inwards_rate (optional)
     * @param  string $gst_outwards_id (optional)
     * @param  string $gst_outwards_description (optional)
     * @param  double $gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate (optional)
     * @param  string $matrix_description (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $regions (optional)
     * @param  string $debtor_prices (optional)
     * @param  string $debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children (optional)
     * @param  string $alternate_parents (optional)
     * @param  string $components (optional)
     * @param  string $warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $group_memberships (optional)
     * @param  string $other_descriptions (optional)
     * @param  string $order_levels (optional)
     * @param  string $budgets (optional)
     * @param  string $logical_orders (optional)
     * @param  string $default_bin_locations (optional)
     * @param  string $product_availabilities (optional)
     * @param  string $selling_prices (optional)
     * @param  string $up_sells (optional)
     * @param  string $attribute_groups (optional)
     * @param  string $unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPOSTRequestPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryItem';
        $request = $this->inventoryPOSTRequestPostRequest($accept, $jiwa_stateful, $physical_item, $ship_with_physical_item, $discountable, $direct_tax, $status, $default_price, $rrp_price, $l_cost, $s_cost, $decimal_places, $minimum_gp, $weight, $cubic, $use_serial_no, $back_orderable, $sales_man_cost, $secondary_cost, $bom_object, $use_expiry_date, $use_standard_cost, $standard_cost, $web_enabled, $sell_price_inc_tax, $style, $colour, $size, $part_encode_order, $part_no, $picture, $description, $unit_measure, $classification, $category1, $category2, $category3, $category4, $category5, $aux1, $aux2, $aux3, $aux4, $aux5, $gst_inwards_id, $gst_inwards_description, $gst_inwards_rate, $gst_outwards_id, $gst_outwards_description, $gst_outwards_rate, $gst_adjustments_inid, $gst_adjustments_in_description, $gst_adjustments_in_rate, $gst_adjustments_outid, $gst_adjustments_out_description, $gst_adjustments_out_rate, $matrix_description, $pricing_group_id, $pricing_group_description, $inventory_ledgers, $notes, $documents, $custom_field_values, $regions, $debtor_prices, $debtor_class_prices, $debtor_price_group_inventory_specific_prices, $alternate_children, $alternate_parents, $components, $warehouse_so_hs, $debtor_part_numbers, $group_memberships, $other_descriptions, $order_levels, $budgets, $logical_orders, $default_bin_locations, $product_availabilities, $selling_prices, $up_sells, $attribute_groups, $unit_of_measures, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPOSTRequestPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $physical_item (optional)
     * @param  bool $ship_with_physical_item (optional)
     * @param  bool $discountable (optional)
     * @param  double $direct_tax (optional)
     * @param  string $status (optional)
     * @param  double $default_price (optional)
     * @param  double $rrp_price (optional)
     * @param  double $l_cost (optional)
     * @param  double $s_cost (optional)
     * @param  int $decimal_places (optional)
     * @param  double $minimum_gp (optional)
     * @param  double $weight (optional)
     * @param  double $cubic (optional)
     * @param  bool $use_serial_no (optional)
     * @param  bool $back_orderable (optional)
     * @param  double $sales_man_cost (optional)
     * @param  double $secondary_cost (optional)
     * @param  string $bom_object (optional)
     * @param  bool $use_expiry_date (optional)
     * @param  bool $use_standard_cost (optional)
     * @param  double $standard_cost (optional)
     * @param  bool $web_enabled (optional)
     * @param  bool $sell_price_inc_tax (optional)
     * @param  string $style (optional)
     * @param  string $colour (optional)
     * @param  string $size (optional)
     * @param  int $part_encode_order (optional)
     * @param  string $part_no (optional)
     * @param  string $picture (optional)
     * @param  string $description (optional)
     * @param  string $unit_measure (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $aux1 (optional)
     * @param  string $aux2 (optional)
     * @param  string $aux3 (optional)
     * @param  string $aux4 (optional)
     * @param  string $aux5 (optional)
     * @param  string $gst_inwards_id (optional)
     * @param  string $gst_inwards_description (optional)
     * @param  double $gst_inwards_rate (optional)
     * @param  string $gst_outwards_id (optional)
     * @param  string $gst_outwards_description (optional)
     * @param  double $gst_outwards_rate (optional)
     * @param  string $gst_adjustments_inid (optional)
     * @param  string $gst_adjustments_in_description (optional)
     * @param  double $gst_adjustments_in_rate (optional)
     * @param  string $gst_adjustments_outid (optional)
     * @param  string $gst_adjustments_out_description (optional)
     * @param  double $gst_adjustments_out_rate (optional)
     * @param  string $matrix_description (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $inventory_ledgers (optional)
     * @param  string $notes (optional)
     * @param  string $documents (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $regions (optional)
     * @param  string $debtor_prices (optional)
     * @param  string $debtor_class_prices (optional)
     * @param  string $debtor_price_group_inventory_specific_prices (optional)
     * @param  string $alternate_children (optional)
     * @param  string $alternate_parents (optional)
     * @param  string $components (optional)
     * @param  string $warehouse_so_hs (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $group_memberships (optional)
     * @param  string $other_descriptions (optional)
     * @param  string $order_levels (optional)
     * @param  string $budgets (optional)
     * @param  string $logical_orders (optional)
     * @param  string $default_bin_locations (optional)
     * @param  string $product_availabilities (optional)
     * @param  string $selling_prices (optional)
     * @param  string $up_sells (optional)
     * @param  string $attribute_groups (optional)
     * @param  string $unit_of_measures (optional)
     * @param  \Jiwa\JiwaModel\InventoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPOSTRequestPostRequest($accept, $jiwa_stateful = null, $physical_item = null, $ship_with_physical_item = null, $discountable = null, $direct_tax = null, $status = null, $default_price = null, $rrp_price = null, $l_cost = null, $s_cost = null, $decimal_places = null, $minimum_gp = null, $weight = null, $cubic = null, $use_serial_no = null, $back_orderable = null, $sales_man_cost = null, $secondary_cost = null, $bom_object = null, $use_expiry_date = null, $use_standard_cost = null, $standard_cost = null, $web_enabled = null, $sell_price_inc_tax = null, $style = null, $colour = null, $size = null, $part_encode_order = null, $part_no = null, $picture = null, $description = null, $unit_measure = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $aux1 = null, $aux2 = null, $aux3 = null, $aux4 = null, $aux5 = null, $gst_inwards_id = null, $gst_inwards_description = null, $gst_inwards_rate = null, $gst_outwards_id = null, $gst_outwards_description = null, $gst_outwards_rate = null, $gst_adjustments_inid = null, $gst_adjustments_in_description = null, $gst_adjustments_in_rate = null, $gst_adjustments_outid = null, $gst_adjustments_out_description = null, $gst_adjustments_out_rate = null, $matrix_description = null, $pricing_group_id = null, $pricing_group_description = null, $inventory_ledgers = null, $notes = null, $documents = null, $custom_field_values = null, $regions = null, $debtor_prices = null, $debtor_class_prices = null, $debtor_price_group_inventory_specific_prices = null, $alternate_children = null, $alternate_parents = null, $components = null, $warehouse_so_hs = null, $debtor_part_numbers = null, $group_memberships = null, $other_descriptions = null, $order_levels = null, $budgets = null, $logical_orders = null, $default_bin_locations = null, $product_availabilities = null, $selling_prices = null, $up_sells = null, $attribute_groups = null, $unit_of_measures = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryPOSTRequestPost'
            );
        }

        $resourcePath = '/Inventory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($physical_item !== null) {
            $queryParams['PhysicalItem'] = ObjectSerializer::toQueryValue($physical_item);
        }
        // query params
        if ($ship_with_physical_item !== null) {
            $queryParams['ShipWithPhysicalItem'] = ObjectSerializer::toQueryValue($ship_with_physical_item);
        }
        // query params
        if ($discountable !== null) {
            $queryParams['Discountable'] = ObjectSerializer::toQueryValue($discountable);
        }
        // query params
        if ($direct_tax !== null) {
            $queryParams['DirectTax'] = ObjectSerializer::toQueryValue($direct_tax);
        }
        // query params
        if ($status !== null) {
            $queryParams['Status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($default_price !== null) {
            $queryParams['DefaultPrice'] = ObjectSerializer::toQueryValue($default_price);
        }
        // query params
        if ($rrp_price !== null) {
            $queryParams['RRPPrice'] = ObjectSerializer::toQueryValue($rrp_price);
        }
        // query params
        if ($l_cost !== null) {
            $queryParams['LCost'] = ObjectSerializer::toQueryValue($l_cost);
        }
        // query params
        if ($s_cost !== null) {
            $queryParams['SCost'] = ObjectSerializer::toQueryValue($s_cost);
        }
        // query params
        if ($decimal_places !== null) {
            $queryParams['DecimalPlaces'] = ObjectSerializer::toQueryValue($decimal_places);
        }
        // query params
        if ($minimum_gp !== null) {
            $queryParams['MinimumGP'] = ObjectSerializer::toQueryValue($minimum_gp);
        }
        // query params
        if ($weight !== null) {
            $queryParams['Weight'] = ObjectSerializer::toQueryValue($weight);
        }
        // query params
        if ($cubic !== null) {
            $queryParams['Cubic'] = ObjectSerializer::toQueryValue($cubic);
        }
        // query params
        if ($use_serial_no !== null) {
            $queryParams['UseSerialNo'] = ObjectSerializer::toQueryValue($use_serial_no);
        }
        // query params
        if ($back_orderable !== null) {
            $queryParams['BackOrderable'] = ObjectSerializer::toQueryValue($back_orderable);
        }
        // query params
        if ($sales_man_cost !== null) {
            $queryParams['SalesManCost'] = ObjectSerializer::toQueryValue($sales_man_cost);
        }
        // query params
        if ($secondary_cost !== null) {
            $queryParams['SecondaryCost'] = ObjectSerializer::toQueryValue($secondary_cost);
        }
        // query params
        if ($bom_object !== null) {
            $queryParams['BOMObject'] = ObjectSerializer::toQueryValue($bom_object);
        }
        // query params
        if ($use_expiry_date !== null) {
            $queryParams['UseExpiryDate'] = ObjectSerializer::toQueryValue($use_expiry_date);
        }
        // query params
        if ($use_standard_cost !== null) {
            $queryParams['UseStandardCost'] = ObjectSerializer::toQueryValue($use_standard_cost);
        }
        // query params
        if ($standard_cost !== null) {
            $queryParams['StandardCost'] = ObjectSerializer::toQueryValue($standard_cost);
        }
        // query params
        if ($web_enabled !== null) {
            $queryParams['WebEnabled'] = ObjectSerializer::toQueryValue($web_enabled);
        }
        // query params
        if ($sell_price_inc_tax !== null) {
            $queryParams['SellPriceIncTax'] = ObjectSerializer::toQueryValue($sell_price_inc_tax);
        }
        // query params
        if ($style !== null) {
            $queryParams['Style'] = ObjectSerializer::toQueryValue($style);
        }
        // query params
        if ($colour !== null) {
            $queryParams['Colour'] = ObjectSerializer::toQueryValue($colour);
        }
        // query params
        if ($size !== null) {
            $queryParams['Size'] = ObjectSerializer::toQueryValue($size);
        }
        // query params
        if ($part_encode_order !== null) {
            $queryParams['PartEncodeOrder'] = ObjectSerializer::toQueryValue($part_encode_order);
        }
        // query params
        if ($part_no !== null) {
            $queryParams['PartNo'] = ObjectSerializer::toQueryValue($part_no);
        }
        // query params
        if ($picture !== null) {
            $queryParams['Picture'] = ObjectSerializer::toQueryValue($picture);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($unit_measure !== null) {
            $queryParams['UnitMeasure'] = ObjectSerializer::toQueryValue($unit_measure);
        }
        // query params
        if ($classification !== null) {
            $queryParams['Classification'] = ObjectSerializer::toQueryValue($classification);
        }
        // query params
        if ($category1 !== null) {
            $queryParams['Category1'] = ObjectSerializer::toQueryValue($category1);
        }
        // query params
        if ($category2 !== null) {
            $queryParams['Category2'] = ObjectSerializer::toQueryValue($category2);
        }
        // query params
        if ($category3 !== null) {
            $queryParams['Category3'] = ObjectSerializer::toQueryValue($category3);
        }
        // query params
        if ($category4 !== null) {
            $queryParams['Category4'] = ObjectSerializer::toQueryValue($category4);
        }
        // query params
        if ($category5 !== null) {
            $queryParams['Category5'] = ObjectSerializer::toQueryValue($category5);
        }
        // query params
        if ($aux1 !== null) {
            $queryParams['Aux1'] = ObjectSerializer::toQueryValue($aux1);
        }
        // query params
        if ($aux2 !== null) {
            $queryParams['Aux2'] = ObjectSerializer::toQueryValue($aux2);
        }
        // query params
        if ($aux3 !== null) {
            $queryParams['Aux3'] = ObjectSerializer::toQueryValue($aux3);
        }
        // query params
        if ($aux4 !== null) {
            $queryParams['Aux4'] = ObjectSerializer::toQueryValue($aux4);
        }
        // query params
        if ($aux5 !== null) {
            $queryParams['Aux5'] = ObjectSerializer::toQueryValue($aux5);
        }
        // query params
        if ($gst_inwards_id !== null) {
            $queryParams['GSTInwardsID'] = ObjectSerializer::toQueryValue($gst_inwards_id);
        }
        // query params
        if ($gst_inwards_description !== null) {
            $queryParams['GSTInwardsDescription'] = ObjectSerializer::toQueryValue($gst_inwards_description);
        }
        // query params
        if ($gst_inwards_rate !== null) {
            $queryParams['GSTInwardsRate'] = ObjectSerializer::toQueryValue($gst_inwards_rate);
        }
        // query params
        if ($gst_outwards_id !== null) {
            $queryParams['GSTOutwardsID'] = ObjectSerializer::toQueryValue($gst_outwards_id);
        }
        // query params
        if ($gst_outwards_description !== null) {
            $queryParams['GSTOutwardsDescription'] = ObjectSerializer::toQueryValue($gst_outwards_description);
        }
        // query params
        if ($gst_outwards_rate !== null) {
            $queryParams['GSTOutwardsRate'] = ObjectSerializer::toQueryValue($gst_outwards_rate);
        }
        // query params
        if ($gst_adjustments_inid !== null) {
            $queryParams['GSTAdjustmentsINID'] = ObjectSerializer::toQueryValue($gst_adjustments_inid);
        }
        // query params
        if ($gst_adjustments_in_description !== null) {
            $queryParams['GSTAdjustmentsINDescription'] = ObjectSerializer::toQueryValue($gst_adjustments_in_description);
        }
        // query params
        if ($gst_adjustments_in_rate !== null) {
            $queryParams['GSTAdjustmentsINRate'] = ObjectSerializer::toQueryValue($gst_adjustments_in_rate);
        }
        // query params
        if ($gst_adjustments_outid !== null) {
            $queryParams['GSTAdjustmentsOUTID'] = ObjectSerializer::toQueryValue($gst_adjustments_outid);
        }
        // query params
        if ($gst_adjustments_out_description !== null) {
            $queryParams['GSTAdjustmentsOUTDescription'] = ObjectSerializer::toQueryValue($gst_adjustments_out_description);
        }
        // query params
        if ($gst_adjustments_out_rate !== null) {
            $queryParams['GSTAdjustmentsOUTRate'] = ObjectSerializer::toQueryValue($gst_adjustments_out_rate);
        }
        // query params
        if ($matrix_description !== null) {
            $queryParams['MatrixDescription'] = ObjectSerializer::toQueryValue($matrix_description);
        }
        // query params
        if ($pricing_group_id !== null) {
            $queryParams['PricingGroupID'] = ObjectSerializer::toQueryValue($pricing_group_id);
        }
        // query params
        if ($pricing_group_description !== null) {
            $queryParams['PricingGroupDescription'] = ObjectSerializer::toQueryValue($pricing_group_description);
        }
        // query params
        if ($inventory_ledgers !== null) {
            $queryParams['InventoryLedgers'] = ObjectSerializer::toQueryValue($inventory_ledgers);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($documents !== null) {
            $queryParams['Documents'] = ObjectSerializer::toQueryValue($documents);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($regions !== null) {
            $queryParams['Regions'] = ObjectSerializer::toQueryValue($regions);
        }
        // query params
        if ($debtor_prices !== null) {
            $queryParams['DebtorPrices'] = ObjectSerializer::toQueryValue($debtor_prices);
        }
        // query params
        if ($debtor_class_prices !== null) {
            $queryParams['DebtorClassPrices'] = ObjectSerializer::toQueryValue($debtor_class_prices);
        }
        // query params
        if ($debtor_price_group_inventory_specific_prices !== null) {
            $queryParams['DebtorPriceGroupInventorySpecificPrices'] = ObjectSerializer::toQueryValue($debtor_price_group_inventory_specific_prices);
        }
        // query params
        if ($alternate_children !== null) {
            $queryParams['AlternateChildren'] = ObjectSerializer::toQueryValue($alternate_children);
        }
        // query params
        if ($alternate_parents !== null) {
            $queryParams['AlternateParents'] = ObjectSerializer::toQueryValue($alternate_parents);
        }
        // query params
        if ($components !== null) {
            $queryParams['Components'] = ObjectSerializer::toQueryValue($components);
        }
        // query params
        if ($warehouse_so_hs !== null) {
            $queryParams['WarehouseSOHs'] = ObjectSerializer::toQueryValue($warehouse_so_hs);
        }
        // query params
        if ($debtor_part_numbers !== null) {
            $queryParams['DebtorPartNumbers'] = ObjectSerializer::toQueryValue($debtor_part_numbers);
        }
        // query params
        if ($group_memberships !== null) {
            $queryParams['GroupMemberships'] = ObjectSerializer::toQueryValue($group_memberships);
        }
        // query params
        if ($other_descriptions !== null) {
            $queryParams['OtherDescriptions'] = ObjectSerializer::toQueryValue($other_descriptions);
        }
        // query params
        if ($order_levels !== null) {
            $queryParams['OrderLevels'] = ObjectSerializer::toQueryValue($order_levels);
        }
        // query params
        if ($budgets !== null) {
            $queryParams['Budgets'] = ObjectSerializer::toQueryValue($budgets);
        }
        // query params
        if ($logical_orders !== null) {
            $queryParams['LogicalOrders'] = ObjectSerializer::toQueryValue($logical_orders);
        }
        // query params
        if ($default_bin_locations !== null) {
            $queryParams['DefaultBinLocations'] = ObjectSerializer::toQueryValue($default_bin_locations);
        }
        // query params
        if ($product_availabilities !== null) {
            $queryParams['ProductAvailabilities'] = ObjectSerializer::toQueryValue($product_availabilities);
        }
        // query params
        if ($selling_prices !== null) {
            $queryParams['SellingPrices'] = ObjectSerializer::toQueryValue($selling_prices);
        }
        // query params
        if ($up_sells !== null) {
            $queryParams['UpSells'] = ObjectSerializer::toQueryValue($up_sells);
        }
        // query params
        if ($attribute_groups !== null) {
            $queryParams['AttributeGroups'] = ObjectSerializer::toQueryValue($attribute_groups);
        }
        // query params
        if ($unit_of_measures !== null) {
            $queryParams['UnitOfMeasures'] = ObjectSerializer::toQueryValue($unit_of_measures);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet
     *
     * Retrieves a price for a product, for a debtor, warehouse, date and quantity
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $in_logical_id in_logical_id (required)
     * @param  \DateTime $date date (required)
     * @param  double $quantity quantity (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryPriceGETResponse
     */
    public function inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetWithHttpInfo($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetWithHttpInfo
     *
     * Retrieves a price for a product, for a debtor, warehouse, date and quantity
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_id (required)
     * @param  string $in_logical_id (required)
     * @param  \DateTime $date (required)
     * @param  double $quantity (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryPriceGETResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetWithHttpInfo($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPriceGETResponse';
        $request = $this->inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetRequest($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPriceGETResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPriceGETResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPriceGETResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetAsync
     *
     * Retrieves a price for a product, for a debtor, warehouse, date and quantity
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_id (required)
     * @param  string $in_logical_id (required)
     * @param  \DateTime $date (required)
     * @param  double $quantity (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetAsync($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful = null)
    {
        return $this->inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetAsyncWithHttpInfo($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetAsyncWithHttpInfo
     *
     * Retrieves a price for a product, for a debtor, warehouse, date and quantity
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_id (required)
     * @param  string $in_logical_id (required)
     * @param  \DateTime $date (required)
     * @param  double $quantity (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetAsyncWithHttpInfo($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPriceGETResponse';
        $request = $this->inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetRequest($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $debtor_id (required)
     * @param  string $in_logical_id (required)
     * @param  \DateTime $date (required)
     * @param  double $quantity (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGetRequest($accept, $inventory_id, $debtor_id, $in_logical_id, $date, $quantity, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet'
            );
        }
        // verify the required parameter 'in_logical_id' is set
        if ($in_logical_id === null || (is_array($in_logical_id) && count($in_logical_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $in_logical_id when calling inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet'
            );
        }
        // verify the required parameter 'quantity' is set
        if ($quantity === null || (is_array($quantity) && count($quantity) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $quantity when calling inventoryPriceGETRequestInventoryIDPricingDebtorIDINLogicalIDDateQuantityGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Pricing/{DebtorID}/{IN_LogicalID}/{Date}/{Quantity}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($in_logical_id !== null) {
            $resourcePath = str_replace(
                '{' . 'IN_LogicalID' . '}',
                ObjectSerializer::toPathValue($in_logical_id),
                $resourcePath
            );
        }
        // path params
        if ($date !== null) {
            $resourcePath = str_replace(
                '{' . 'Date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }
        // path params
        if ($quantity !== null) {
            $resourcePath = str_replace(
                '{' . 'Quantity' . '}',
                ObjectSerializer::toPathValue($quantity),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete
     *
     * Deletes an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteWithHttpInfo
     *
     * Deletes an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteRequest($accept, $pricing_group_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsync
     *
     * Deletes an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsync($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        return $this->inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteRequest($accept, $pricing_group_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteRequest($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete'
            );
        }
        // verify the required parameter 'pricing_group_id' is set
        if ($pricing_group_id === null || (is_array($pricing_group_id) && count($pricing_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pricing_group_id when calling inventoryPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete'
            );
        }

        $resourcePath = '/Inventory/PricingGroups/{PricingGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($pricing_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PricingGroupID' . '}',
                ObjectSerializer::toPathValue($pricing_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGet
     *
     * Retrieves an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryPricingGroup
     */
    public function inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGet($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetWithHttpInfo
     *
     * Retrieves an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryPricingGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPricingGroup';
        $request = $this->inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetRequest($accept, $pricing_group_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsync
     *
     * Retrieves an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsync($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        return $this->inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPricingGroup';
        $request = $this->inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetRequest($accept, $pricing_group_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGetRequest($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGet'
            );
        }
        // verify the required parameter 'pricing_group_id' is set
        if ($pricing_group_id === null || (is_array($pricing_group_id) && count($pricing_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pricing_group_id when calling inventoryPricingGroupGETRequestPricingGroupsPricingGroupIDGet'
            );
        }

        $resourcePath = '/Inventory/PricingGroups/{PricingGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($pricing_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PricingGroupID' . '}',
                ObjectSerializer::toPathValue($pricing_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate
     *
     * Updates an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $is_default is_default (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryPricingGroup
     */
    public function inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        list($response) = $this->inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful, $description, $is_default, $last_saved_date_time, $body);
        return $response;
    }

    /**
     * Operation inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateWithHttpInfo
     *
     * Updates an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryPricingGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPricingGroup';
        $request = $this->inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateRequest($accept, $pricing_group_id, $jiwa_stateful, $description, $is_default, $last_saved_date_time, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsync
     *
     * Updates an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsync($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        return $this->inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful, $description, $is_default, $last_saved_date_time, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPricingGroup';
        $request = $this->inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateRequest($accept, $pricing_group_id, $jiwa_stateful, $description, $is_default, $last_saved_date_time, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateRequest($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate'
            );
        }
        // verify the required parameter 'pricing_group_id' is set
        if ($pricing_group_id === null || (is_array($pricing_group_id) && count($pricing_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pricing_group_id when calling inventoryPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate'
            );
        }

        $resourcePath = '/Inventory/PricingGroups/{PricingGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($pricing_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PricingGroupID' . '}',
                ObjectSerializer::toPathValue($pricing_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPricingGroupPOSTRequestPricingGroupsPost
     *
     * Creates a new inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $is_default is_default (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryPricingGroup
     */
    public function inventoryPricingGroupPOSTRequestPricingGroupsPost($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        list($response) = $this->inventoryPricingGroupPOSTRequestPricingGroupsPostWithHttpInfo($accept, $jiwa_stateful, $description, $is_default, $body);
        return $response;
    }

    /**
     * Operation inventoryPricingGroupPOSTRequestPricingGroupsPostWithHttpInfo
     *
     * Creates a new inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryPricingGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPricingGroupPOSTRequestPricingGroupsPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPricingGroup';
        $request = $this->inventoryPricingGroupPOSTRequestPricingGroupsPostRequest($accept, $jiwa_stateful, $description, $is_default, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPricingGroupPOSTRequestPricingGroupsPostAsync
     *
     * Creates a new inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupPOSTRequestPricingGroupsPostAsync($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        return $this->inventoryPricingGroupPOSTRequestPricingGroupsPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $is_default, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPricingGroupPOSTRequestPricingGroupsPostAsyncWithHttpInfo
     *
     * Creates a new inventory pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupPOSTRequestPricingGroupsPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPricingGroup';
        $request = $this->inventoryPricingGroupPOSTRequestPricingGroupsPostRequest($accept, $jiwa_stateful, $description, $is_default, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPricingGroupPOSTRequestPricingGroupsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\JiwaModel\InventoryPricingGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPricingGroupPOSTRequestPricingGroupsPostRequest($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryPricingGroupPOSTRequestPricingGroupsPost'
            );
        }

        $resourcePath = '/Inventory/PricingGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPricingGroupsGETManyRequestPricingGroupsGet
     *
     * Retrieves a list of inventory pricing groups.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryPricingGroup[]
     */
    public function inventoryPricingGroupsGETManyRequestPricingGroupsGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryPricingGroupsGETManyRequestPricingGroupsGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryPricingGroupsGETManyRequestPricingGroupsGetWithHttpInfo
     *
     * Retrieves a list of inventory pricing groups.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryPricingGroup[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPricingGroupsGETManyRequestPricingGroupsGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPricingGroup[]';
        $request = $this->inventoryPricingGroupsGETManyRequestPricingGroupsGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryPricingGroup[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPricingGroupsGETManyRequestPricingGroupsGetAsync
     *
     * Retrieves a list of inventory pricing groups.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupsGETManyRequestPricingGroupsGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->inventoryPricingGroupsGETManyRequestPricingGroupsGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPricingGroupsGETManyRequestPricingGroupsGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory pricing groups.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPricingGroupsGETManyRequestPricingGroupsGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryPricingGroup[]';
        $request = $this->inventoryPricingGroupsGETManyRequestPricingGroupsGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPricingGroupsGETManyRequestPricingGroupsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPricingGroupsGETManyRequestPricingGroupsGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryPricingGroupsGETManyRequestPricingGroupsGet'
            );
        }

        $resourcePath = '/Inventory/PricingGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGet
     *
     * Retrieves a list of product availabilities for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryProductAvailability[]
     */
    public function inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetWithHttpInfo
     *
     * Retrieves a list of product availabilities for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryProductAvailability[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryProductAvailability[]';
        $request = $this->inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetAsync
     *
     * Retrieves a list of product availabilities for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetAsyncWithHttpInfo
     *
     * Retrieves a list of product availabilities for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryProductAvailability[]';
        $request = $this->inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryProductAvailabilitiesGETManyRequestInventoryIDProductAvailabilitiesGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/ProductAvailabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGet
     *
     * Retrieves a product availability from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $logical_warehouse_id logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryProductAvailability
     */
    public function inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGet($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetWithHttpInfo
     *
     * Retrieves a product availability from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryProductAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryProductAvailability';
        $request = $this->inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetAsync
     *
     * Retrieves a product availability from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetAsync($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null)
    {
        return $this->inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetAsyncWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetAsyncWithHttpInfo
     *
     * Retrieves a product availability from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetAsyncWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryProductAvailability';
        $request = $this->inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGetRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGet'
            );
        }
        // verify the required parameter 'logical_warehouse_id' is set
        if ($logical_warehouse_id === null || (is_array($logical_warehouse_id) && count($logical_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logical_warehouse_id when calling inventoryProductAvailabilityGETRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/ProductAvailabilities/{LogicalWarehouseID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($logical_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'LogicalWarehouseID' . '}',
                ObjectSerializer::toPathValue($logical_warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdate
     *
     * Updates a product availability.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $logical_warehouse_id logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $available available (optional)
     * @param  string $product_availability_id product_availability_id (optional)
     * @param  string $logical_warehouse_description logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryProductAvailabilityPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryProductAvailability
     */
    public function inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdate($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $available = null, $product_availability_id = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        list($response) = $this->inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $available, $product_availability_id, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);
        return $response;
    }

    /**
     * Operation inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateWithHttpInfo
     *
     * Updates a product availability.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $available (optional)
     * @param  string $product_availability_id (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryProductAvailabilityPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryProductAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $available = null, $product_availability_id = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryProductAvailability';
        $request = $this->inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $available, $product_availability_id, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryProductAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateAsync
     *
     * Updates a product availability.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $available (optional)
     * @param  string $product_availability_id (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryProductAvailabilityPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateAsync($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $available = null, $product_availability_id = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        return $this->inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $available, $product_availability_id, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateAsyncWithHttpInfo
     *
     * Updates a product availability.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $available (optional)
     * @param  string $product_availability_id (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryProductAvailabilityPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $available = null, $product_availability_id = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryProductAvailability';
        $request = $this->inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful, $available, $product_availability_id, $logical_warehouse_description, $physical_warehouse_id, $physical_warehouse_description, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $logical_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $available (optional)
     * @param  string $product_availability_id (optional)
     * @param  string $logical_warehouse_description (optional)
     * @param  string $physical_warehouse_id (optional)
     * @param  string $physical_warehouse_description (optional)
     * @param  \Jiwa\JiwaModel\InventoryProductAvailabilityPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdateRequest($accept, $inventory_id, $logical_warehouse_id, $jiwa_stateful = null, $available = null, $product_availability_id = null, $logical_warehouse_description = null, $physical_warehouse_id = null, $physical_warehouse_description = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdate'
            );
        }
        // verify the required parameter 'logical_warehouse_id' is set
        if ($logical_warehouse_id === null || (is_array($logical_warehouse_id) && count($logical_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logical_warehouse_id when calling inventoryProductAvailabilityPATCHRequestInventoryIDProductAvailabilitiesLogicalWarehouseIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/ProductAvailabilities/{LogicalWarehouseID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($available !== null) {
            $queryParams['Available'] = ObjectSerializer::toQueryValue($available);
        }
        // query params
        if ($product_availability_id !== null) {
            $queryParams['ProductAvailabilityID'] = ObjectSerializer::toQueryValue($product_availability_id);
        }
        // query params
        if ($logical_warehouse_description !== null) {
            $queryParams['LogicalWarehouseDescription'] = ObjectSerializer::toQueryValue($logical_warehouse_description);
        }
        // query params
        if ($physical_warehouse_id !== null) {
            $queryParams['PhysicalWarehouseID'] = ObjectSerializer::toQueryValue($physical_warehouse_id);
        }
        // query params
        if ($physical_warehouse_description !== null) {
            $queryParams['PhysicalWarehouseDescription'] = ObjectSerializer::toQueryValue($physical_warehouse_description);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($logical_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'LogicalWarehouseID' . '}',
                ObjectSerializer::toPathValue($logical_warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryRegionGETRequestInventoryIDRegionsRegionNameGet
     *
     * Retrieves an inventory region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryRegion
     */
    public function inventoryRegionGETRequestInventoryIDRegionsRegionNameGet($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryRegionGETRequestInventoryIDRegionsRegionNameGetWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryRegionGETRequestInventoryIDRegionsRegionNameGetWithHttpInfo
     *
     * Retrieves an inventory region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryRegion, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryRegionGETRequestInventoryIDRegionsRegionNameGetWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryRegion';
        $request = $this->inventoryRegionGETRequestInventoryIDRegionsRegionNameGetRequest($accept, $inventory_id, $region_name, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryRegionGETRequestInventoryIDRegionsRegionNameGetAsync
     *
     * Retrieves an inventory region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegionGETRequestInventoryIDRegionsRegionNameGetAsync($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        return $this->inventoryRegionGETRequestInventoryIDRegionsRegionNameGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryRegionGETRequestInventoryIDRegionsRegionNameGetAsyncWithHttpInfo
     *
     * Retrieves an inventory region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegionGETRequestInventoryIDRegionsRegionNameGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryRegion';
        $request = $this->inventoryRegionGETRequestInventoryIDRegionsRegionNameGetRequest($accept, $inventory_id, $region_name, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryRegionGETRequestInventoryIDRegionsRegionNameGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryRegionGETRequestInventoryIDRegionsRegionNameGetRequest($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryRegionGETRequestInventoryIDRegionsRegionNameGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryRegionGETRequestInventoryIDRegionsRegionNameGet'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventoryRegionGETRequestInventoryIDRegionsRegionNameGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdate
     *
     * Updates a inventory region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $region_supplier_ordering_id region_supplier_ordering_id (optional)
     * @param  bool $order_enabled order_enabled (optional)
     * @param  string $region_id region_id (optional)
     * @param  string $suppliers suppliers (optional)
     * @param  \Jiwa\JiwaModel\InventoryRegionPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryRegion
     */
    public function inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdate($accept, $inventory_id, $region_name, $jiwa_stateful = null, $region_supplier_ordering_id = null, $order_enabled = null, $region_id = null, $suppliers = null, $body = null)
    {
        list($response) = $this->inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful, $region_supplier_ordering_id, $order_enabled, $region_id, $suppliers, $body);
        return $response;
    }

    /**
     * Operation inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateWithHttpInfo
     *
     * Updates a inventory region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $region_supplier_ordering_id (optional)
     * @param  bool $order_enabled (optional)
     * @param  string $region_id (optional)
     * @param  string $suppliers (optional)
     * @param  \Jiwa\JiwaModel\InventoryRegionPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryRegion, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful = null, $region_supplier_ordering_id = null, $order_enabled = null, $region_id = null, $suppliers = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryRegion';
        $request = $this->inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateRequest($accept, $inventory_id, $region_name, $jiwa_stateful, $region_supplier_ordering_id, $order_enabled, $region_id, $suppliers, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateAsync
     *
     * Updates a inventory region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $region_supplier_ordering_id (optional)
     * @param  bool $order_enabled (optional)
     * @param  string $region_id (optional)
     * @param  string $suppliers (optional)
     * @param  \Jiwa\JiwaModel\InventoryRegionPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateAsync($accept, $inventory_id, $region_name, $jiwa_stateful = null, $region_supplier_ordering_id = null, $order_enabled = null, $region_id = null, $suppliers = null, $body = null)
    {
        return $this->inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateAsyncWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful, $region_supplier_ordering_id, $order_enabled, $region_id, $suppliers, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateAsyncWithHttpInfo
     *
     * Updates a inventory region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $region_supplier_ordering_id (optional)
     * @param  bool $order_enabled (optional)
     * @param  string $region_id (optional)
     * @param  string $suppliers (optional)
     * @param  \Jiwa\JiwaModel\InventoryRegionPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateAsyncWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful = null, $region_supplier_ordering_id = null, $order_enabled = null, $region_id = null, $suppliers = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryRegion';
        $request = $this->inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateRequest($accept, $inventory_id, $region_name, $jiwa_stateful, $region_supplier_ordering_id, $order_enabled, $region_id, $suppliers, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $region_supplier_ordering_id (optional)
     * @param  bool $order_enabled (optional)
     * @param  string $region_id (optional)
     * @param  string $suppliers (optional)
     * @param  \Jiwa\JiwaModel\InventoryRegionPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdateRequest($accept, $inventory_id, $region_name, $jiwa_stateful = null, $region_supplier_ordering_id = null, $order_enabled = null, $region_id = null, $suppliers = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdate'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventoryRegionPATCHRequestInventoryIDRegionsRegionNameUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($region_supplier_ordering_id !== null) {
            $queryParams['RegionSupplierOrderingID'] = ObjectSerializer::toQueryValue($region_supplier_ordering_id);
        }
        // query params
        if ($order_enabled !== null) {
            $queryParams['OrderEnabled'] = ObjectSerializer::toQueryValue($order_enabled);
        }
        // query params
        if ($region_id !== null) {
            $queryParams['RegionID'] = ObjectSerializer::toQueryValue($region_id);
        }
        // query params
        if ($suppliers !== null) {
            $queryParams['Suppliers'] = ObjectSerializer::toQueryValue($suppliers);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryRegionsGETManyRequestInventoryIDRegionsGet
     *
     * Retrieves a list of inventory regions.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryRegion[]
     */
    public function inventoryRegionsGETManyRequestInventoryIDRegionsGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryRegionsGETManyRequestInventoryIDRegionsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryRegionsGETManyRequestInventoryIDRegionsGetWithHttpInfo
     *
     * Retrieves a list of inventory regions.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryRegion[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryRegionsGETManyRequestInventoryIDRegionsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryRegion[]';
        $request = $this->inventoryRegionsGETManyRequestInventoryIDRegionsGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryRegion[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryRegionsGETManyRequestInventoryIDRegionsGetAsync
     *
     * Retrieves a list of inventory regions.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegionsGETManyRequestInventoryIDRegionsGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryRegionsGETManyRequestInventoryIDRegionsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryRegionsGETManyRequestInventoryIDRegionsGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory regions.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegionsGETManyRequestInventoryIDRegionsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryRegion[]';
        $request = $this->inventoryRegionsGETManyRequestInventoryIDRegionsGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryRegionsGETManyRequestInventoryIDRegionsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryRegionsGETManyRequestInventoryIDRegionsGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryRegionsGETManyRequestInventoryIDRegionsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryRegionsGETManyRequestInventoryIDRegionsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySAVERequestSaveGet
     *
     * Saves a stateful inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id inventory_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryItem
     */
    public function inventorySAVERequestSaveGet($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        list($response) = $this->inventorySAVERequestSaveGetWithHttpInfo($accept, $jiwa_stateful, $inventory_id);
        return $response;
    }

    /**
     * Operation inventorySAVERequestSaveGetWithHttpInfo
     *
     * Saves a stateful inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySAVERequestSaveGetWithHttpInfo($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryItem';
        $request = $this->inventorySAVERequestSaveGetRequest($accept, $jiwa_stateful, $inventory_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySAVERequestSaveGetAsync
     *
     * Saves a stateful inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySAVERequestSaveGetAsync($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        return $this->inventorySAVERequestSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful, $inventory_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySAVERequestSaveGetAsyncWithHttpInfo
     *
     * Saves a stateful inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySAVERequestSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryItem';
        $request = $this->inventorySAVERequestSaveGetRequest($accept, $jiwa_stateful, $inventory_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySAVERequestSaveGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySAVERequestSaveGetRequest($accept, $jiwa_stateful = null, $inventory_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySAVERequestSaveGet'
            );
        }

        $resourcePath = '/Inventory/Save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inventory_id !== null) {
            $queryParams['InventoryID'] = ObjectSerializer::toQueryValue($inventory_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySellingPriceGETRequestInventoryIDSellingPricesGet
     *
     * Retrieves the selling prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySellingPrices
     */
    public function inventorySellingPriceGETRequestInventoryIDSellingPricesGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventorySellingPriceGETRequestInventoryIDSellingPricesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventorySellingPriceGETRequestInventoryIDSellingPricesGetWithHttpInfo
     *
     * Retrieves the selling prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySellingPrices, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySellingPriceGETRequestInventoryIDSellingPricesGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySellingPrices';
        $request = $this->inventorySellingPriceGETRequestInventoryIDSellingPricesGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySellingPrices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySellingPrices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySellingPrices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySellingPrices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySellingPriceGETRequestInventoryIDSellingPricesGetAsync
     *
     * Retrieves the selling prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySellingPriceGETRequestInventoryIDSellingPricesGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventorySellingPriceGETRequestInventoryIDSellingPricesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySellingPriceGETRequestInventoryIDSellingPricesGetAsyncWithHttpInfo
     *
     * Retrieves the selling prices for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySellingPriceGETRequestInventoryIDSellingPricesGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySellingPrices';
        $request = $this->inventorySellingPriceGETRequestInventoryIDSellingPricesGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySellingPriceGETRequestInventoryIDSellingPricesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySellingPriceGETRequestInventoryIDSellingPricesGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySellingPriceGETRequestInventoryIDSellingPricesGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySellingPriceGETRequestInventoryIDSellingPricesGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/SellingPrices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdate
     *
     * Updates the selling prices.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $sell_prices sell_prices (optional)
     * @param  \DateTime $current_price_date current_price_date (optional)
     * @param  \DateTime $forward_price_date forward_price_date (optional)
     * @param  \Jiwa\JiwaModel\InventorySellingPricePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySellingPrices
     */
    public function inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdate($accept, $inventory_id, $jiwa_stateful = null, $sell_prices = null, $current_price_date = null, $forward_price_date = null, $body = null)
    {
        list($response) = $this->inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $sell_prices, $current_price_date, $forward_price_date, $body);
        return $response;
    }

    /**
     * Operation inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateWithHttpInfo
     *
     * Updates the selling prices.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $sell_prices (optional)
     * @param  \DateTime $current_price_date (optional)
     * @param  \DateTime $forward_price_date (optional)
     * @param  \Jiwa\JiwaModel\InventorySellingPricePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySellingPrices, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $sell_prices = null, $current_price_date = null, $forward_price_date = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySellingPrices';
        $request = $this->inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateRequest($accept, $inventory_id, $jiwa_stateful, $sell_prices, $current_price_date, $forward_price_date, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySellingPrices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySellingPrices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySellingPrices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySellingPrices',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateAsync
     *
     * Updates the selling prices.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $sell_prices (optional)
     * @param  \DateTime $current_price_date (optional)
     * @param  \DateTime $forward_price_date (optional)
     * @param  \Jiwa\JiwaModel\InventorySellingPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateAsync($accept, $inventory_id, $jiwa_stateful = null, $sell_prices = null, $current_price_date = null, $forward_price_date = null, $body = null)
    {
        return $this->inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $sell_prices, $current_price_date, $forward_price_date, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateAsyncWithHttpInfo
     *
     * Updates the selling prices.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $sell_prices (optional)
     * @param  \DateTime $current_price_date (optional)
     * @param  \DateTime $forward_price_date (optional)
     * @param  \Jiwa\JiwaModel\InventorySellingPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $sell_prices = null, $current_price_date = null, $forward_price_date = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySellingPrices';
        $request = $this->inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateRequest($accept, $inventory_id, $jiwa_stateful, $sell_prices, $current_price_date, $forward_price_date, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $sell_prices (optional)
     * @param  \DateTime $current_price_date (optional)
     * @param  \DateTime $forward_price_date (optional)
     * @param  \Jiwa\JiwaModel\InventorySellingPricePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdateRequest($accept, $inventory_id, $jiwa_stateful = null, $sell_prices = null, $current_price_date = null, $forward_price_date = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySellingPricePATCHRequestInventoryIDSellingPricesUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/SellingPrices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sell_prices !== null) {
            $queryParams['SellPrices'] = ObjectSerializer::toQueryValue($sell_prices);
        }
        // query params
        if ($current_price_date !== null) {
            $queryParams['CurrentPriceDate'] = ObjectSerializer::toQueryValue($current_price_date);
        }
        // query params
        if ($forward_price_date !== null) {
            $queryParams['ForwardPriceDate'] = ObjectSerializer::toQueryValue($forward_price_date);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDelete
     *
     * Deletes an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  string $supplier_id supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate fx_rate (optional)
     * @param  bool $default_supplier default_supplier (optional)
     * @param  double $spare_float1 spare_float1 (optional)
     * @param  double $spare_float2 spare_float2 (optional)
     * @param  double $spare_float3 spare_float3 (optional)
     * @param  \DateTime $spare_date1 spare_date1 (optional)
     * @param  \DateTime $spare_date2 spare_date2 (optional)
     * @param  \DateTime $spare_date3 spare_date3 (optional)
     * @param  string $creditor_id creditor_id (optional)
     * @param  string $creditor_account_no creditor_account_no (optional)
     * @param  string $creditor_name creditor_name (optional)
     * @param  string $supplier_part_no supplier_part_no (optional)
     * @param  string $supplier_upc supplier_upc (optional)
     * @param  string $spare_string1 spare_string1 (optional)
     * @param  string $spare_string2 spare_string2 (optional)
     * @param  string $spare_string3 spare_string3 (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $supplier_warehouses supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks supplier_quantity_price_breaks (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDelete($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null)
    {
        list($response) = $this->inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks);
        return $response;
    }

    /**
     * Operation inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteWithHttpInfo
     *
     * Deletes an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteAsync
     *
     * Deletes an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteAsync($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null)
    {
        return $this->inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteAsyncWithHttpInfo
     *
     * Deletes an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDeleteRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDelete'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDelete'
            );
        }
        // verify the required parameter 'supplier_id' is set
        if ($supplier_id === null || (is_array($supplier_id) && count($supplier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_id when calling inventorySupplierDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers/{SupplierID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fx_rate !== null) {
            $queryParams['FXRate'] = ObjectSerializer::toQueryValue($fx_rate);
        }
        // query params
        if ($default_supplier !== null) {
            $queryParams['DefaultSupplier'] = ObjectSerializer::toQueryValue($default_supplier);
        }
        // query params
        if ($spare_float1 !== null) {
            $queryParams['SpareFloat1'] = ObjectSerializer::toQueryValue($spare_float1);
        }
        // query params
        if ($spare_float2 !== null) {
            $queryParams['SpareFloat2'] = ObjectSerializer::toQueryValue($spare_float2);
        }
        // query params
        if ($spare_float3 !== null) {
            $queryParams['SpareFloat3'] = ObjectSerializer::toQueryValue($spare_float3);
        }
        // query params
        if ($spare_date1 !== null) {
            $queryParams['SpareDate1'] = ObjectSerializer::toQueryValue($spare_date1);
        }
        // query params
        if ($spare_date2 !== null) {
            $queryParams['SpareDate2'] = ObjectSerializer::toQueryValue($spare_date2);
        }
        // query params
        if ($spare_date3 !== null) {
            $queryParams['SpareDate3'] = ObjectSerializer::toQueryValue($spare_date3);
        }
        // query params
        if ($creditor_id !== null) {
            $queryParams['CreditorID'] = ObjectSerializer::toQueryValue($creditor_id);
        }
        // query params
        if ($creditor_account_no !== null) {
            $queryParams['CreditorAccountNo'] = ObjectSerializer::toQueryValue($creditor_account_no);
        }
        // query params
        if ($creditor_name !== null) {
            $queryParams['CreditorName'] = ObjectSerializer::toQueryValue($creditor_name);
        }
        // query params
        if ($supplier_part_no !== null) {
            $queryParams['SupplierPartNo'] = ObjectSerializer::toQueryValue($supplier_part_no);
        }
        // query params
        if ($supplier_upc !== null) {
            $queryParams['SupplierUPC'] = ObjectSerializer::toQueryValue($supplier_upc);
        }
        // query params
        if ($spare_string1 !== null) {
            $queryParams['SpareString1'] = ObjectSerializer::toQueryValue($spare_string1);
        }
        // query params
        if ($spare_string2 !== null) {
            $queryParams['SpareString2'] = ObjectSerializer::toQueryValue($spare_string2);
        }
        // query params
        if ($spare_string3 !== null) {
            $queryParams['SpareString3'] = ObjectSerializer::toQueryValue($spare_string3);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($supplier_warehouses !== null) {
            $queryParams['SupplierWarehouses'] = ObjectSerializer::toQueryValue($supplier_warehouses);
        }
        // query params
        if ($supplier_quantity_price_breaks !== null) {
            $queryParams['SupplierQuantityPriceBreaks'] = ObjectSerializer::toQueryValue($supplier_quantity_price_breaks);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }
        // path params
        if ($supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierID' . '}',
                ObjectSerializer::toPathValue($supplier_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGet
     *
     * Retrieves an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  string $supplier_id supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySupplier
     */
    public function inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGet($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetWithHttpInfo
     *
     * Retrieves an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySupplier, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplier';
        $request = $this->inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetAsync
     *
     * Retrieves an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetAsync($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        return $this->inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplier';
        $request = $this->inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGetRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGet'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGet'
            );
        }
        // verify the required parameter 'supplier_id' is set
        if ($supplier_id === null || (is_array($supplier_id) && count($supplier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_id when calling inventorySupplierGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers/{SupplierID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }
        // path params
        if ($supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierID' . '}',
                ObjectSerializer::toPathValue($supplier_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdate
     *
     * Updates an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  string $supplier_id supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate fx_rate (optional)
     * @param  bool $default_supplier default_supplier (optional)
     * @param  double $spare_float1 spare_float1 (optional)
     * @param  double $spare_float2 spare_float2 (optional)
     * @param  double $spare_float3 spare_float3 (optional)
     * @param  \DateTime $spare_date1 spare_date1 (optional)
     * @param  \DateTime $spare_date2 spare_date2 (optional)
     * @param  \DateTime $spare_date3 spare_date3 (optional)
     * @param  string $creditor_id creditor_id (optional)
     * @param  string $creditor_account_no creditor_account_no (optional)
     * @param  string $creditor_name creditor_name (optional)
     * @param  string $supplier_part_no supplier_part_no (optional)
     * @param  string $supplier_upc supplier_upc (optional)
     * @param  string $spare_string1 spare_string1 (optional)
     * @param  string $spare_string2 spare_string2 (optional)
     * @param  string $spare_string3 spare_string3 (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $supplier_warehouses supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySupplier
     */
    public function inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdate($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        list($response) = $this->inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks, $body);
        return $response;
    }

    /**
     * Operation inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateWithHttpInfo
     *
     * Updates an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySupplier, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplier';
        $request = $this->inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateAsync
     *
     * Updates an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateAsync($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        return $this->inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateAsyncWithHttpInfo
     *
     * Updates an inventory item supplier.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplier';
        $request = $this->inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdateRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdate'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdate'
            );
        }
        // verify the required parameter 'supplier_id' is set
        if ($supplier_id === null || (is_array($supplier_id) && count($supplier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_id when calling inventorySupplierPATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers/{SupplierID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fx_rate !== null) {
            $queryParams['FXRate'] = ObjectSerializer::toQueryValue($fx_rate);
        }
        // query params
        if ($default_supplier !== null) {
            $queryParams['DefaultSupplier'] = ObjectSerializer::toQueryValue($default_supplier);
        }
        // query params
        if ($spare_float1 !== null) {
            $queryParams['SpareFloat1'] = ObjectSerializer::toQueryValue($spare_float1);
        }
        // query params
        if ($spare_float2 !== null) {
            $queryParams['SpareFloat2'] = ObjectSerializer::toQueryValue($spare_float2);
        }
        // query params
        if ($spare_float3 !== null) {
            $queryParams['SpareFloat3'] = ObjectSerializer::toQueryValue($spare_float3);
        }
        // query params
        if ($spare_date1 !== null) {
            $queryParams['SpareDate1'] = ObjectSerializer::toQueryValue($spare_date1);
        }
        // query params
        if ($spare_date2 !== null) {
            $queryParams['SpareDate2'] = ObjectSerializer::toQueryValue($spare_date2);
        }
        // query params
        if ($spare_date3 !== null) {
            $queryParams['SpareDate3'] = ObjectSerializer::toQueryValue($spare_date3);
        }
        // query params
        if ($creditor_id !== null) {
            $queryParams['CreditorID'] = ObjectSerializer::toQueryValue($creditor_id);
        }
        // query params
        if ($creditor_account_no !== null) {
            $queryParams['CreditorAccountNo'] = ObjectSerializer::toQueryValue($creditor_account_no);
        }
        // query params
        if ($creditor_name !== null) {
            $queryParams['CreditorName'] = ObjectSerializer::toQueryValue($creditor_name);
        }
        // query params
        if ($supplier_part_no !== null) {
            $queryParams['SupplierPartNo'] = ObjectSerializer::toQueryValue($supplier_part_no);
        }
        // query params
        if ($supplier_upc !== null) {
            $queryParams['SupplierUPC'] = ObjectSerializer::toQueryValue($supplier_upc);
        }
        // query params
        if ($spare_string1 !== null) {
            $queryParams['SpareString1'] = ObjectSerializer::toQueryValue($spare_string1);
        }
        // query params
        if ($spare_string2 !== null) {
            $queryParams['SpareString2'] = ObjectSerializer::toQueryValue($spare_string2);
        }
        // query params
        if ($spare_string3 !== null) {
            $queryParams['SpareString3'] = ObjectSerializer::toQueryValue($spare_string3);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($supplier_warehouses !== null) {
            $queryParams['SupplierWarehouses'] = ObjectSerializer::toQueryValue($supplier_warehouses);
        }
        // query params
        if ($supplier_quantity_price_breaks !== null) {
            $queryParams['SupplierQuantityPriceBreaks'] = ObjectSerializer::toQueryValue($supplier_quantity_price_breaks);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }
        // path params
        if ($supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierID' . '}',
                ObjectSerializer::toPathValue($supplier_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPost
     *
     * Appends a supplier to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate fx_rate (optional)
     * @param  bool $default_supplier default_supplier (optional)
     * @param  double $spare_float1 spare_float1 (optional)
     * @param  double $spare_float2 spare_float2 (optional)
     * @param  double $spare_float3 spare_float3 (optional)
     * @param  \DateTime $spare_date1 spare_date1 (optional)
     * @param  \DateTime $spare_date2 spare_date2 (optional)
     * @param  \DateTime $spare_date3 spare_date3 (optional)
     * @param  string $creditor_id creditor_id (optional)
     * @param  string $creditor_account_no creditor_account_no (optional)
     * @param  string $creditor_name creditor_name (optional)
     * @param  string $supplier_part_no supplier_part_no (optional)
     * @param  string $supplier_upc supplier_upc (optional)
     * @param  string $spare_string1 spare_string1 (optional)
     * @param  string $spare_string2 spare_string2 (optional)
     * @param  string $spare_string3 spare_string3 (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $supplier_warehouses supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySupplier
     */
    public function inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPost($accept, $inventory_id, $region_name, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        list($response) = $this->inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks, $body);
        return $response;
    }

    /**
     * Operation inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostWithHttpInfo
     *
     * Appends a supplier to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySupplier, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplier';
        $request = $this->inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostRequest($accept, $inventory_id, $region_name, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostAsync
     *
     * Appends a supplier to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostAsync($accept, $inventory_id, $region_name, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        return $this->inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostAsyncWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostAsyncWithHttpInfo
     *
     * Appends a supplier to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostAsyncWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplier';
        $request = $this->inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostRequest($accept, $inventory_id, $region_name, $jiwa_stateful, $fx_rate, $default_supplier, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_id, $creditor_account_no, $creditor_name, $supplier_part_no, $supplier_upc, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $supplier_warehouses, $supplier_quantity_price_breaks, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $fx_rate (optional)
     * @param  bool $default_supplier (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_id (optional)
     * @param  string $creditor_account_no (optional)
     * @param  string $creditor_name (optional)
     * @param  string $supplier_part_no (optional)
     * @param  string $supplier_upc (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $supplier_warehouses (optional)
     * @param  string $supplier_quantity_price_breaks (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPostRequest($accept, $inventory_id, $region_name, $jiwa_stateful = null, $fx_rate = null, $default_supplier = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_id = null, $creditor_account_no = null, $creditor_name = null, $supplier_part_no = null, $supplier_upc = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $supplier_warehouses = null, $supplier_quantity_price_breaks = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPost'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierPOSTRequestInventoryIDRegionsRegionNameSuppliersPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fx_rate !== null) {
            $queryParams['FXRate'] = ObjectSerializer::toQueryValue($fx_rate);
        }
        // query params
        if ($default_supplier !== null) {
            $queryParams['DefaultSupplier'] = ObjectSerializer::toQueryValue($default_supplier);
        }
        // query params
        if ($spare_float1 !== null) {
            $queryParams['SpareFloat1'] = ObjectSerializer::toQueryValue($spare_float1);
        }
        // query params
        if ($spare_float2 !== null) {
            $queryParams['SpareFloat2'] = ObjectSerializer::toQueryValue($spare_float2);
        }
        // query params
        if ($spare_float3 !== null) {
            $queryParams['SpareFloat3'] = ObjectSerializer::toQueryValue($spare_float3);
        }
        // query params
        if ($spare_date1 !== null) {
            $queryParams['SpareDate1'] = ObjectSerializer::toQueryValue($spare_date1);
        }
        // query params
        if ($spare_date2 !== null) {
            $queryParams['SpareDate2'] = ObjectSerializer::toQueryValue($spare_date2);
        }
        // query params
        if ($spare_date3 !== null) {
            $queryParams['SpareDate3'] = ObjectSerializer::toQueryValue($spare_date3);
        }
        // query params
        if ($creditor_id !== null) {
            $queryParams['CreditorID'] = ObjectSerializer::toQueryValue($creditor_id);
        }
        // query params
        if ($creditor_account_no !== null) {
            $queryParams['CreditorAccountNo'] = ObjectSerializer::toQueryValue($creditor_account_no);
        }
        // query params
        if ($creditor_name !== null) {
            $queryParams['CreditorName'] = ObjectSerializer::toQueryValue($creditor_name);
        }
        // query params
        if ($supplier_part_no !== null) {
            $queryParams['SupplierPartNo'] = ObjectSerializer::toQueryValue($supplier_part_no);
        }
        // query params
        if ($supplier_upc !== null) {
            $queryParams['SupplierUPC'] = ObjectSerializer::toQueryValue($supplier_upc);
        }
        // query params
        if ($spare_string1 !== null) {
            $queryParams['SpareString1'] = ObjectSerializer::toQueryValue($spare_string1);
        }
        // query params
        if ($spare_string2 !== null) {
            $queryParams['SpareString2'] = ObjectSerializer::toQueryValue($spare_string2);
        }
        // query params
        if ($spare_string3 !== null) {
            $queryParams['SpareString3'] = ObjectSerializer::toQueryValue($spare_string3);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($supplier_warehouses !== null) {
            $queryParams['SupplierWarehouses'] = ObjectSerializer::toQueryValue($supplier_warehouses);
        }
        // query params
        if ($supplier_quantity_price_breaks !== null) {
            $queryParams['SupplierQuantityPriceBreaks'] = ObjectSerializer::toQueryValue($supplier_quantity_price_breaks);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDelete
     *
     * Deletes a supplier warehouse from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  string $supplier_id supplier_id (required)
     * @param  string $supplier_warehouse_id supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse default_warehouse (optional)
     * @param  double $home_suppliers_cost home_suppliers_cost (optional)
     * @param  double $suppliers_cost suppliers_cost (optional)
     * @param  double $suppliers_cost2 suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 home_suppliers_cost2 (optional)
     * @param  double $supplier_soh supplier_soh (optional)
     * @param  int $delivery_days delivery_days (optional)
     * @param  double $spare_float1 spare_float1 (optional)
     * @param  double $spare_float2 spare_float2 (optional)
     * @param  double $spare_float3 spare_float3 (optional)
     * @param  \DateTime $spare_date1 spare_date1 (optional)
     * @param  \DateTime $spare_date2 spare_date2 (optional)
     * @param  \DateTime $spare_date3 spare_date3 (optional)
     * @param  string $creditor_warehouse_id creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description creditor_warehouse_description (optional)
     * @param  string $spare_string1 spare_string1 (optional)
     * @param  string $spare_string2 spare_string2 (optional)
     * @param  string $spare_string3 spare_string3 (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $unit_of_measure unit_of_measure (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDelete($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null)
    {
        list($response) = $this->inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure);
        return $response;
    }

    /**
     * Operation inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteWithHttpInfo
     *
     * Deletes a supplier warehouse from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteAsync
     *
     * Deletes a supplier warehouse from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteAsync($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null)
    {
        return $this->inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteAsyncWithHttpInfo
     *
     * Deletes a supplier warehouse from an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDeleteRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDelete'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDelete'
            );
        }
        // verify the required parameter 'supplier_id' is set
        if ($supplier_id === null || (is_array($supplier_id) && count($supplier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_id when calling inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDelete'
            );
        }
        // verify the required parameter 'supplier_warehouse_id' is set
        if ($supplier_warehouse_id === null || (is_array($supplier_warehouse_id) && count($supplier_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_warehouse_id when calling inventorySupplierWarehouseDELETERequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers/{SupplierID}/SupplierWarehouses/{SupplierWarehouseID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_warehouse !== null) {
            $queryParams['DefaultWarehouse'] = ObjectSerializer::toQueryValue($default_warehouse);
        }
        // query params
        if ($home_suppliers_cost !== null) {
            $queryParams['HomeSuppliersCost'] = ObjectSerializer::toQueryValue($home_suppliers_cost);
        }
        // query params
        if ($suppliers_cost !== null) {
            $queryParams['SuppliersCost'] = ObjectSerializer::toQueryValue($suppliers_cost);
        }
        // query params
        if ($suppliers_cost2 !== null) {
            $queryParams['SuppliersCost2'] = ObjectSerializer::toQueryValue($suppliers_cost2);
        }
        // query params
        if ($home_suppliers_cost2 !== null) {
            $queryParams['HomeSuppliersCost2'] = ObjectSerializer::toQueryValue($home_suppliers_cost2);
        }
        // query params
        if ($supplier_soh !== null) {
            $queryParams['SupplierSOH'] = ObjectSerializer::toQueryValue($supplier_soh);
        }
        // query params
        if ($delivery_days !== null) {
            $queryParams['DeliveryDays'] = ObjectSerializer::toQueryValue($delivery_days);
        }
        // query params
        if ($spare_float1 !== null) {
            $queryParams['SpareFloat1'] = ObjectSerializer::toQueryValue($spare_float1);
        }
        // query params
        if ($spare_float2 !== null) {
            $queryParams['SpareFloat2'] = ObjectSerializer::toQueryValue($spare_float2);
        }
        // query params
        if ($spare_float3 !== null) {
            $queryParams['SpareFloat3'] = ObjectSerializer::toQueryValue($spare_float3);
        }
        // query params
        if ($spare_date1 !== null) {
            $queryParams['SpareDate1'] = ObjectSerializer::toQueryValue($spare_date1);
        }
        // query params
        if ($spare_date2 !== null) {
            $queryParams['SpareDate2'] = ObjectSerializer::toQueryValue($spare_date2);
        }
        // query params
        if ($spare_date3 !== null) {
            $queryParams['SpareDate3'] = ObjectSerializer::toQueryValue($spare_date3);
        }
        // query params
        if ($creditor_warehouse_id !== null) {
            $queryParams['CreditorWarehouseID'] = ObjectSerializer::toQueryValue($creditor_warehouse_id);
        }
        // query params
        if ($creditor_warehouse_description !== null) {
            $queryParams['CreditorWarehouseDescription'] = ObjectSerializer::toQueryValue($creditor_warehouse_description);
        }
        // query params
        if ($spare_string1 !== null) {
            $queryParams['SpareString1'] = ObjectSerializer::toQueryValue($spare_string1);
        }
        // query params
        if ($spare_string2 !== null) {
            $queryParams['SpareString2'] = ObjectSerializer::toQueryValue($spare_string2);
        }
        // query params
        if ($spare_string3 !== null) {
            $queryParams['SpareString3'] = ObjectSerializer::toQueryValue($spare_string3);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($unit_of_measure !== null) {
            $queryParams['UnitOfMeasure'] = ObjectSerializer::toQueryValue($unit_of_measure);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }
        // path params
        if ($supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierID' . '}',
                ObjectSerializer::toPathValue($supplier_id),
                $resourcePath
            );
        }
        // path params
        if ($supplier_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierWarehouseID' . '}',
                ObjectSerializer::toPathValue($supplier_warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGet
     *
     * Retrieves an inventory item supplier warehouse.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  string $supplier_id supplier_id (required)
     * @param  string $supplier_warehouse_id supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySupplierWarehouse
     */
    public function inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGet($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetWithHttpInfo
     *
     * Retrieves an inventory item supplier warehouse.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySupplierWarehouse, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplierWarehouse';
        $request = $this->inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetAsync
     *
     * Retrieves an inventory item supplier warehouse.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetAsync($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null)
    {
        return $this->inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory item supplier warehouse.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplierWarehouse';
        $request = $this->inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGetRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGet'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGet'
            );
        }
        // verify the required parameter 'supplier_id' is set
        if ($supplier_id === null || (is_array($supplier_id) && count($supplier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_id when calling inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGet'
            );
        }
        // verify the required parameter 'supplier_warehouse_id' is set
        if ($supplier_warehouse_id === null || (is_array($supplier_warehouse_id) && count($supplier_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_warehouse_id when calling inventorySupplierWarehouseGETRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers/{SupplierID}/SupplierWarehouses/{SupplierWarehouseID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }
        // path params
        if ($supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierID' . '}',
                ObjectSerializer::toPathValue($supplier_id),
                $resourcePath
            );
        }
        // path params
        if ($supplier_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierWarehouseID' . '}',
                ObjectSerializer::toPathValue($supplier_warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdate
     *
     * Updates a supplier warehouse for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  string $supplier_id supplier_id (required)
     * @param  string $supplier_warehouse_id supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse default_warehouse (optional)
     * @param  double $home_suppliers_cost home_suppliers_cost (optional)
     * @param  double $suppliers_cost suppliers_cost (optional)
     * @param  double $suppliers_cost2 suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 home_suppliers_cost2 (optional)
     * @param  double $supplier_soh supplier_soh (optional)
     * @param  int $delivery_days delivery_days (optional)
     * @param  double $spare_float1 spare_float1 (optional)
     * @param  double $spare_float2 spare_float2 (optional)
     * @param  double $spare_float3 spare_float3 (optional)
     * @param  \DateTime $spare_date1 spare_date1 (optional)
     * @param  \DateTime $spare_date2 spare_date2 (optional)
     * @param  \DateTime $spare_date3 spare_date3 (optional)
     * @param  string $creditor_warehouse_id creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description creditor_warehouse_description (optional)
     * @param  string $spare_string1 spare_string1 (optional)
     * @param  string $spare_string2 spare_string2 (optional)
     * @param  string $spare_string3 spare_string3 (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $unit_of_measure unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySupplierWarehouse
     */
    public function inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdate($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        list($response) = $this->inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure, $body);
        return $response;
    }

    /**
     * Operation inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateWithHttpInfo
     *
     * Updates a supplier warehouse for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySupplierWarehouse, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplierWarehouse';
        $request = $this->inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateAsync
     *
     * Updates a supplier warehouse for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateAsync($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        return $this->inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateAsyncWithHttpInfo
     *
     * Updates a supplier warehouse for an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplierWarehouse';
        $request = $this->inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  string $supplier_warehouse_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdateRequest($accept, $inventory_id, $region_name, $supplier_id, $supplier_warehouse_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdate'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdate'
            );
        }
        // verify the required parameter 'supplier_id' is set
        if ($supplier_id === null || (is_array($supplier_id) && count($supplier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_id when calling inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdate'
            );
        }
        // verify the required parameter 'supplier_warehouse_id' is set
        if ($supplier_warehouse_id === null || (is_array($supplier_warehouse_id) && count($supplier_warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_warehouse_id when calling inventorySupplierWarehousePATCHRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesSupplierWarehouseIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers/{SupplierID}/SupplierWarehouses/{SupplierWarehouseID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_warehouse !== null) {
            $queryParams['DefaultWarehouse'] = ObjectSerializer::toQueryValue($default_warehouse);
        }
        // query params
        if ($home_suppliers_cost !== null) {
            $queryParams['HomeSuppliersCost'] = ObjectSerializer::toQueryValue($home_suppliers_cost);
        }
        // query params
        if ($suppliers_cost !== null) {
            $queryParams['SuppliersCost'] = ObjectSerializer::toQueryValue($suppliers_cost);
        }
        // query params
        if ($suppliers_cost2 !== null) {
            $queryParams['SuppliersCost2'] = ObjectSerializer::toQueryValue($suppliers_cost2);
        }
        // query params
        if ($home_suppliers_cost2 !== null) {
            $queryParams['HomeSuppliersCost2'] = ObjectSerializer::toQueryValue($home_suppliers_cost2);
        }
        // query params
        if ($supplier_soh !== null) {
            $queryParams['SupplierSOH'] = ObjectSerializer::toQueryValue($supplier_soh);
        }
        // query params
        if ($delivery_days !== null) {
            $queryParams['DeliveryDays'] = ObjectSerializer::toQueryValue($delivery_days);
        }
        // query params
        if ($spare_float1 !== null) {
            $queryParams['SpareFloat1'] = ObjectSerializer::toQueryValue($spare_float1);
        }
        // query params
        if ($spare_float2 !== null) {
            $queryParams['SpareFloat2'] = ObjectSerializer::toQueryValue($spare_float2);
        }
        // query params
        if ($spare_float3 !== null) {
            $queryParams['SpareFloat3'] = ObjectSerializer::toQueryValue($spare_float3);
        }
        // query params
        if ($spare_date1 !== null) {
            $queryParams['SpareDate1'] = ObjectSerializer::toQueryValue($spare_date1);
        }
        // query params
        if ($spare_date2 !== null) {
            $queryParams['SpareDate2'] = ObjectSerializer::toQueryValue($spare_date2);
        }
        // query params
        if ($spare_date3 !== null) {
            $queryParams['SpareDate3'] = ObjectSerializer::toQueryValue($spare_date3);
        }
        // query params
        if ($creditor_warehouse_id !== null) {
            $queryParams['CreditorWarehouseID'] = ObjectSerializer::toQueryValue($creditor_warehouse_id);
        }
        // query params
        if ($creditor_warehouse_description !== null) {
            $queryParams['CreditorWarehouseDescription'] = ObjectSerializer::toQueryValue($creditor_warehouse_description);
        }
        // query params
        if ($spare_string1 !== null) {
            $queryParams['SpareString1'] = ObjectSerializer::toQueryValue($spare_string1);
        }
        // query params
        if ($spare_string2 !== null) {
            $queryParams['SpareString2'] = ObjectSerializer::toQueryValue($spare_string2);
        }
        // query params
        if ($spare_string3 !== null) {
            $queryParams['SpareString3'] = ObjectSerializer::toQueryValue($spare_string3);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($unit_of_measure !== null) {
            $queryParams['UnitOfMeasure'] = ObjectSerializer::toQueryValue($unit_of_measure);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }
        // path params
        if ($supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierID' . '}',
                ObjectSerializer::toPathValue($supplier_id),
                $resourcePath
            );
        }
        // path params
        if ($supplier_warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierWarehouseID' . '}',
                ObjectSerializer::toPathValue($supplier_warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPost
     *
     * Appends a supplier warehouse to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  string $supplier_id supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse default_warehouse (optional)
     * @param  double $home_suppliers_cost home_suppliers_cost (optional)
     * @param  double $suppliers_cost suppliers_cost (optional)
     * @param  double $suppliers_cost2 suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 home_suppliers_cost2 (optional)
     * @param  double $supplier_soh supplier_soh (optional)
     * @param  int $delivery_days delivery_days (optional)
     * @param  double $spare_float1 spare_float1 (optional)
     * @param  double $spare_float2 spare_float2 (optional)
     * @param  double $spare_float3 spare_float3 (optional)
     * @param  \DateTime $spare_date1 spare_date1 (optional)
     * @param  \DateTime $spare_date2 spare_date2 (optional)
     * @param  \DateTime $spare_date3 spare_date3 (optional)
     * @param  string $creditor_warehouse_id creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description creditor_warehouse_description (optional)
     * @param  string $spare_string1 spare_string1 (optional)
     * @param  string $spare_string2 spare_string2 (optional)
     * @param  string $spare_string3 spare_string3 (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $unit_of_measure unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySupplierWarehouse
     */
    public function inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPost($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        list($response) = $this->inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure, $body);
        return $response;
    }

    /**
     * Operation inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostWithHttpInfo
     *
     * Appends a supplier warehouse to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySupplierWarehouse, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplierWarehouse';
        $request = $this->inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostAsync
     *
     * Appends a supplier warehouse to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostAsync($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        return $this->inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostAsyncWithHttpInfo
     *
     * Appends a supplier warehouse to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplierWarehouse';
        $request = $this->inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful, $default_warehouse, $home_suppliers_cost, $suppliers_cost, $suppliers_cost2, $home_suppliers_cost2, $supplier_soh, $delivery_days, $spare_float1, $spare_float2, $spare_float3, $spare_date1, $spare_date2, $spare_date3, $creditor_warehouse_id, $creditor_warehouse_description, $spare_string1, $spare_string2, $spare_string3, $custom_field_values, $unit_of_measure, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_warehouse (optional)
     * @param  double $home_suppliers_cost (optional)
     * @param  double $suppliers_cost (optional)
     * @param  double $suppliers_cost2 (optional)
     * @param  double $home_suppliers_cost2 (optional)
     * @param  double $supplier_soh (optional)
     * @param  int $delivery_days (optional)
     * @param  double $spare_float1 (optional)
     * @param  double $spare_float2 (optional)
     * @param  double $spare_float3 (optional)
     * @param  \DateTime $spare_date1 (optional)
     * @param  \DateTime $spare_date2 (optional)
     * @param  \DateTime $spare_date3 (optional)
     * @param  string $creditor_warehouse_id (optional)
     * @param  string $creditor_warehouse_description (optional)
     * @param  string $spare_string1 (optional)
     * @param  string $spare_string2 (optional)
     * @param  string $spare_string3 (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $unit_of_measure (optional)
     * @param  \Jiwa\JiwaModel\InventorySupplierWarehousePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPostRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null, $default_warehouse = null, $home_suppliers_cost = null, $suppliers_cost = null, $suppliers_cost2 = null, $home_suppliers_cost2 = null, $supplier_soh = null, $delivery_days = null, $spare_float1 = null, $spare_float2 = null, $spare_float3 = null, $spare_date1 = null, $spare_date2 = null, $spare_date3 = null, $creditor_warehouse_id = null, $creditor_warehouse_description = null, $spare_string1 = null, $spare_string2 = null, $spare_string3 = null, $custom_field_values = null, $unit_of_measure = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPost'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPost'
            );
        }
        // verify the required parameter 'supplier_id' is set
        if ($supplier_id === null || (is_array($supplier_id) && count($supplier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_id when calling inventorySupplierWarehousePOSTRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers/{SupplierID}/SupplierWarehouses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_warehouse !== null) {
            $queryParams['DefaultWarehouse'] = ObjectSerializer::toQueryValue($default_warehouse);
        }
        // query params
        if ($home_suppliers_cost !== null) {
            $queryParams['HomeSuppliersCost'] = ObjectSerializer::toQueryValue($home_suppliers_cost);
        }
        // query params
        if ($suppliers_cost !== null) {
            $queryParams['SuppliersCost'] = ObjectSerializer::toQueryValue($suppliers_cost);
        }
        // query params
        if ($suppliers_cost2 !== null) {
            $queryParams['SuppliersCost2'] = ObjectSerializer::toQueryValue($suppliers_cost2);
        }
        // query params
        if ($home_suppliers_cost2 !== null) {
            $queryParams['HomeSuppliersCost2'] = ObjectSerializer::toQueryValue($home_suppliers_cost2);
        }
        // query params
        if ($supplier_soh !== null) {
            $queryParams['SupplierSOH'] = ObjectSerializer::toQueryValue($supplier_soh);
        }
        // query params
        if ($delivery_days !== null) {
            $queryParams['DeliveryDays'] = ObjectSerializer::toQueryValue($delivery_days);
        }
        // query params
        if ($spare_float1 !== null) {
            $queryParams['SpareFloat1'] = ObjectSerializer::toQueryValue($spare_float1);
        }
        // query params
        if ($spare_float2 !== null) {
            $queryParams['SpareFloat2'] = ObjectSerializer::toQueryValue($spare_float2);
        }
        // query params
        if ($spare_float3 !== null) {
            $queryParams['SpareFloat3'] = ObjectSerializer::toQueryValue($spare_float3);
        }
        // query params
        if ($spare_date1 !== null) {
            $queryParams['SpareDate1'] = ObjectSerializer::toQueryValue($spare_date1);
        }
        // query params
        if ($spare_date2 !== null) {
            $queryParams['SpareDate2'] = ObjectSerializer::toQueryValue($spare_date2);
        }
        // query params
        if ($spare_date3 !== null) {
            $queryParams['SpareDate3'] = ObjectSerializer::toQueryValue($spare_date3);
        }
        // query params
        if ($creditor_warehouse_id !== null) {
            $queryParams['CreditorWarehouseID'] = ObjectSerializer::toQueryValue($creditor_warehouse_id);
        }
        // query params
        if ($creditor_warehouse_description !== null) {
            $queryParams['CreditorWarehouseDescription'] = ObjectSerializer::toQueryValue($creditor_warehouse_description);
        }
        // query params
        if ($spare_string1 !== null) {
            $queryParams['SpareString1'] = ObjectSerializer::toQueryValue($spare_string1);
        }
        // query params
        if ($spare_string2 !== null) {
            $queryParams['SpareString2'] = ObjectSerializer::toQueryValue($spare_string2);
        }
        // query params
        if ($spare_string3 !== null) {
            $queryParams['SpareString3'] = ObjectSerializer::toQueryValue($spare_string3);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($unit_of_measure !== null) {
            $queryParams['UnitOfMeasure'] = ObjectSerializer::toQueryValue($unit_of_measure);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }
        // path params
        if ($supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierID' . '}',
                ObjectSerializer::toPathValue($supplier_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGet
     *
     * Retrieves a list of inventory supplier warehouses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  string $supplier_id supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySupplierWarehouse[]
     */
    public function inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGet($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetWithHttpInfo
     *
     * Retrieves a list of inventory supplier warehouses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySupplierWarehouse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplierWarehouse[]';
        $request = $this->inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplierWarehouse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetAsync
     *
     * Retrieves a list of inventory supplier warehouses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetAsync($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        return $this->inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory supplier warehouses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplierWarehouse[]';
        $request = $this->inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  string $supplier_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGetRequest($accept, $inventory_id, $region_name, $supplier_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGet'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGet'
            );
        }
        // verify the required parameter 'supplier_id' is set
        if ($supplier_id === null || (is_array($supplier_id) && count($supplier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_id when calling inventorySupplierWarehousesGETManyRequestInventoryIDRegionsRegionNameSuppliersSupplierIDSupplierWarehousesGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers/{SupplierID}/SupplierWarehouses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }
        // path params
        if ($supplier_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SupplierID' . '}',
                ObjectSerializer::toPathValue($supplier_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGet
     *
     * Retrieves a list of suppliers for a given inventory item in a particular region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $region_name region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventorySupplier[]
     */
    public function inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGet($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        list($response) = $this->inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetWithHttpInfo
     *
     * Retrieves a list of suppliers for a given inventory item in a particular region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventorySupplier[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplier[]';
        $request = $this->inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetRequest($accept, $inventory_id, $region_name, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventorySupplier[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetAsync
     *
     * Retrieves a list of suppliers for a given inventory item in a particular region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetAsync($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        return $this->inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetAsyncWithHttpInfo
     *
     * Retrieves a list of suppliers for a given inventory item in a particular region.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetAsyncWithHttpInfo($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventorySupplier[]';
        $request = $this->inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetRequest($accept, $inventory_id, $region_name, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $region_name (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGetRequest($accept, $inventory_id, $region_name, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGet'
            );
        }
        // verify the required parameter 'region_name' is set
        if ($region_name === null || (is_array($region_name) && count($region_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region_name when calling inventorySuppliersGETManyRequestInventoryIDRegionsRegionNameSuppliersGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/Regions/{RegionName}/Suppliers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($region_name !== null) {
            $resourcePath = str_replace(
                '{' . 'RegionName' . '}',
                ObjectSerializer::toPathValue($region_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDelete
     *
     * Deletes a inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $unit_of_measure_id unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id rec_id (optional)
     * @param  string $inner_unit_of_measure inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell is_sell (optional)
     * @param  bool $is_purchase is_purchase (optional)
     * @param  int $item_no item_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $name name (optional)
     * @param  string $part_no part_no (optional)
     * @param  string $barcode barcode (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDelete($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null)
    {
        list($response) = $this->inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode);
        return $response;
    }

    /**
     * Operation inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteWithHttpInfo
     *
     * Deletes a inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteAsync
     *
     * Deletes a inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteAsync($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null)
    {
        return $this->inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteAsyncWithHttpInfo
     *
     * Deletes a inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDeleteRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDelete'
            );
        }
        // verify the required parameter 'unit_of_measure_id' is set
        if ($unit_of_measure_id === null || (is_array($unit_of_measure_id) && count($unit_of_measure_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unit_of_measure_id when calling inventoryUnitOfMeasureDELETERequestInventoryIDUnitOfMeasuresUnitOfMeasureIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UnitOfMeasures/{UnitOfMeasureID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($rec_id !== null) {
            $queryParams['RecID'] = ObjectSerializer::toQueryValue($rec_id);
        }
        // query params
        if ($inner_unit_of_measure !== null) {
            $queryParams['InnerUnitOfMeasure'] = ObjectSerializer::toQueryValue($inner_unit_of_measure);
        }
        // query params
        if ($quantity_inners_per_unit_of_measure !== null) {
            $queryParams['QuantityInnersPerUnitOfMeasure'] = ObjectSerializer::toQueryValue($quantity_inners_per_unit_of_measure);
        }
        // query params
        if ($is_sell !== null) {
            $queryParams['IsSell'] = ObjectSerializer::toQueryValue($is_sell);
        }
        // query params
        if ($is_purchase !== null) {
            $queryParams['IsPurchase'] = ObjectSerializer::toQueryValue($is_purchase);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($part_no !== null) {
            $queryParams['PartNo'] = ObjectSerializer::toQueryValue($part_no);
        }
        // query params
        if ($barcode !== null) {
            $queryParams['Barcode'] = ObjectSerializer::toQueryValue($barcode);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($unit_of_measure_id !== null) {
            $resourcePath = str_replace(
                '{' . 'UnitOfMeasureID' . '}',
                ObjectSerializer::toPathValue($unit_of_measure_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGet
     *
     * Retrieves an inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $unit_of_measure_id unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryUnitOfMeasure
     */
    public function inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGet($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetWithHttpInfo
     *
     * Retrieves an inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryUnitOfMeasure, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUnitOfMeasure';
        $request = $this->inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetAsync
     *
     * Retrieves an inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetAsync($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null)
    {
        return $this->inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetAsyncWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetAsyncWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUnitOfMeasure';
        $request = $this->inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGetRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGet'
            );
        }
        // verify the required parameter 'unit_of_measure_id' is set
        if ($unit_of_measure_id === null || (is_array($unit_of_measure_id) && count($unit_of_measure_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unit_of_measure_id when calling inventoryUnitOfMeasureGETRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UnitOfMeasures/{UnitOfMeasureID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($unit_of_measure_id !== null) {
            $resourcePath = str_replace(
                '{' . 'UnitOfMeasureID' . '}',
                ObjectSerializer::toPathValue($unit_of_measure_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdate
     *
     * Updates a inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $unit_of_measure_id unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id rec_id (optional)
     * @param  string $inner_unit_of_measure inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell is_sell (optional)
     * @param  bool $is_purchase is_purchase (optional)
     * @param  int $item_no item_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $name name (optional)
     * @param  string $part_no part_no (optional)
     * @param  string $barcode barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryUnitOfMeasure
     */
    public function inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdate($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        list($response) = $this->inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode, $body);
        return $response;
    }

    /**
     * Operation inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateWithHttpInfo
     *
     * Updates a inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryUnitOfMeasure, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUnitOfMeasure';
        $request = $this->inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateAsync
     *
     * Updates a inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateAsync($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        return $this->inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateAsyncWithHttpInfo
     *
     * Updates a inventory unit of measure.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUnitOfMeasure';
        $request = $this->inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $unit_of_measure_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdateRequest($accept, $inventory_id, $unit_of_measure_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdate'
            );
        }
        // verify the required parameter 'unit_of_measure_id' is set
        if ($unit_of_measure_id === null || (is_array($unit_of_measure_id) && count($unit_of_measure_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unit_of_measure_id when calling inventoryUnitOfMeasurePATCHRequestInventoryIDUnitOfMeasuresUnitOfMeasureIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UnitOfMeasures/{UnitOfMeasureID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($rec_id !== null) {
            $queryParams['RecID'] = ObjectSerializer::toQueryValue($rec_id);
        }
        // query params
        if ($inner_unit_of_measure !== null) {
            $queryParams['InnerUnitOfMeasure'] = ObjectSerializer::toQueryValue($inner_unit_of_measure);
        }
        // query params
        if ($quantity_inners_per_unit_of_measure !== null) {
            $queryParams['QuantityInnersPerUnitOfMeasure'] = ObjectSerializer::toQueryValue($quantity_inners_per_unit_of_measure);
        }
        // query params
        if ($is_sell !== null) {
            $queryParams['IsSell'] = ObjectSerializer::toQueryValue($is_sell);
        }
        // query params
        if ($is_purchase !== null) {
            $queryParams['IsPurchase'] = ObjectSerializer::toQueryValue($is_purchase);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($part_no !== null) {
            $queryParams['PartNo'] = ObjectSerializer::toQueryValue($part_no);
        }
        // query params
        if ($barcode !== null) {
            $queryParams['Barcode'] = ObjectSerializer::toQueryValue($barcode);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($unit_of_measure_id !== null) {
            $resourcePath = str_replace(
                '{' . 'UnitOfMeasureID' . '}',
                ObjectSerializer::toPathValue($unit_of_measure_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPost
     *
     * Appends an alternate child to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id rec_id (optional)
     * @param  string $inner_unit_of_measure inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell is_sell (optional)
     * @param  bool $is_purchase is_purchase (optional)
     * @param  int $item_no item_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $name name (optional)
     * @param  string $part_no part_no (optional)
     * @param  string $barcode barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryUnitOfMeasure
     */
    public function inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPost($accept, $inventory_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        list($response) = $this->inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode, $body);
        return $response;
    }

    /**
     * Operation inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostWithHttpInfo
     *
     * Appends an alternate child to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryUnitOfMeasure, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUnitOfMeasure';
        $request = $this->inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostRequest($accept, $inventory_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostAsync
     *
     * Appends an alternate child to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostAsync($accept, $inventory_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        return $this->inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostAsyncWithHttpInfo
     *
     * Appends an alternate child to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUnitOfMeasure';
        $request = $this->inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostRequest($accept, $inventory_id, $jiwa_stateful, $rec_id, $inner_unit_of_measure, $quantity_inners_per_unit_of_measure, $is_sell, $is_purchase, $item_no, $last_saved_date_time, $name, $part_no, $barcode, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $rec_id (optional)
     * @param  string $inner_unit_of_measure (optional)
     * @param  double $quantity_inners_per_unit_of_measure (optional)
     * @param  bool $is_sell (optional)
     * @param  bool $is_purchase (optional)
     * @param  int $item_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $name (optional)
     * @param  string $part_no (optional)
     * @param  string $barcode (optional)
     * @param  \Jiwa\JiwaModel\InventoryUnitOfMeasurePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPostRequest($accept, $inventory_id, $jiwa_stateful = null, $rec_id = null, $inner_unit_of_measure = null, $quantity_inners_per_unit_of_measure = null, $is_sell = null, $is_purchase = null, $item_no = null, $last_saved_date_time = null, $name = null, $part_no = null, $barcode = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUnitOfMeasurePOSTRequestInventoryIDUnitOfMeasuresPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UnitOfMeasures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($rec_id !== null) {
            $queryParams['RecID'] = ObjectSerializer::toQueryValue($rec_id);
        }
        // query params
        if ($inner_unit_of_measure !== null) {
            $queryParams['InnerUnitOfMeasure'] = ObjectSerializer::toQueryValue($inner_unit_of_measure);
        }
        // query params
        if ($quantity_inners_per_unit_of_measure !== null) {
            $queryParams['QuantityInnersPerUnitOfMeasure'] = ObjectSerializer::toQueryValue($quantity_inners_per_unit_of_measure);
        }
        // query params
        if ($is_sell !== null) {
            $queryParams['IsSell'] = ObjectSerializer::toQueryValue($is_sell);
        }
        // query params
        if ($is_purchase !== null) {
            $queryParams['IsPurchase'] = ObjectSerializer::toQueryValue($is_purchase);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($part_no !== null) {
            $queryParams['PartNo'] = ObjectSerializer::toQueryValue($part_no);
        }
        // query params
        if ($barcode !== null) {
            $queryParams['Barcode'] = ObjectSerializer::toQueryValue($barcode);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGet
     *
     * Retrieves a list of inventory unit of measures.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryUnitOfMeasure[]
     */
    public function inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetWithHttpInfo
     *
     * Retrieves a list of inventory unit of measures.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryUnitOfMeasure[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUnitOfMeasure[]';
        $request = $this->inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUnitOfMeasure[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetAsync
     *
     * Retrieves a list of inventory unit of measures.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory unit of measures.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUnitOfMeasure[]';
        $request = $this->inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUnitOfMeasuresGETManyRequestInventoryIDUnitOfMeasuresGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UnitOfMeasures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDelete
     *
     * Deletes a inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $up_sell_id up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description up_sell_inventory_description (optional)
     * @param  string $up_sell_description up_sell_description (optional)
     * @param  string $primary_category_id primary_category_id (optional)
     * @param  string $primary_category_description primary_category_description (optional)
     * @param  int $primary_category_no primary_category_no (optional)
     * @param  string $secondary_category_id secondary_category_id (optional)
     * @param  string $secondary_category_description secondary_category_description (optional)
     * @param  int $secondary_category_no secondary_category_no (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\Object
     */
    public function inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDelete($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null)
    {
        list($response) = $this->inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no);
        return $response;
    }

    /**
     * Operation inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteWithHttpInfo
     *
     * Deletes a inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteAsync
     *
     * Deletes a inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteAsync($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null)
    {
        return $this->inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteAsyncWithHttpInfo
     *
     * Deletes a inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteAsyncWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null)
    {
        $returnType = '\Jiwa\JiwaModel\Object';
        $request = $this->inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDeleteRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDelete'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDelete'
            );
        }
        // verify the required parameter 'up_sell_id' is set
        if ($up_sell_id === null || (is_array($up_sell_id) && count($up_sell_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $up_sell_id when calling inventoryUpSellDELETERequestInventoryIDUpSellsUpSellIDDelete'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UpSells/{UpSellID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($up_sell_quantity !== null) {
            $queryParams['UpSellQuantity'] = ObjectSerializer::toQueryValue($up_sell_quantity);
        }
        // query params
        if ($up_sell_inventory_id !== null) {
            $queryParams['UpSellInventoryID'] = ObjectSerializer::toQueryValue($up_sell_inventory_id);
        }
        // query params
        if ($up_sell_inventory_part_no !== null) {
            $queryParams['UpSellInventoryPartNo'] = ObjectSerializer::toQueryValue($up_sell_inventory_part_no);
        }
        // query params
        if ($up_sell_inventory_description !== null) {
            $queryParams['UpSellInventoryDescription'] = ObjectSerializer::toQueryValue($up_sell_inventory_description);
        }
        // query params
        if ($up_sell_description !== null) {
            $queryParams['UpSellDescription'] = ObjectSerializer::toQueryValue($up_sell_description);
        }
        // query params
        if ($primary_category_id !== null) {
            $queryParams['PrimaryCategoryID'] = ObjectSerializer::toQueryValue($primary_category_id);
        }
        // query params
        if ($primary_category_description !== null) {
            $queryParams['PrimaryCategoryDescription'] = ObjectSerializer::toQueryValue($primary_category_description);
        }
        // query params
        if ($primary_category_no !== null) {
            $queryParams['PrimaryCategoryNo'] = ObjectSerializer::toQueryValue($primary_category_no);
        }
        // query params
        if ($secondary_category_id !== null) {
            $queryParams['SecondaryCategoryID'] = ObjectSerializer::toQueryValue($secondary_category_id);
        }
        // query params
        if ($secondary_category_description !== null) {
            $queryParams['SecondaryCategoryDescription'] = ObjectSerializer::toQueryValue($secondary_category_description);
        }
        // query params
        if ($secondary_category_no !== null) {
            $queryParams['SecondaryCategoryNo'] = ObjectSerializer::toQueryValue($secondary_category_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($up_sell_id !== null) {
            $resourcePath = str_replace(
                '{' . 'UpSellID' . '}',
                ObjectSerializer::toPathValue($up_sell_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGet
     *
     * Retrieves an inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $up_sell_id up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryUpSell
     */
    public function inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGet($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetWithHttpInfo
     *
     * Retrieves an inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryUpSell, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUpSell';
        $request = $this->inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetAsync
     *
     * Retrieves an inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetAsync($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null)
    {
        return $this->inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetAsyncWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetAsyncWithHttpInfo
     *
     * Retrieves an inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetAsyncWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUpSell';
        $request = $this->inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGetRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGet'
            );
        }
        // verify the required parameter 'up_sell_id' is set
        if ($up_sell_id === null || (is_array($up_sell_id) && count($up_sell_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $up_sell_id when calling inventoryUpSellGETRequestInventoryIDUpSellsUpSellIDGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UpSells/{UpSellID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($up_sell_id !== null) {
            $resourcePath = str_replace(
                '{' . 'UpSellID' . '}',
                ObjectSerializer::toPathValue($up_sell_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdate
     *
     * Updates a inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  string $up_sell_id up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description up_sell_inventory_description (optional)
     * @param  string $up_sell_description up_sell_description (optional)
     * @param  string $primary_category_id primary_category_id (optional)
     * @param  string $primary_category_description primary_category_description (optional)
     * @param  int $primary_category_no primary_category_no (optional)
     * @param  string $secondary_category_id secondary_category_id (optional)
     * @param  string $secondary_category_description secondary_category_description (optional)
     * @param  int $secondary_category_no secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryUpSell
     */
    public function inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdate($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        list($response) = $this->inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no, $body);
        return $response;
    }

    /**
     * Operation inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateWithHttpInfo
     *
     * Updates a inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryUpSell, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUpSell';
        $request = $this->inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateAsync
     *
     * Updates a inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateAsync($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        return $this->inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateAsyncWithHttpInfo
     *
     * Updates a inventory up sell.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateAsyncWithHttpInfo($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUpSell';
        $request = $this->inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  string $up_sell_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdateRequest($accept, $inventory_id, $up_sell_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdate'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdate'
            );
        }
        // verify the required parameter 'up_sell_id' is set
        if ($up_sell_id === null || (is_array($up_sell_id) && count($up_sell_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $up_sell_id when calling inventoryUpSellPATCHRequestInventoryIDUpSellsUpSellIDUpdate'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UpSells/{UpSellID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($up_sell_quantity !== null) {
            $queryParams['UpSellQuantity'] = ObjectSerializer::toQueryValue($up_sell_quantity);
        }
        // query params
        if ($up_sell_inventory_id !== null) {
            $queryParams['UpSellInventoryID'] = ObjectSerializer::toQueryValue($up_sell_inventory_id);
        }
        // query params
        if ($up_sell_inventory_part_no !== null) {
            $queryParams['UpSellInventoryPartNo'] = ObjectSerializer::toQueryValue($up_sell_inventory_part_no);
        }
        // query params
        if ($up_sell_inventory_description !== null) {
            $queryParams['UpSellInventoryDescription'] = ObjectSerializer::toQueryValue($up_sell_inventory_description);
        }
        // query params
        if ($up_sell_description !== null) {
            $queryParams['UpSellDescription'] = ObjectSerializer::toQueryValue($up_sell_description);
        }
        // query params
        if ($primary_category_id !== null) {
            $queryParams['PrimaryCategoryID'] = ObjectSerializer::toQueryValue($primary_category_id);
        }
        // query params
        if ($primary_category_description !== null) {
            $queryParams['PrimaryCategoryDescription'] = ObjectSerializer::toQueryValue($primary_category_description);
        }
        // query params
        if ($primary_category_no !== null) {
            $queryParams['PrimaryCategoryNo'] = ObjectSerializer::toQueryValue($primary_category_no);
        }
        // query params
        if ($secondary_category_id !== null) {
            $queryParams['SecondaryCategoryID'] = ObjectSerializer::toQueryValue($secondary_category_id);
        }
        // query params
        if ($secondary_category_description !== null) {
            $queryParams['SecondaryCategoryDescription'] = ObjectSerializer::toQueryValue($secondary_category_description);
        }
        // query params
        if ($secondary_category_no !== null) {
            $queryParams['SecondaryCategoryNo'] = ObjectSerializer::toQueryValue($secondary_category_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }
        // path params
        if ($up_sell_id !== null) {
            $resourcePath = str_replace(
                '{' . 'UpSellID' . '}',
                ObjectSerializer::toPathValue($up_sell_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUpSellPOSTRequestInventoryIDUpSellsPost
     *
     * Appends an up sell to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description up_sell_inventory_description (optional)
     * @param  string $up_sell_description up_sell_description (optional)
     * @param  string $primary_category_id primary_category_id (optional)
     * @param  string $primary_category_description primary_category_description (optional)
     * @param  int $primary_category_no primary_category_no (optional)
     * @param  string $secondary_category_id secondary_category_id (optional)
     * @param  string $secondary_category_description secondary_category_description (optional)
     * @param  int $secondary_category_no secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryUpSell
     */
    public function inventoryUpSellPOSTRequestInventoryIDUpSellsPost($accept, $inventory_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        list($response) = $this->inventoryUpSellPOSTRequestInventoryIDUpSellsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no, $body);
        return $response;
    }

    /**
     * Operation inventoryUpSellPOSTRequestInventoryIDUpSellsPostWithHttpInfo
     *
     * Appends an up sell to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryUpSell, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUpSellPOSTRequestInventoryIDUpSellsPostWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUpSell';
        $request = $this->inventoryUpSellPOSTRequestInventoryIDUpSellsPostRequest($accept, $inventory_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUpSellPOSTRequestInventoryIDUpSellsPostAsync
     *
     * Appends an up sell to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellPOSTRequestInventoryIDUpSellsPostAsync($accept, $inventory_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        return $this->inventoryUpSellPOSTRequestInventoryIDUpSellsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUpSellPOSTRequestInventoryIDUpSellsPostAsyncWithHttpInfo
     *
     * Appends an up sell to an inventory item.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellPOSTRequestInventoryIDUpSellsPostAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUpSell';
        $request = $this->inventoryUpSellPOSTRequestInventoryIDUpSellsPostRequest($accept, $inventory_id, $jiwa_stateful, $up_sell_quantity, $up_sell_inventory_id, $up_sell_inventory_part_no, $up_sell_inventory_description, $up_sell_description, $primary_category_id, $primary_category_description, $primary_category_no, $secondary_category_id, $secondary_category_description, $secondary_category_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUpSellPOSTRequestInventoryIDUpSellsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $up_sell_quantity (optional)
     * @param  string $up_sell_inventory_id (optional)
     * @param  string $up_sell_inventory_part_no (optional)
     * @param  string $up_sell_inventory_description (optional)
     * @param  string $up_sell_description (optional)
     * @param  string $primary_category_id (optional)
     * @param  string $primary_category_description (optional)
     * @param  int $primary_category_no (optional)
     * @param  string $secondary_category_id (optional)
     * @param  string $secondary_category_description (optional)
     * @param  int $secondary_category_no (optional)
     * @param  \Jiwa\JiwaModel\InventoryUpSellPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUpSellPOSTRequestInventoryIDUpSellsPostRequest($accept, $inventory_id, $jiwa_stateful = null, $up_sell_quantity = null, $up_sell_inventory_id = null, $up_sell_inventory_part_no = null, $up_sell_inventory_description = null, $up_sell_description = null, $primary_category_id = null, $primary_category_description = null, $primary_category_no = null, $secondary_category_id = null, $secondary_category_description = null, $secondary_category_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUpSellPOSTRequestInventoryIDUpSellsPost'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUpSellPOSTRequestInventoryIDUpSellsPost'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UpSells';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($up_sell_quantity !== null) {
            $queryParams['UpSellQuantity'] = ObjectSerializer::toQueryValue($up_sell_quantity);
        }
        // query params
        if ($up_sell_inventory_id !== null) {
            $queryParams['UpSellInventoryID'] = ObjectSerializer::toQueryValue($up_sell_inventory_id);
        }
        // query params
        if ($up_sell_inventory_part_no !== null) {
            $queryParams['UpSellInventoryPartNo'] = ObjectSerializer::toQueryValue($up_sell_inventory_part_no);
        }
        // query params
        if ($up_sell_inventory_description !== null) {
            $queryParams['UpSellInventoryDescription'] = ObjectSerializer::toQueryValue($up_sell_inventory_description);
        }
        // query params
        if ($up_sell_description !== null) {
            $queryParams['UpSellDescription'] = ObjectSerializer::toQueryValue($up_sell_description);
        }
        // query params
        if ($primary_category_id !== null) {
            $queryParams['PrimaryCategoryID'] = ObjectSerializer::toQueryValue($primary_category_id);
        }
        // query params
        if ($primary_category_description !== null) {
            $queryParams['PrimaryCategoryDescription'] = ObjectSerializer::toQueryValue($primary_category_description);
        }
        // query params
        if ($primary_category_no !== null) {
            $queryParams['PrimaryCategoryNo'] = ObjectSerializer::toQueryValue($primary_category_no);
        }
        // query params
        if ($secondary_category_id !== null) {
            $queryParams['SecondaryCategoryID'] = ObjectSerializer::toQueryValue($secondary_category_id);
        }
        // query params
        if ($secondary_category_description !== null) {
            $queryParams['SecondaryCategoryDescription'] = ObjectSerializer::toQueryValue($secondary_category_description);
        }
        // query params
        if ($secondary_category_no !== null) {
            $queryParams['SecondaryCategoryNo'] = ObjectSerializer::toQueryValue($secondary_category_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUpSellsGETManyRequestInventoryIDUpSellsGet
     *
     * Retrieves a list of inventory up sells.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\JiwaModel\InventoryUpSell[]
     */
    public function inventoryUpSellsGETManyRequestInventoryIDUpSellsGet($accept, $inventory_id, $jiwa_stateful = null)
    {
        list($response) = $this->inventoryUpSellsGETManyRequestInventoryIDUpSellsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation inventoryUpSellsGETManyRequestInventoryIDUpSellsGetWithHttpInfo
     *
     * Retrieves a list of inventory up sells.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\JiwaModel\InventoryUpSell[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUpSellsGETManyRequestInventoryIDUpSellsGetWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUpSell[]';
        $request = $this->inventoryUpSellsGETManyRequestInventoryIDUpSellsGetRequest($accept, $inventory_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\JiwaModel\InventoryUpSell[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUpSellsGETManyRequestInventoryIDUpSellsGetAsync
     *
     * Retrieves a list of inventory up sells.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellsGETManyRequestInventoryIDUpSellsGetAsync($accept, $inventory_id, $jiwa_stateful = null)
    {
        return $this->inventoryUpSellsGETManyRequestInventoryIDUpSellsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUpSellsGETManyRequestInventoryIDUpSellsGetAsyncWithHttpInfo
     *
     * Retrieves a list of inventory up sells.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpSellsGETManyRequestInventoryIDUpSellsGetAsyncWithHttpInfo($accept, $inventory_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\JiwaModel\InventoryUpSell[]';
        $request = $this->inventoryUpSellsGETManyRequestInventoryIDUpSellsGetRequest($accept, $inventory_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUpSellsGETManyRequestInventoryIDUpSellsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $inventory_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUpSellsGETManyRequestInventoryIDUpSellsGetRequest($accept, $inventory_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling inventoryUpSellsGETManyRequestInventoryIDUpSellsGet'
            );
        }
        // verify the required parameter 'inventory_id' is set
        if ($inventory_id === null || (is_array($inventory_id) && count($inventory_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_id when calling inventoryUpSellsGETManyRequestInventoryIDUpSellsGet'
            );
        }

        $resourcePath = '/Inventory/{InventoryID}/UpSells';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($inventory_id !== null) {
            $resourcePath = str_replace(
                '{' . 'InventoryID' . '}',
                ObjectSerializer::toPathValue($inventory_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
