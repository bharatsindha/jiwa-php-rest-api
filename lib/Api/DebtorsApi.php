<?php
/**
 * DebtorsApi
 * PHP version 5
 *
 * @category Class
 * @package  Jiwa
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * JiwaAPI
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.28-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Jiwa\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Jiwa\ApiException;
use Jiwa\Configuration;
use Jiwa\HeaderSelector;
use Jiwa\ObjectSerializer;

/**
 * DebtorsApi Class Doc Comment
 *
 * @category Class
 * @package  Jiwa
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DebtorsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation debtorABANDONRequestAbandonDelete
     *
     * Abandons a stateful debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id debtor_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorABANDONRequestAbandonDelete($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        list($response) = $this->debtorABANDONRequestAbandonDeleteWithHttpInfo($accept, $jiwa_stateful, $debtor_id);
        return $response;
    }

    /**
     * Operation debtorABANDONRequestAbandonDeleteWithHttpInfo
     *
     * Abandons a stateful debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorABANDONRequestAbandonDeleteWithHttpInfo($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful, $debtor_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorABANDONRequestAbandonDeleteAsync
     *
     * Abandons a stateful debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorABANDONRequestAbandonDeleteAsync($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        return $this->debtorABANDONRequestAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful, $debtor_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorABANDONRequestAbandonDeleteAsyncWithHttpInfo
     *
     * Abandons a stateful debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorABANDONRequestAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful, $debtor_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorABANDONRequestAbandonDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorABANDONRequestAbandonDeleteRequest($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorABANDONRequestAbandonDelete'
            );
        }

        $resourcePath = '/Debtors/Abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($debtor_id !== null) {
            $queryParams['DebtorID'] = ObjectSerializer::toQueryValue($debtor_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorAPIKeyDebtorGETRequestGet
     *
     * Retrieves a debtor for a API Key authenticated customer.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Debtor
     */
    public function debtorAPIKeyDebtorGETRequestGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->debtorAPIKeyDebtorGETRequestGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorAPIKeyDebtorGETRequestGetWithHttpInfo
     *
     * Retrieves a debtor for a API Key authenticated customer.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Debtor, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorAPIKeyDebtorGETRequestGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorAPIKeyDebtorGETRequestGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorAPIKeyDebtorGETRequestGetAsync
     *
     * Retrieves a debtor for a API Key authenticated customer.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorAPIKeyDebtorGETRequestGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->debtorAPIKeyDebtorGETRequestGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorAPIKeyDebtorGETRequestGetAsyncWithHttpInfo
     *
     * Retrieves a debtor for a API Key authenticated customer.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorAPIKeyDebtorGETRequestGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorAPIKeyDebtorGETRequestGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorAPIKeyDebtorGETRequestGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorAPIKeyDebtorGETRequestGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorAPIKeyDebtorGETRequestGet'
            );
        }

        $resourcePath = '/Debtors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorBackordersGETRequestDebtorIDBackordersGet
     *
     * Retrieves a list of backorders for a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorBackOrder[]
     */
    public function debtorBackordersGETRequestDebtorIDBackordersGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorBackordersGETRequestDebtorIDBackordersGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorBackordersGETRequestDebtorIDBackordersGetWithHttpInfo
     *
     * Retrieves a list of backorders for a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorBackOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorBackordersGETRequestDebtorIDBackordersGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorBackOrder[]';
        $request = $this->debtorBackordersGETRequestDebtorIDBackordersGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorBackOrder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorBackOrder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorBackOrder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorBackOrder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorBackordersGETRequestDebtorIDBackordersGetAsync
     *
     * Retrieves a list of backorders for a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorBackordersGETRequestDebtorIDBackordersGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorBackordersGETRequestDebtorIDBackordersGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorBackordersGETRequestDebtorIDBackordersGetAsyncWithHttpInfo
     *
     * Retrieves a list of backorders for a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorBackordersGETRequestDebtorIDBackordersGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorBackOrder[]';
        $request = $this->debtorBackordersGETRequestDebtorIDBackordersGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorBackordersGETRequestDebtorIDBackordersGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorBackordersGETRequestDebtorIDBackordersGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorBackordersGETRequestDebtorIDBackordersGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorBackordersGETRequestDebtorIDBackordersGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Backorders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCategoriesABANDONRequestCategoriesAbandonDelete
     *
     * Abandons a stateful debtor categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorCategoriesABANDONRequestCategoriesAbandonDelete($accept, $jiwa_stateful = null)
    {
        list($response) = $this->debtorCategoriesABANDONRequestCategoriesAbandonDeleteWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorCategoriesABANDONRequestCategoriesAbandonDeleteWithHttpInfo
     *
     * Abandons a stateful debtor categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCategoriesABANDONRequestCategoriesAbandonDeleteWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorCategoriesABANDONRequestCategoriesAbandonDeleteRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCategoriesABANDONRequestCategoriesAbandonDeleteAsync
     *
     * Abandons a stateful debtor categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoriesABANDONRequestCategoriesAbandonDeleteAsync($accept, $jiwa_stateful = null)
    {
        return $this->debtorCategoriesABANDONRequestCategoriesAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCategoriesABANDONRequestCategoriesAbandonDeleteAsyncWithHttpInfo
     *
     * Abandons a stateful debtor categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoriesABANDONRequestCategoriesAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorCategoriesABANDONRequestCategoriesAbandonDeleteRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCategoriesABANDONRequestCategoriesAbandonDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCategoriesABANDONRequestCategoriesAbandonDeleteRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCategoriesABANDONRequestCategoriesAbandonDelete'
            );
        }

        $resourcePath = '/Debtors/Categories/Abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCategoriesSAVERequestCategoriesSaveGet
     *
     * Saves a stateful debtor categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorCategory[]
     */
    public function debtorCategoriesSAVERequestCategoriesSaveGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->debtorCategoriesSAVERequestCategoriesSaveGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorCategoriesSAVERequestCategoriesSaveGetWithHttpInfo
     *
     * Saves a stateful debtor categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorCategory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCategoriesSAVERequestCategoriesSaveGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorCategory[]';
        $request = $this->debtorCategoriesSAVERequestCategoriesSaveGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCategoriesSAVERequestCategoriesSaveGetAsync
     *
     * Saves a stateful debtor categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoriesSAVERequestCategoriesSaveGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->debtorCategoriesSAVERequestCategoriesSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCategoriesSAVERequestCategoriesSaveGetAsyncWithHttpInfo
     *
     * Saves a stateful debtor categories collection.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoriesSAVERequestCategoriesSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorCategory[]';
        $request = $this->debtorCategoriesSAVERequestCategoriesSaveGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCategoriesSAVERequestCategoriesSaveGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCategoriesSAVERequestCategoriesSaveGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCategoriesSAVERequestCategoriesSaveGet'
            );
        }

        $resourcePath = '/Debtors/Categories/Save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCategoryDELETERequestCategoriesCategoryIDDelete
     *
     * Deletes a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorCategoryDELETERequestCategoriesCategoryIDDelete($accept, $category_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorCategoryDELETERequestCategoriesCategoryIDDeleteWithHttpInfo($accept, $category_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorCategoryDELETERequestCategoriesCategoryIDDeleteWithHttpInfo
     *
     * Deletes a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCategoryDELETERequestCategoriesCategoryIDDeleteWithHttpInfo($accept, $category_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorCategoryDELETERequestCategoriesCategoryIDDeleteRequest($accept, $category_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCategoryDELETERequestCategoriesCategoryIDDeleteAsync
     *
     * Deletes a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoryDELETERequestCategoriesCategoryIDDeleteAsync($accept, $category_id, $jiwa_stateful = null)
    {
        return $this->debtorCategoryDELETERequestCategoriesCategoryIDDeleteAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCategoryDELETERequestCategoriesCategoryIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoryDELETERequestCategoriesCategoryIDDeleteAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorCategoryDELETERequestCategoriesCategoryIDDeleteRequest($accept, $category_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCategoryDELETERequestCategoriesCategoryIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCategoryDELETERequestCategoriesCategoryIDDeleteRequest($accept, $category_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCategoryDELETERequestCategoriesCategoryIDDelete'
            );
        }
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling debtorCategoryDELETERequestCategoriesCategoryIDDelete'
            );
        }

        $resourcePath = '/Debtors/Categories/{CategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'CategoryID' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCategoryGETRequestCategoriesCategoryIDGet
     *
     * Retrieves a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorCategory
     */
    public function debtorCategoryGETRequestCategoriesCategoryIDGet($accept, $category_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorCategoryGETRequestCategoriesCategoryIDGetWithHttpInfo($accept, $category_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorCategoryGETRequestCategoriesCategoryIDGetWithHttpInfo
     *
     * Retrieves a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCategoryGETRequestCategoriesCategoryIDGetWithHttpInfo($accept, $category_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorCategory';
        $request = $this->debtorCategoryGETRequestCategoriesCategoryIDGetRequest($accept, $category_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCategoryGETRequestCategoriesCategoryIDGetAsync
     *
     * Retrieves a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoryGETRequestCategoriesCategoryIDGetAsync($accept, $category_id, $jiwa_stateful = null)
    {
        return $this->debtorCategoryGETRequestCategoriesCategoryIDGetAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCategoryGETRequestCategoriesCategoryIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoryGETRequestCategoriesCategoryIDGetAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorCategory';
        $request = $this->debtorCategoryGETRequestCategoriesCategoryIDGetRequest($accept, $category_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCategoryGETRequestCategoriesCategoryIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCategoryGETRequestCategoriesCategoryIDGetRequest($accept, $category_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCategoryGETRequestCategoriesCategoryIDGet'
            );
        }
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling debtorCategoryGETRequestCategoriesCategoryIDGet'
            );
        }

        $resourcePath = '/Debtors/Categories/{CategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'CategoryID' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCategoryPATCHRequestCategoriesCategoryIDUpdate
     *
     * Updates a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  int $category_no category_no (optional)
     * @param  bool $is_default is_default (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorCategoryPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorCategory
     */
    public function debtorCategoryPATCHRequestCategoriesCategoryIDUpdate($accept, $category_id, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        list($response) = $this->debtorCategoryPATCHRequestCategoriesCategoryIDUpdateWithHttpInfo($accept, $category_id, $jiwa_stateful, $description, $category_no, $is_default, $last_saved_date_time, $body);
        return $response;
    }

    /**
     * Operation debtorCategoryPATCHRequestCategoriesCategoryIDUpdateWithHttpInfo
     *
     * Updates a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  int $category_no (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorCategoryPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCategoryPATCHRequestCategoriesCategoryIDUpdateWithHttpInfo($accept, $category_id, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorCategory';
        $request = $this->debtorCategoryPATCHRequestCategoriesCategoryIDUpdateRequest($accept, $category_id, $jiwa_stateful, $description, $category_no, $is_default, $last_saved_date_time, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCategoryPATCHRequestCategoriesCategoryIDUpdateAsync
     *
     * Updates a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  int $category_no (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorCategoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoryPATCHRequestCategoriesCategoryIDUpdateAsync($accept, $category_id, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        return $this->debtorCategoryPATCHRequestCategoriesCategoryIDUpdateAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful, $description, $category_no, $is_default, $last_saved_date_time, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCategoryPATCHRequestCategoriesCategoryIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  int $category_no (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorCategoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoryPATCHRequestCategoriesCategoryIDUpdateAsyncWithHttpInfo($accept, $category_id, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorCategory';
        $request = $this->debtorCategoryPATCHRequestCategoriesCategoryIDUpdateRequest($accept, $category_id, $jiwa_stateful, $description, $category_no, $is_default, $last_saved_date_time, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCategoryPATCHRequestCategoriesCategoryIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $category_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  int $category_no (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorCategoryPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCategoryPATCHRequestCategoriesCategoryIDUpdateRequest($accept, $category_id, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCategoryPATCHRequestCategoriesCategoryIDUpdate'
            );
        }
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling debtorCategoryPATCHRequestCategoriesCategoryIDUpdate'
            );
        }

        $resourcePath = '/Debtors/Categories/{CategoryID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($category_no !== null) {
            $queryParams['CategoryNo'] = ObjectSerializer::toQueryValue($category_no);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'CategoryID' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCategoryPOSTRequestCategoriesPost
     *
     * Creates a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  int $category_no category_no (optional)
     * @param  bool $is_default is_default (optional)
     * @param  \Jiwa\Model\DebtorCategoryPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorCategory
     */
    public function debtorCategoryPOSTRequestCategoriesPost($accept, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $body = null)
    {
        list($response) = $this->debtorCategoryPOSTRequestCategoriesPostWithHttpInfo($accept, $jiwa_stateful, $description, $category_no, $is_default, $body);
        return $response;
    }

    /**
     * Operation debtorCategoryPOSTRequestCategoriesPostWithHttpInfo
     *
     * Creates a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  int $category_no (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\Model\DebtorCategoryPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCategoryPOSTRequestCategoriesPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorCategory';
        $request = $this->debtorCategoryPOSTRequestCategoriesPostRequest($accept, $jiwa_stateful, $description, $category_no, $is_default, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCategoryPOSTRequestCategoriesPostAsync
     *
     * Creates a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  int $category_no (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\Model\DebtorCategoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoryPOSTRequestCategoriesPostAsync($accept, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $body = null)
    {
        return $this->debtorCategoryPOSTRequestCategoriesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $category_no, $is_default, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCategoryPOSTRequestCategoriesPostAsyncWithHttpInfo
     *
     * Creates a debtor category.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  int $category_no (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\Model\DebtorCategoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCategoryPOSTRequestCategoriesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorCategory';
        $request = $this->debtorCategoryPOSTRequestCategoriesPostRequest($accept, $jiwa_stateful, $description, $category_no, $is_default, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCategoryPOSTRequestCategoriesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  int $category_no (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\Model\DebtorCategoryPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCategoryPOSTRequestCategoriesPostRequest($accept, $jiwa_stateful = null, $description = null, $category_no = null, $is_default = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCategoryPOSTRequestCategoriesPost'
            );
        }

        $resourcePath = '/Debtors/Categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($category_no !== null) {
            $queryParams['CategoryNo'] = ObjectSerializer::toQueryValue($category_no);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorClassificationABANDONRequestClassificationsAbandonDelete
     *
     * Abandons a stateful debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id classification_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorClassificationABANDONRequestClassificationsAbandonDelete($accept, $jiwa_stateful = null, $classification_id = null)
    {
        list($response) = $this->debtorClassificationABANDONRequestClassificationsAbandonDeleteWithHttpInfo($accept, $jiwa_stateful, $classification_id);
        return $response;
    }

    /**
     * Operation debtorClassificationABANDONRequestClassificationsAbandonDeleteWithHttpInfo
     *
     * Abandons a stateful debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorClassificationABANDONRequestClassificationsAbandonDeleteWithHttpInfo($accept, $jiwa_stateful = null, $classification_id = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorClassificationABANDONRequestClassificationsAbandonDeleteRequest($accept, $jiwa_stateful, $classification_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorClassificationABANDONRequestClassificationsAbandonDeleteAsync
     *
     * Abandons a stateful debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationABANDONRequestClassificationsAbandonDeleteAsync($accept, $jiwa_stateful = null, $classification_id = null)
    {
        return $this->debtorClassificationABANDONRequestClassificationsAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful, $classification_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorClassificationABANDONRequestClassificationsAbandonDeleteAsyncWithHttpInfo
     *
     * Abandons a stateful debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationABANDONRequestClassificationsAbandonDeleteAsyncWithHttpInfo($accept, $jiwa_stateful = null, $classification_id = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorClassificationABANDONRequestClassificationsAbandonDeleteRequest($accept, $jiwa_stateful, $classification_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorClassificationABANDONRequestClassificationsAbandonDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorClassificationABANDONRequestClassificationsAbandonDeleteRequest($accept, $jiwa_stateful = null, $classification_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorClassificationABANDONRequestClassificationsAbandonDelete'
            );
        }

        $resourcePath = '/Debtors/Classifications/Abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($classification_id !== null) {
            $queryParams['ClassificationID'] = ObjectSerializer::toQueryValue($classification_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorClassificationDELETERequestClassificationsClassificationIDDelete
     *
     * Deletes a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorClassificationDELETERequestClassificationsClassificationIDDelete($accept, $classification_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorClassificationDELETERequestClassificationsClassificationIDDeleteWithHttpInfo($accept, $classification_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorClassificationDELETERequestClassificationsClassificationIDDeleteWithHttpInfo
     *
     * Deletes a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorClassificationDELETERequestClassificationsClassificationIDDeleteWithHttpInfo($accept, $classification_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorClassificationDELETERequestClassificationsClassificationIDDeleteRequest($accept, $classification_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorClassificationDELETERequestClassificationsClassificationIDDeleteAsync
     *
     * Deletes a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationDELETERequestClassificationsClassificationIDDeleteAsync($accept, $classification_id, $jiwa_stateful = null)
    {
        return $this->debtorClassificationDELETERequestClassificationsClassificationIDDeleteAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorClassificationDELETERequestClassificationsClassificationIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationDELETERequestClassificationsClassificationIDDeleteAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorClassificationDELETERequestClassificationsClassificationIDDeleteRequest($accept, $classification_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorClassificationDELETERequestClassificationsClassificationIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorClassificationDELETERequestClassificationsClassificationIDDeleteRequest($accept, $classification_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorClassificationDELETERequestClassificationsClassificationIDDelete'
            );
        }
        // verify the required parameter 'classification_id' is set
        if ($classification_id === null || (is_array($classification_id) && count($classification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $classification_id when calling debtorClassificationDELETERequestClassificationsClassificationIDDelete'
            );
        }

        $resourcePath = '/Debtors/Classifications/{ClassificationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($classification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ClassificationID' . '}',
                ObjectSerializer::toPathValue($classification_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorClassificationGETRequestClassificationsClassificationIDGet
     *
     * Retrieves a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorClassification
     */
    public function debtorClassificationGETRequestClassificationsClassificationIDGet($accept, $classification_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorClassificationGETRequestClassificationsClassificationIDGetWithHttpInfo($accept, $classification_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorClassificationGETRequestClassificationsClassificationIDGetWithHttpInfo
     *
     * Retrieves a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorClassification, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorClassificationGETRequestClassificationsClassificationIDGetWithHttpInfo($accept, $classification_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorClassification';
        $request = $this->debtorClassificationGETRequestClassificationsClassificationIDGetRequest($accept, $classification_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorClassificationGETRequestClassificationsClassificationIDGetAsync
     *
     * Retrieves a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationGETRequestClassificationsClassificationIDGetAsync($accept, $classification_id, $jiwa_stateful = null)
    {
        return $this->debtorClassificationGETRequestClassificationsClassificationIDGetAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorClassificationGETRequestClassificationsClassificationIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationGETRequestClassificationsClassificationIDGetAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorClassification';
        $request = $this->debtorClassificationGETRequestClassificationsClassificationIDGetRequest($accept, $classification_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorClassificationGETRequestClassificationsClassificationIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorClassificationGETRequestClassificationsClassificationIDGetRequest($accept, $classification_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorClassificationGETRequestClassificationsClassificationIDGet'
            );
        }
        // verify the required parameter 'classification_id' is set
        if ($classification_id === null || (is_array($classification_id) && count($classification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $classification_id when calling debtorClassificationGETRequestClassificationsClassificationIDGet'
            );
        }

        $resourcePath = '/Debtors/Classifications/{ClassificationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($classification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ClassificationID' . '}',
                ObjectSerializer::toPathValue($classification_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorClassificationPATCHRequestClassificationsClassificationIDUpdate
     *
     * Updates a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  bool $is_default is_default (optional)
     * @param  int $terms_days terms_days (optional)
     * @param  string $terms_type terms_type (optional)
     * @param  string $pricing_group_id pricing_group_id (optional)
     * @param  string $pricing_group_description pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorClassification
     */
    public function debtorClassificationPATCHRequestClassificationsClassificationIDUpdate($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        list($response) = $this->debtorClassificationPATCHRequestClassificationsClassificationIDUpdateWithHttpInfo($accept, $classification_id, $jiwa_stateful, $description, $last_saved_date_time, $is_default, $terms_days, $terms_type, $pricing_group_id, $pricing_group_description, $sell_pricing_scheme_id, $sell_pricing_scheme_description, $debtor_ledgers, $body);
        return $response;
    }

    /**
     * Operation debtorClassificationPATCHRequestClassificationsClassificationIDUpdateWithHttpInfo
     *
     * Updates a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $is_default (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorClassification, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorClassificationPATCHRequestClassificationsClassificationIDUpdateWithHttpInfo($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorClassification';
        $request = $this->debtorClassificationPATCHRequestClassificationsClassificationIDUpdateRequest($accept, $classification_id, $jiwa_stateful, $description, $last_saved_date_time, $is_default, $terms_days, $terms_type, $pricing_group_id, $pricing_group_description, $sell_pricing_scheme_id, $sell_pricing_scheme_description, $debtor_ledgers, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorClassificationPATCHRequestClassificationsClassificationIDUpdateAsync
     *
     * Updates a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $is_default (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationPATCHRequestClassificationsClassificationIDUpdateAsync($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        return $this->debtorClassificationPATCHRequestClassificationsClassificationIDUpdateAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful, $description, $last_saved_date_time, $is_default, $terms_days, $terms_type, $pricing_group_id, $pricing_group_description, $sell_pricing_scheme_id, $sell_pricing_scheme_description, $debtor_ledgers, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorClassificationPATCHRequestClassificationsClassificationIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $is_default (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationPATCHRequestClassificationsClassificationIDUpdateAsyncWithHttpInfo($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorClassification';
        $request = $this->debtorClassificationPATCHRequestClassificationsClassificationIDUpdateRequest($accept, $classification_id, $jiwa_stateful, $description, $last_saved_date_time, $is_default, $terms_days, $terms_type, $pricing_group_id, $pricing_group_description, $sell_pricing_scheme_id, $sell_pricing_scheme_description, $debtor_ledgers, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorClassificationPATCHRequestClassificationsClassificationIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $classification_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $is_default (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorClassificationPATCHRequestClassificationsClassificationIDUpdateRequest($accept, $classification_id, $jiwa_stateful = null, $description = null, $last_saved_date_time = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorClassificationPATCHRequestClassificationsClassificationIDUpdate'
            );
        }
        // verify the required parameter 'classification_id' is set
        if ($classification_id === null || (is_array($classification_id) && count($classification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $classification_id when calling debtorClassificationPATCHRequestClassificationsClassificationIDUpdate'
            );
        }

        $resourcePath = '/Debtors/Classifications/{ClassificationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($terms_days !== null) {
            $queryParams['TermsDays'] = ObjectSerializer::toQueryValue($terms_days);
        }
        // query params
        if ($terms_type !== null) {
            $queryParams['TermsType'] = ObjectSerializer::toQueryValue($terms_type);
        }
        // query params
        if ($pricing_group_id !== null) {
            $queryParams['PricingGroupID'] = ObjectSerializer::toQueryValue($pricing_group_id);
        }
        // query params
        if ($pricing_group_description !== null) {
            $queryParams['PricingGroupDescription'] = ObjectSerializer::toQueryValue($pricing_group_description);
        }
        // query params
        if ($sell_pricing_scheme_id !== null) {
            $queryParams['SellPricingSchemeID'] = ObjectSerializer::toQueryValue($sell_pricing_scheme_id);
        }
        // query params
        if ($sell_pricing_scheme_description !== null) {
            $queryParams['SellPricingSchemeDescription'] = ObjectSerializer::toQueryValue($sell_pricing_scheme_description);
        }
        // query params
        if ($debtor_ledgers !== null) {
            $queryParams['DebtorLedgers'] = ObjectSerializer::toQueryValue($debtor_ledgers);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($classification_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ClassificationID' . '}',
                ObjectSerializer::toPathValue($classification_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorClassificationPOSTRequestClassificationsPost
     *
     * Creates a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $is_default is_default (optional)
     * @param  int $terms_days terms_days (optional)
     * @param  string $terms_type terms_type (optional)
     * @param  string $pricing_group_id pricing_group_id (optional)
     * @param  string $pricing_group_description pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorClassification
     */
    public function debtorClassificationPOSTRequestClassificationsPost($accept, $jiwa_stateful = null, $description = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        list($response) = $this->debtorClassificationPOSTRequestClassificationsPostWithHttpInfo($accept, $jiwa_stateful, $description, $is_default, $terms_days, $terms_type, $pricing_group_id, $pricing_group_description, $sell_pricing_scheme_id, $sell_pricing_scheme_description, $debtor_ledgers, $body);
        return $response;
    }

    /**
     * Operation debtorClassificationPOSTRequestClassificationsPostWithHttpInfo
     *
     * Creates a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorClassification, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorClassificationPOSTRequestClassificationsPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorClassification';
        $request = $this->debtorClassificationPOSTRequestClassificationsPostRequest($accept, $jiwa_stateful, $description, $is_default, $terms_days, $terms_type, $pricing_group_id, $pricing_group_description, $sell_pricing_scheme_id, $sell_pricing_scheme_description, $debtor_ledgers, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorClassificationPOSTRequestClassificationsPostAsync
     *
     * Creates a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationPOSTRequestClassificationsPostAsync($accept, $jiwa_stateful = null, $description = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        return $this->debtorClassificationPOSTRequestClassificationsPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $is_default, $terms_days, $terms_type, $pricing_group_id, $pricing_group_description, $sell_pricing_scheme_id, $sell_pricing_scheme_description, $debtor_ledgers, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorClassificationPOSTRequestClassificationsPostAsyncWithHttpInfo
     *
     * Creates a debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationPOSTRequestClassificationsPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorClassification';
        $request = $this->debtorClassificationPOSTRequestClassificationsPostRequest($accept, $jiwa_stateful, $description, $is_default, $terms_days, $terms_type, $pricing_group_id, $pricing_group_description, $sell_pricing_scheme_id, $sell_pricing_scheme_description, $debtor_ledgers, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorClassificationPOSTRequestClassificationsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  string $pricing_group_id (optional)
     * @param  string $pricing_group_description (optional)
     * @param  string $sell_pricing_scheme_id (optional)
     * @param  string $sell_pricing_scheme_description (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorClassificationPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorClassificationPOSTRequestClassificationsPostRequest($accept, $jiwa_stateful = null, $description = null, $is_default = null, $terms_days = null, $terms_type = null, $pricing_group_id = null, $pricing_group_description = null, $sell_pricing_scheme_id = null, $sell_pricing_scheme_description = null, $debtor_ledgers = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorClassificationPOSTRequestClassificationsPost'
            );
        }

        $resourcePath = '/Debtors/Classifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($terms_days !== null) {
            $queryParams['TermsDays'] = ObjectSerializer::toQueryValue($terms_days);
        }
        // query params
        if ($terms_type !== null) {
            $queryParams['TermsType'] = ObjectSerializer::toQueryValue($terms_type);
        }
        // query params
        if ($pricing_group_id !== null) {
            $queryParams['PricingGroupID'] = ObjectSerializer::toQueryValue($pricing_group_id);
        }
        // query params
        if ($pricing_group_description !== null) {
            $queryParams['PricingGroupDescription'] = ObjectSerializer::toQueryValue($pricing_group_description);
        }
        // query params
        if ($sell_pricing_scheme_id !== null) {
            $queryParams['SellPricingSchemeID'] = ObjectSerializer::toQueryValue($sell_pricing_scheme_id);
        }
        // query params
        if ($sell_pricing_scheme_description !== null) {
            $queryParams['SellPricingSchemeDescription'] = ObjectSerializer::toQueryValue($sell_pricing_scheme_description);
        }
        // query params
        if ($debtor_ledgers !== null) {
            $queryParams['DebtorLedgers'] = ObjectSerializer::toQueryValue($debtor_ledgers);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorClassificationSAVERequestClassificationsSaveGet
     *
     * Saves a stateful debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id classification_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorClassification
     */
    public function debtorClassificationSAVERequestClassificationsSaveGet($accept, $jiwa_stateful = null, $classification_id = null)
    {
        list($response) = $this->debtorClassificationSAVERequestClassificationsSaveGetWithHttpInfo($accept, $jiwa_stateful, $classification_id);
        return $response;
    }

    /**
     * Operation debtorClassificationSAVERequestClassificationsSaveGetWithHttpInfo
     *
     * Saves a stateful debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorClassification, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorClassificationSAVERequestClassificationsSaveGetWithHttpInfo($accept, $jiwa_stateful = null, $classification_id = null)
    {
        $returnType = '\Jiwa\Model\DebtorClassification';
        $request = $this->debtorClassificationSAVERequestClassificationsSaveGetRequest($accept, $jiwa_stateful, $classification_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorClassification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorClassificationSAVERequestClassificationsSaveGetAsync
     *
     * Saves a stateful debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationSAVERequestClassificationsSaveGetAsync($accept, $jiwa_stateful = null, $classification_id = null)
    {
        return $this->debtorClassificationSAVERequestClassificationsSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful, $classification_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorClassificationSAVERequestClassificationsSaveGetAsyncWithHttpInfo
     *
     * Saves a stateful debtor classification.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorClassificationSAVERequestClassificationsSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful = null, $classification_id = null)
    {
        $returnType = '\Jiwa\Model\DebtorClassification';
        $request = $this->debtorClassificationSAVERequestClassificationsSaveGetRequest($accept, $jiwa_stateful, $classification_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorClassificationSAVERequestClassificationsSaveGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $classification_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorClassificationSAVERequestClassificationsSaveGetRequest($accept, $jiwa_stateful = null, $classification_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorClassificationSAVERequestClassificationsSaveGet'
            );
        }

        $resourcePath = '/Debtors/Classifications/Save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($classification_id !== null) {
            $queryParams['ClassificationID'] = ObjectSerializer::toQueryValue($classification_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDelete
     *
     * Deletes a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $contact_name_id contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact default_contact (optional)
     * @param  bool $debtor_contact debtor_contact (optional)
     * @param  bool $creditor_contact creditor_contact (optional)
     * @param  string $contact_id contact_id (optional)
     * @param  string $account_no account_no (optional)
     * @param  string $title title (optional)
     * @param  string $first_name first_name (optional)
     * @param  string $surname surname (optional)
     * @param  string $primary_position_id primary_position_id (optional)
     * @param  string $primary_position_name primary_position_name (optional)
     * @param  string $secondary_position_id secondary_position_id (optional)
     * @param  string $secondary_position_name secondary_position_name (optional)
     * @param  string $tertiary_position_id tertiary_position_id (optional)
     * @param  string $tertiary_position_name tertiary_position_name (optional)
     * @param  string $phone phone (optional)
     * @param  string $mobile mobile (optional)
     * @param  string $fax fax (optional)
     * @param  string $email_address email_address (optional)
     * @param  string $prospect_id prospect_id (optional)
     * @param  string $logon_code logon_code (optional)
     * @param  string $logon_password logon_password (optional)
     * @param  string $external_app_rec_id external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user logon_code_changed_by_user (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDelete($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null)
    {
        list($response) = $this->debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $last_saved_date_time, $logon_code_changed_by_user);
        return $response;
    }

    /**
     * Operation debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteWithHttpInfo
     *
     * Deletes a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $last_saved_date_time, $logon_code_changed_by_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteAsync
     *
     * Deletes a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteAsync($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null)
    {
        return $this->debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $last_saved_date_time, $logon_code_changed_by_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $last_saved_date_time, $logon_code_changed_by_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDeleteRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDelete'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDelete'
            );
        }
        // verify the required parameter 'contact_name_id' is set
        if ($contact_name_id === null || (is_array($contact_name_id) && count($contact_name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_name_id when calling debtorContactNameDELETERequestDebtorIDContactNamesContactNameIDDelete'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/ContactNames/{ContactNameID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_contact !== null) {
            $queryParams['DefaultContact'] = ObjectSerializer::toQueryValue($default_contact);
        }
        // query params
        if ($debtor_contact !== null) {
            $queryParams['DebtorContact'] = ObjectSerializer::toQueryValue($debtor_contact);
        }
        // query params
        if ($creditor_contact !== null) {
            $queryParams['CreditorContact'] = ObjectSerializer::toQueryValue($creditor_contact);
        }
        // query params
        if ($contact_id !== null) {
            $queryParams['ContactID'] = ObjectSerializer::toQueryValue($contact_id);
        }
        // query params
        if ($account_no !== null) {
            $queryParams['AccountNo'] = ObjectSerializer::toQueryValue($account_no);
        }
        // query params
        if ($title !== null) {
            $queryParams['Title'] = ObjectSerializer::toQueryValue($title);
        }
        // query params
        if ($first_name !== null) {
            $queryParams['FirstName'] = ObjectSerializer::toQueryValue($first_name);
        }
        // query params
        if ($surname !== null) {
            $queryParams['Surname'] = ObjectSerializer::toQueryValue($surname);
        }
        // query params
        if ($primary_position_id !== null) {
            $queryParams['PrimaryPositionID'] = ObjectSerializer::toQueryValue($primary_position_id);
        }
        // query params
        if ($primary_position_name !== null) {
            $queryParams['PrimaryPositionName'] = ObjectSerializer::toQueryValue($primary_position_name);
        }
        // query params
        if ($secondary_position_id !== null) {
            $queryParams['SecondaryPositionID'] = ObjectSerializer::toQueryValue($secondary_position_id);
        }
        // query params
        if ($secondary_position_name !== null) {
            $queryParams['SecondaryPositionName'] = ObjectSerializer::toQueryValue($secondary_position_name);
        }
        // query params
        if ($tertiary_position_id !== null) {
            $queryParams['TertiaryPositionID'] = ObjectSerializer::toQueryValue($tertiary_position_id);
        }
        // query params
        if ($tertiary_position_name !== null) {
            $queryParams['TertiaryPositionName'] = ObjectSerializer::toQueryValue($tertiary_position_name);
        }
        // query params
        if ($phone !== null) {
            $queryParams['Phone'] = ObjectSerializer::toQueryValue($phone);
        }
        // query params
        if ($mobile !== null) {
            $queryParams['Mobile'] = ObjectSerializer::toQueryValue($mobile);
        }
        // query params
        if ($fax !== null) {
            $queryParams['Fax'] = ObjectSerializer::toQueryValue($fax);
        }
        // query params
        if ($email_address !== null) {
            $queryParams['EmailAddress'] = ObjectSerializer::toQueryValue($email_address);
        }
        // query params
        if ($prospect_id !== null) {
            $queryParams['ProspectID'] = ObjectSerializer::toQueryValue($prospect_id);
        }
        // query params
        if ($logon_code !== null) {
            $queryParams['LogonCode'] = ObjectSerializer::toQueryValue($logon_code);
        }
        // query params
        if ($logon_password !== null) {
            $queryParams['LogonPassword'] = ObjectSerializer::toQueryValue($logon_password);
        }
        // query params
        if ($external_app_rec_id !== null) {
            $queryParams['ExternalAppRecID'] = ObjectSerializer::toQueryValue($external_app_rec_id);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($logon_code_changed_by_user !== null) {
            $queryParams['LogonCodeChangedByUser'] = ObjectSerializer::toQueryValue($logon_code_changed_by_user);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($contact_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactNameID' . '}',
                ObjectSerializer::toPathValue($contact_name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGet
     *
     * Retrieves a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $contact_name_id contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorContactName
     */
    public function debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGet($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetWithHttpInfo
     *
     * Retrieves a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorContactName, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorContactName';
        $request = $this->debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetAsync
     *
     * Retrieves a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetAsync($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null)
    {
        return $this->debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetAsyncWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetAsyncWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorContactName';
        $request = $this->debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGetRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGet'
            );
        }
        // verify the required parameter 'contact_name_id' is set
        if ($contact_name_id === null || (is_array($contact_name_id) && count($contact_name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_name_id when calling debtorContactNameGETRequestDebtorIDContactNamesContactNameIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/ContactNames/{ContactNameID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($contact_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactNameID' . '}',
                ObjectSerializer::toPathValue($contact_name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdate
     *
     * Updates a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $contact_name_id contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact default_contact (optional)
     * @param  bool $debtor_contact debtor_contact (optional)
     * @param  bool $creditor_contact creditor_contact (optional)
     * @param  string $contact_id contact_id (optional)
     * @param  string $account_no account_no (optional)
     * @param  string $title title (optional)
     * @param  string $first_name first_name (optional)
     * @param  string $surname surname (optional)
     * @param  string $primary_position_id primary_position_id (optional)
     * @param  string $primary_position_name primary_position_name (optional)
     * @param  string $secondary_position_id secondary_position_id (optional)
     * @param  string $secondary_position_name secondary_position_name (optional)
     * @param  string $tertiary_position_id tertiary_position_id (optional)
     * @param  string $tertiary_position_name tertiary_position_name (optional)
     * @param  string $phone phone (optional)
     * @param  string $mobile mobile (optional)
     * @param  string $fax fax (optional)
     * @param  string $email_address email_address (optional)
     * @param  string $prospect_id prospect_id (optional)
     * @param  string $logon_code logon_code (optional)
     * @param  string $logon_password logon_password (optional)
     * @param  string $external_app_rec_id external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorContactName
     */
    public function debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdate($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null, $body = null)
    {
        list($response) = $this->debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $last_saved_date_time, $logon_code_changed_by_user, $body);
        return $response;
    }

    /**
     * Operation debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateWithHttpInfo
     *
     * Updates a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorContactName, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorContactName';
        $request = $this->debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $last_saved_date_time, $logon_code_changed_by_user, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateAsync
     *
     * Updates a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateAsync($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null, $body = null)
    {
        return $this->debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $last_saved_date_time, $logon_code_changed_by_user, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor contact name.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorContactName';
        $request = $this->debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $last_saved_date_time, $logon_code_changed_by_user, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $contact_name_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdateRequest($accept, $debtor_id, $contact_name_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $last_saved_date_time = null, $logon_code_changed_by_user = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdate'
            );
        }
        // verify the required parameter 'contact_name_id' is set
        if ($contact_name_id === null || (is_array($contact_name_id) && count($contact_name_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_name_id when calling debtorContactNamePATCHRequestDebtorIDContactNamesContactNameIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/ContactNames/{ContactNameID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_contact !== null) {
            $queryParams['DefaultContact'] = ObjectSerializer::toQueryValue($default_contact);
        }
        // query params
        if ($debtor_contact !== null) {
            $queryParams['DebtorContact'] = ObjectSerializer::toQueryValue($debtor_contact);
        }
        // query params
        if ($creditor_contact !== null) {
            $queryParams['CreditorContact'] = ObjectSerializer::toQueryValue($creditor_contact);
        }
        // query params
        if ($contact_id !== null) {
            $queryParams['ContactID'] = ObjectSerializer::toQueryValue($contact_id);
        }
        // query params
        if ($account_no !== null) {
            $queryParams['AccountNo'] = ObjectSerializer::toQueryValue($account_no);
        }
        // query params
        if ($title !== null) {
            $queryParams['Title'] = ObjectSerializer::toQueryValue($title);
        }
        // query params
        if ($first_name !== null) {
            $queryParams['FirstName'] = ObjectSerializer::toQueryValue($first_name);
        }
        // query params
        if ($surname !== null) {
            $queryParams['Surname'] = ObjectSerializer::toQueryValue($surname);
        }
        // query params
        if ($primary_position_id !== null) {
            $queryParams['PrimaryPositionID'] = ObjectSerializer::toQueryValue($primary_position_id);
        }
        // query params
        if ($primary_position_name !== null) {
            $queryParams['PrimaryPositionName'] = ObjectSerializer::toQueryValue($primary_position_name);
        }
        // query params
        if ($secondary_position_id !== null) {
            $queryParams['SecondaryPositionID'] = ObjectSerializer::toQueryValue($secondary_position_id);
        }
        // query params
        if ($secondary_position_name !== null) {
            $queryParams['SecondaryPositionName'] = ObjectSerializer::toQueryValue($secondary_position_name);
        }
        // query params
        if ($tertiary_position_id !== null) {
            $queryParams['TertiaryPositionID'] = ObjectSerializer::toQueryValue($tertiary_position_id);
        }
        // query params
        if ($tertiary_position_name !== null) {
            $queryParams['TertiaryPositionName'] = ObjectSerializer::toQueryValue($tertiary_position_name);
        }
        // query params
        if ($phone !== null) {
            $queryParams['Phone'] = ObjectSerializer::toQueryValue($phone);
        }
        // query params
        if ($mobile !== null) {
            $queryParams['Mobile'] = ObjectSerializer::toQueryValue($mobile);
        }
        // query params
        if ($fax !== null) {
            $queryParams['Fax'] = ObjectSerializer::toQueryValue($fax);
        }
        // query params
        if ($email_address !== null) {
            $queryParams['EmailAddress'] = ObjectSerializer::toQueryValue($email_address);
        }
        // query params
        if ($prospect_id !== null) {
            $queryParams['ProspectID'] = ObjectSerializer::toQueryValue($prospect_id);
        }
        // query params
        if ($logon_code !== null) {
            $queryParams['LogonCode'] = ObjectSerializer::toQueryValue($logon_code);
        }
        // query params
        if ($logon_password !== null) {
            $queryParams['LogonPassword'] = ObjectSerializer::toQueryValue($logon_password);
        }
        // query params
        if ($external_app_rec_id !== null) {
            $queryParams['ExternalAppRecID'] = ObjectSerializer::toQueryValue($external_app_rec_id);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($logon_code_changed_by_user !== null) {
            $queryParams['LogonCodeChangedByUser'] = ObjectSerializer::toQueryValue($logon_code_changed_by_user);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($contact_name_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ContactNameID' . '}',
                ObjectSerializer::toPathValue($contact_name_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorContactNamePOSTRequestDebtorIDContactNamesPost
     *
     * Appends a contact name to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact default_contact (optional)
     * @param  bool $debtor_contact debtor_contact (optional)
     * @param  bool $creditor_contact creditor_contact (optional)
     * @param  string $contact_id contact_id (optional)
     * @param  string $account_no account_no (optional)
     * @param  string $title title (optional)
     * @param  string $first_name first_name (optional)
     * @param  string $surname surname (optional)
     * @param  string $primary_position_id primary_position_id (optional)
     * @param  string $primary_position_name primary_position_name (optional)
     * @param  string $secondary_position_id secondary_position_id (optional)
     * @param  string $secondary_position_name secondary_position_name (optional)
     * @param  string $tertiary_position_id tertiary_position_id (optional)
     * @param  string $tertiary_position_name tertiary_position_name (optional)
     * @param  string $phone phone (optional)
     * @param  string $mobile mobile (optional)
     * @param  string $fax fax (optional)
     * @param  string $email_address email_address (optional)
     * @param  string $prospect_id prospect_id (optional)
     * @param  string $logon_code logon_code (optional)
     * @param  string $logon_password logon_password (optional)
     * @param  string $external_app_rec_id external_app_rec_id (optional)
     * @param  bool $logon_code_changed_by_user logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorContactName
     */
    public function debtorContactNamePOSTRequestDebtorIDContactNamesPost($accept, $debtor_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $logon_code_changed_by_user = null, $body = null)
    {
        list($response) = $this->debtorContactNamePOSTRequestDebtorIDContactNamesPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $logon_code_changed_by_user, $body);
        return $response;
    }

    /**
     * Operation debtorContactNamePOSTRequestDebtorIDContactNamesPostWithHttpInfo
     *
     * Appends a contact name to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorContactName, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorContactNamePOSTRequestDebtorIDContactNamesPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $logon_code_changed_by_user = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorContactName';
        $request = $this->debtorContactNamePOSTRequestDebtorIDContactNamesPostRequest($accept, $debtor_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $logon_code_changed_by_user, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorContactNamePOSTRequestDebtorIDContactNamesPostAsync
     *
     * Appends a contact name to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNamePOSTRequestDebtorIDContactNamesPostAsync($accept, $debtor_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $logon_code_changed_by_user = null, $body = null)
    {
        return $this->debtorContactNamePOSTRequestDebtorIDContactNamesPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $logon_code_changed_by_user, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorContactNamePOSTRequestDebtorIDContactNamesPostAsyncWithHttpInfo
     *
     * Appends a contact name to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNamePOSTRequestDebtorIDContactNamesPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $logon_code_changed_by_user = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorContactName';
        $request = $this->debtorContactNamePOSTRequestDebtorIDContactNamesPostRequest($accept, $debtor_id, $jiwa_stateful, $default_contact, $debtor_contact, $creditor_contact, $contact_id, $account_no, $title, $first_name, $surname, $primary_position_id, $primary_position_name, $secondary_position_id, $secondary_position_name, $tertiary_position_id, $tertiary_position_name, $phone, $mobile, $fax, $email_address, $prospect_id, $logon_code, $logon_password, $external_app_rec_id, $logon_code_changed_by_user, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorContactNamePOSTRequestDebtorIDContactNamesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $default_contact (optional)
     * @param  bool $debtor_contact (optional)
     * @param  bool $creditor_contact (optional)
     * @param  string $contact_id (optional)
     * @param  string $account_no (optional)
     * @param  string $title (optional)
     * @param  string $first_name (optional)
     * @param  string $surname (optional)
     * @param  string $primary_position_id (optional)
     * @param  string $primary_position_name (optional)
     * @param  string $secondary_position_id (optional)
     * @param  string $secondary_position_name (optional)
     * @param  string $tertiary_position_id (optional)
     * @param  string $tertiary_position_name (optional)
     * @param  string $phone (optional)
     * @param  string $mobile (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $prospect_id (optional)
     * @param  string $logon_code (optional)
     * @param  string $logon_password (optional)
     * @param  string $external_app_rec_id (optional)
     * @param  bool $logon_code_changed_by_user (optional)
     * @param  \Jiwa\Model\DebtorContactNamePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorContactNamePOSTRequestDebtorIDContactNamesPostRequest($accept, $debtor_id, $jiwa_stateful = null, $default_contact = null, $debtor_contact = null, $creditor_contact = null, $contact_id = null, $account_no = null, $title = null, $first_name = null, $surname = null, $primary_position_id = null, $primary_position_name = null, $secondary_position_id = null, $secondary_position_name = null, $tertiary_position_id = null, $tertiary_position_name = null, $phone = null, $mobile = null, $fax = null, $email_address = null, $prospect_id = null, $logon_code = null, $logon_password = null, $external_app_rec_id = null, $logon_code_changed_by_user = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorContactNamePOSTRequestDebtorIDContactNamesPost'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorContactNamePOSTRequestDebtorIDContactNamesPost'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/ContactNames';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_contact !== null) {
            $queryParams['DefaultContact'] = ObjectSerializer::toQueryValue($default_contact);
        }
        // query params
        if ($debtor_contact !== null) {
            $queryParams['DebtorContact'] = ObjectSerializer::toQueryValue($debtor_contact);
        }
        // query params
        if ($creditor_contact !== null) {
            $queryParams['CreditorContact'] = ObjectSerializer::toQueryValue($creditor_contact);
        }
        // query params
        if ($contact_id !== null) {
            $queryParams['ContactID'] = ObjectSerializer::toQueryValue($contact_id);
        }
        // query params
        if ($account_no !== null) {
            $queryParams['AccountNo'] = ObjectSerializer::toQueryValue($account_no);
        }
        // query params
        if ($title !== null) {
            $queryParams['Title'] = ObjectSerializer::toQueryValue($title);
        }
        // query params
        if ($first_name !== null) {
            $queryParams['FirstName'] = ObjectSerializer::toQueryValue($first_name);
        }
        // query params
        if ($surname !== null) {
            $queryParams['Surname'] = ObjectSerializer::toQueryValue($surname);
        }
        // query params
        if ($primary_position_id !== null) {
            $queryParams['PrimaryPositionID'] = ObjectSerializer::toQueryValue($primary_position_id);
        }
        // query params
        if ($primary_position_name !== null) {
            $queryParams['PrimaryPositionName'] = ObjectSerializer::toQueryValue($primary_position_name);
        }
        // query params
        if ($secondary_position_id !== null) {
            $queryParams['SecondaryPositionID'] = ObjectSerializer::toQueryValue($secondary_position_id);
        }
        // query params
        if ($secondary_position_name !== null) {
            $queryParams['SecondaryPositionName'] = ObjectSerializer::toQueryValue($secondary_position_name);
        }
        // query params
        if ($tertiary_position_id !== null) {
            $queryParams['TertiaryPositionID'] = ObjectSerializer::toQueryValue($tertiary_position_id);
        }
        // query params
        if ($tertiary_position_name !== null) {
            $queryParams['TertiaryPositionName'] = ObjectSerializer::toQueryValue($tertiary_position_name);
        }
        // query params
        if ($phone !== null) {
            $queryParams['Phone'] = ObjectSerializer::toQueryValue($phone);
        }
        // query params
        if ($mobile !== null) {
            $queryParams['Mobile'] = ObjectSerializer::toQueryValue($mobile);
        }
        // query params
        if ($fax !== null) {
            $queryParams['Fax'] = ObjectSerializer::toQueryValue($fax);
        }
        // query params
        if ($email_address !== null) {
            $queryParams['EmailAddress'] = ObjectSerializer::toQueryValue($email_address);
        }
        // query params
        if ($prospect_id !== null) {
            $queryParams['ProspectID'] = ObjectSerializer::toQueryValue($prospect_id);
        }
        // query params
        if ($logon_code !== null) {
            $queryParams['LogonCode'] = ObjectSerializer::toQueryValue($logon_code);
        }
        // query params
        if ($logon_password !== null) {
            $queryParams['LogonPassword'] = ObjectSerializer::toQueryValue($logon_password);
        }
        // query params
        if ($external_app_rec_id !== null) {
            $queryParams['ExternalAppRecID'] = ObjectSerializer::toQueryValue($external_app_rec_id);
        }
        // query params
        if ($logon_code_changed_by_user !== null) {
            $queryParams['LogonCodeChangedByUser'] = ObjectSerializer::toQueryValue($logon_code_changed_by_user);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorContactNamesGETManyRequestDebtorIDContactNamesGet
     *
     * Retrieves a list of debtor contact names.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorContactName[]
     */
    public function debtorContactNamesGETManyRequestDebtorIDContactNamesGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorContactNamesGETManyRequestDebtorIDContactNamesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorContactNamesGETManyRequestDebtorIDContactNamesGetWithHttpInfo
     *
     * Retrieves a list of debtor contact names.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorContactName[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorContactNamesGETManyRequestDebtorIDContactNamesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorContactName[]';
        $request = $this->debtorContactNamesGETManyRequestDebtorIDContactNamesGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorContactName[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorContactNamesGETManyRequestDebtorIDContactNamesGetAsync
     *
     * Retrieves a list of debtor contact names.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNamesGETManyRequestDebtorIDContactNamesGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorContactNamesGETManyRequestDebtorIDContactNamesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorContactNamesGETManyRequestDebtorIDContactNamesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor contact names.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorContactNamesGETManyRequestDebtorIDContactNamesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorContactName[]';
        $request = $this->debtorContactNamesGETManyRequestDebtorIDContactNamesGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorContactNamesGETManyRequestDebtorIDContactNamesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorContactNamesGETManyRequestDebtorIDContactNamesGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorContactNamesGETManyRequestDebtorIDContactNamesGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorContactNamesGETManyRequestDebtorIDContactNamesGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/ContactNames';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGet
     *
     * Retrieves a debtor custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $setting_id setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\CustomFieldValue
     */
    public function debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGet($accept, $debtor_id, $setting_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetWithHttpInfo($accept, $debtor_id, $setting_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetWithHttpInfo
     *
     * Retrieves a debtor custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\CustomFieldValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetWithHttpInfo($accept, $debtor_id, $setting_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\CustomFieldValue';
        $request = $this->debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetRequest($accept, $debtor_id, $setting_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetAsync
     *
     * Retrieves a debtor custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetAsync($accept, $debtor_id, $setting_id, $jiwa_stateful = null)
    {
        return $this->debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetAsyncWithHttpInfo($accept, $debtor_id, $setting_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetAsyncWithHttpInfo($accept, $debtor_id, $setting_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\CustomFieldValue';
        $request = $this->debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetRequest($accept, $debtor_id, $setting_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGetRequest($accept, $debtor_id, $setting_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGet'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling debtorCustomFieldValueGETRequestDebtorIDCustomFieldValuesSettingIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/CustomFieldValues/{SettingID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SettingID' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdate
     *
     * Updates a debtor custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $setting_id setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents contents (optional)
     * @param  \Jiwa\Model\DebtorCustomFieldValuePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\CustomFieldValue
     */
    public function debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdate($accept, $debtor_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        list($response) = $this->debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateWithHttpInfo($accept, $debtor_id, $setting_id, $jiwa_stateful, $contents, $body);
        return $response;
    }

    /**
     * Operation debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateWithHttpInfo
     *
     * Updates a debtor custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\Model\DebtorCustomFieldValuePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\CustomFieldValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateWithHttpInfo($accept, $debtor_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        $returnType = '\Jiwa\Model\CustomFieldValue';
        $request = $this->debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateRequest($accept, $debtor_id, $setting_id, $jiwa_stateful, $contents, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateAsync
     *
     * Updates a debtor custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\Model\DebtorCustomFieldValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateAsync($accept, $debtor_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        return $this->debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $setting_id, $jiwa_stateful, $contents, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor custom field value.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\Model\DebtorCustomFieldValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        $returnType = '\Jiwa\Model\CustomFieldValue';
        $request = $this->debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateRequest($accept, $debtor_id, $setting_id, $jiwa_stateful, $contents, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $setting_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $contents (optional)
     * @param  \Jiwa\Model\DebtorCustomFieldValuePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdateRequest($accept, $debtor_id, $setting_id, $jiwa_stateful = null, $contents = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdate'
            );
        }
        // verify the required parameter 'setting_id' is set
        if ($setting_id === null || (is_array($setting_id) && count($setting_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $setting_id when calling debtorCustomFieldValuePATCHRequestDebtorIDCustomFieldValuesSettingIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/CustomFieldValues/{SettingID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contents !== null) {
            $queryParams['Contents'] = ObjectSerializer::toQueryValue($contents);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($setting_id !== null) {
            $resourcePath = str_replace(
                '{' . 'SettingID' . '}',
                ObjectSerializer::toPathValue($setting_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGet
     *
     * Retrieves a list of custom field values for a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\CustomFieldValue[]
     */
    public function debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetWithHttpInfo
     *
     * Retrieves a list of custom field values for a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\CustomFieldValue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\CustomFieldValue[]';
        $request = $this->debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomFieldValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetAsync
     *
     * Retrieves a list of custom field values for a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetAsyncWithHttpInfo
     *
     * Retrieves a list of custom field values for a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\CustomFieldValue[]';
        $request = $this->debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorCustomFieldValuesGETManyRequestDebtorIDCustomFieldValuesGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/CustomFieldValues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorCustomFieldsGETManyRequestCustomFieldsGet
     *
     * Retrieves a list of debtor custom fields.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\CustomField[]
     */
    public function debtorCustomFieldsGETManyRequestCustomFieldsGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->debtorCustomFieldsGETManyRequestCustomFieldsGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorCustomFieldsGETManyRequestCustomFieldsGetWithHttpInfo
     *
     * Retrieves a list of debtor custom fields.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\CustomField[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorCustomFieldsGETManyRequestCustomFieldsGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\CustomField[]';
        $request = $this->debtorCustomFieldsGETManyRequestCustomFieldsGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorCustomFieldsGETManyRequestCustomFieldsGetAsync
     *
     * Retrieves a list of debtor custom fields.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCustomFieldsGETManyRequestCustomFieldsGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->debtorCustomFieldsGETManyRequestCustomFieldsGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorCustomFieldsGETManyRequestCustomFieldsGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor custom fields.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorCustomFieldsGETManyRequestCustomFieldsGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\CustomField[]';
        $request = $this->debtorCustomFieldsGETManyRequestCustomFieldsGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorCustomFieldsGETManyRequestCustomFieldsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorCustomFieldsGETManyRequestCustomFieldsGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorCustomFieldsGETManyRequestCustomFieldsGet'
            );
        }

        $resourcePath = '/Debtors/CustomFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDELETERequestDebtorIDDelete
     *
     * Deletes a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorDELETERequestDebtorIDDelete($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDELETERequestDebtorIDDeleteWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDELETERequestDebtorIDDeleteWithHttpInfo
     *
     * Deletes a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDELETERequestDebtorIDDeleteWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorDELETERequestDebtorIDDeleteRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDELETERequestDebtorIDDeleteAsync
     *
     * Deletes a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDELETERequestDebtorIDDeleteAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorDELETERequestDebtorIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDELETERequestDebtorIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDELETERequestDebtorIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorDELETERequestDebtorIDDeleteRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDELETERequestDebtorIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDELETERequestDebtorIDDeleteRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDELETERequestDebtorIDDelete'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDELETERequestDebtorIDDelete'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDelete
     *
     * Deletes a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $delivery_address_id delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $delivery_address_name delivery_address_name (optional)
     * @param  string $delivery_address_code delivery_address_code (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $address2 address2 (optional)
     * @param  string $address3 address3 (optional)
     * @param  string $address4 address4 (optional)
     * @param  string $postcode postcode (optional)
     * @param  string $country country (optional)
     * @param  string $notes notes (optional)
     * @param  string $courier_details courier_details (optional)
     * @param  string $edi_store_location_code edi_store_location_code (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDelete($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null)
    {
        list($response) = $this->debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code);
        return $response;
    }

    /**
     * Operation debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteWithHttpInfo
     *
     * Deletes a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteAsync
     *
     * Deletes a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteAsync($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null)
    {
        return $this->debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDeleteRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDelete'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDelete'
            );
        }
        // verify the required parameter 'delivery_address_id' is set
        if ($delivery_address_id === null || (is_array($delivery_address_id) && count($delivery_address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delivery_address_id when calling debtorDeliveryAddressDELETERequestDebtorIDDeliveryAddressesDeliveryAddressIDDelete'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DeliveryAddresses/{DeliveryAddressID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($delivery_address_name !== null) {
            $queryParams['DeliveryAddressName'] = ObjectSerializer::toQueryValue($delivery_address_name);
        }
        // query params
        if ($delivery_address_code !== null) {
            $queryParams['DeliveryAddressCode'] = ObjectSerializer::toQueryValue($delivery_address_code);
        }
        // query params
        if ($address1 !== null) {
            $queryParams['Address1'] = ObjectSerializer::toQueryValue($address1);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['Address2'] = ObjectSerializer::toQueryValue($address2);
        }
        // query params
        if ($address3 !== null) {
            $queryParams['Address3'] = ObjectSerializer::toQueryValue($address3);
        }
        // query params
        if ($address4 !== null) {
            $queryParams['Address4'] = ObjectSerializer::toQueryValue($address4);
        }
        // query params
        if ($postcode !== null) {
            $queryParams['Postcode'] = ObjectSerializer::toQueryValue($postcode);
        }
        // query params
        if ($country !== null) {
            $queryParams['Country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($courier_details !== null) {
            $queryParams['CourierDetails'] = ObjectSerializer::toQueryValue($courier_details);
        }
        // query params
        if ($edi_store_location_code !== null) {
            $queryParams['EDIStoreLocationCode'] = ObjectSerializer::toQueryValue($edi_store_location_code);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($delivery_address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DeliveryAddressID' . '}',
                ObjectSerializer::toPathValue($delivery_address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGet
     *
     * Retrieves a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $delivery_address_id delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorDeliveryAddress
     */
    public function debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGet($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetWithHttpInfo
     *
     * Retrieves a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorDeliveryAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorDeliveryAddress';
        $request = $this->debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetAsync
     *
     * Retrieves a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetAsync($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null)
    {
        return $this->debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetAsyncWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetAsyncWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorDeliveryAddress';
        $request = $this->debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGetRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGet'
            );
        }
        // verify the required parameter 'delivery_address_id' is set
        if ($delivery_address_id === null || (is_array($delivery_address_id) && count($delivery_address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delivery_address_id when calling debtorDeliveryAddressGETRequestDebtorIDDeliveryAddressesDeliveryAddressIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DeliveryAddresses/{DeliveryAddressID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($delivery_address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DeliveryAddressID' . '}',
                ObjectSerializer::toPathValue($delivery_address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdate
     *
     * Updates a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $delivery_address_id delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $delivery_address_name delivery_address_name (optional)
     * @param  string $delivery_address_code delivery_address_code (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $address2 address2 (optional)
     * @param  string $address3 address3 (optional)
     * @param  string $address4 address4 (optional)
     * @param  string $postcode postcode (optional)
     * @param  string $country country (optional)
     * @param  string $notes notes (optional)
     * @param  string $courier_details courier_details (optional)
     * @param  string $edi_store_location_code edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorDeliveryAddress
     */
    public function debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdate($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        list($response) = $this->debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code, $body);
        return $response;
    }

    /**
     * Operation debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateWithHttpInfo
     *
     * Updates a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorDeliveryAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorDeliveryAddress';
        $request = $this->debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateAsync
     *
     * Updates a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateAsync($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        return $this->debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor delivery address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorDeliveryAddress';
        $request = $this->debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $delivery_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdateRequest($accept, $debtor_id, $delivery_address_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdate'
            );
        }
        // verify the required parameter 'delivery_address_id' is set
        if ($delivery_address_id === null || (is_array($delivery_address_id) && count($delivery_address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delivery_address_id when calling debtorDeliveryAddressPATCHRequestDebtorIDDeliveryAddressesDeliveryAddressIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DeliveryAddresses/{DeliveryAddressID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($delivery_address_name !== null) {
            $queryParams['DeliveryAddressName'] = ObjectSerializer::toQueryValue($delivery_address_name);
        }
        // query params
        if ($delivery_address_code !== null) {
            $queryParams['DeliveryAddressCode'] = ObjectSerializer::toQueryValue($delivery_address_code);
        }
        // query params
        if ($address1 !== null) {
            $queryParams['Address1'] = ObjectSerializer::toQueryValue($address1);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['Address2'] = ObjectSerializer::toQueryValue($address2);
        }
        // query params
        if ($address3 !== null) {
            $queryParams['Address3'] = ObjectSerializer::toQueryValue($address3);
        }
        // query params
        if ($address4 !== null) {
            $queryParams['Address4'] = ObjectSerializer::toQueryValue($address4);
        }
        // query params
        if ($postcode !== null) {
            $queryParams['Postcode'] = ObjectSerializer::toQueryValue($postcode);
        }
        // query params
        if ($country !== null) {
            $queryParams['Country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($courier_details !== null) {
            $queryParams['CourierDetails'] = ObjectSerializer::toQueryValue($courier_details);
        }
        // query params
        if ($edi_store_location_code !== null) {
            $queryParams['EDIStoreLocationCode'] = ObjectSerializer::toQueryValue($edi_store_location_code);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($delivery_address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DeliveryAddressID' . '}',
                ObjectSerializer::toPathValue($delivery_address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPost
     *
     * Appends a delivery address to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $delivery_address_name delivery_address_name (optional)
     * @param  string $delivery_address_code delivery_address_code (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $address2 address2 (optional)
     * @param  string $address3 address3 (optional)
     * @param  string $address4 address4 (optional)
     * @param  string $postcode postcode (optional)
     * @param  string $country country (optional)
     * @param  string $notes notes (optional)
     * @param  string $courier_details courier_details (optional)
     * @param  string $edi_store_location_code edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorDeliveryAddress
     */
    public function debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPost($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        list($response) = $this->debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code, $body);
        return $response;
    }

    /**
     * Operation debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostWithHttpInfo
     *
     * Appends a delivery address to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorDeliveryAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorDeliveryAddress';
        $request = $this->debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostRequest($accept, $debtor_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostAsync
     *
     * Appends a delivery address to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostAsync($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        return $this->debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostAsyncWithHttpInfo
     *
     * Appends a delivery address to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorDeliveryAddress';
        $request = $this->debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostRequest($accept, $debtor_id, $jiwa_stateful, $is_default, $delivery_address_name, $delivery_address_code, $address1, $address2, $address3, $address4, $postcode, $country, $notes, $courier_details, $edi_store_location_code, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $delivery_address_name (optional)
     * @param  string $delivery_address_code (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  string $courier_details (optional)
     * @param  string $edi_store_location_code (optional)
     * @param  \Jiwa\Model\DebtorDeliveryAddressPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPostRequest($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $delivery_address_name = null, $delivery_address_code = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $country = null, $notes = null, $courier_details = null, $edi_store_location_code = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPost'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDeliveryAddressPOSTRequestDebtorIDDeliveryAddressesPost'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DeliveryAddresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($delivery_address_name !== null) {
            $queryParams['DeliveryAddressName'] = ObjectSerializer::toQueryValue($delivery_address_name);
        }
        // query params
        if ($delivery_address_code !== null) {
            $queryParams['DeliveryAddressCode'] = ObjectSerializer::toQueryValue($delivery_address_code);
        }
        // query params
        if ($address1 !== null) {
            $queryParams['Address1'] = ObjectSerializer::toQueryValue($address1);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['Address2'] = ObjectSerializer::toQueryValue($address2);
        }
        // query params
        if ($address3 !== null) {
            $queryParams['Address3'] = ObjectSerializer::toQueryValue($address3);
        }
        // query params
        if ($address4 !== null) {
            $queryParams['Address4'] = ObjectSerializer::toQueryValue($address4);
        }
        // query params
        if ($postcode !== null) {
            $queryParams['Postcode'] = ObjectSerializer::toQueryValue($postcode);
        }
        // query params
        if ($country !== null) {
            $queryParams['Country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($courier_details !== null) {
            $queryParams['CourierDetails'] = ObjectSerializer::toQueryValue($courier_details);
        }
        // query params
        if ($edi_store_location_code !== null) {
            $queryParams['EDIStoreLocationCode'] = ObjectSerializer::toQueryValue($edi_store_location_code);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGet
     *
     * Retrieves a list of debtor delivery addresses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorDeliveryAddress[]
     */
    public function debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetWithHttpInfo
     *
     * Retrieves a list of debtor delivery addresses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorDeliveryAddress[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorDeliveryAddress[]';
        $request = $this->debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorDeliveryAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetAsync
     *
     * Retrieves a list of debtor delivery addresses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor delivery addresses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorDeliveryAddress[]';
        $request = $this->debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDeliveryAddressesGETManyRequestDebtorIDDeliveryAddressesGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DeliveryAddresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDelete
     *
     * Deletes a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDelete($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteWithHttpInfo
     *
     * Deletes a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteRequest($accept, $debtor_id, $document_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteAsync
     *
     * Deletes a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteAsync($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        return $this->debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteRequest($accept, $debtor_id, $document_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDeleteRequest($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDelete'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDelete'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling debtorDocumentDELETERequestDebtorIDDocumentsDocumentIDDelete'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGet
     *
     * Retrieves a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Document
     */
    public function debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGet($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetWithHttpInfo
     *
     * Retrieves a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Document';
        $request = $this->debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetRequest($accept, $debtor_id, $document_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetAsync
     *
     * Retrieves a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetAsync($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        return $this->debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetAsyncWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetAsyncWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Document';
        $request = $this->debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetRequest($accept, $debtor_id, $document_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGetRequest($accept, $debtor_id, $document_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGet'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling debtorDocumentGETRequestDebtorIDDocumentsDocumentIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdate
     *
     * Updates a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $document_id document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type document_type (optional)
     * @param  string $file_id file_id (optional)
     * @param  string $physical_file_name physical_file_name (optional)
     * @param  string $full_physical_file_name full_physical_file_name (optional)
     * @param  string $description description (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $file_binary file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Document
     */
    public function debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdate($accept, $debtor_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        list($response) = $this->debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);
        return $response;
    }

    /**
     * Operation debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateWithHttpInfo
     *
     * Updates a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Document';
        $request = $this->debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateRequest($accept, $debtor_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateAsync
     *
     * Updates a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateAsync($accept, $debtor_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        return $this->debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor document.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Document';
        $request = $this->debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateRequest($accept, $debtor_id, $document_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $document_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdateRequest($accept, $debtor_id, $document_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdate'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling debtorDocumentPATCHRequestDebtorIDDocumentsDocumentIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Documents/{DocumentID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_type !== null) {
            $queryParams['DocumentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($file_id !== null) {
            $queryParams['FileID'] = ObjectSerializer::toQueryValue($file_id);
        }
        // query params
        if ($physical_file_name !== null) {
            $queryParams['PhysicalFileName'] = ObjectSerializer::toQueryValue($physical_file_name);
        }
        // query params
        if ($full_physical_file_name !== null) {
            $queryParams['FullPhysicalFileName'] = ObjectSerializer::toQueryValue($full_physical_file_name);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($file_binary !== null) {
            $queryParams['FileBinary'] = ObjectSerializer::toQueryValue($file_binary);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentPOSTRequestDebtorIDDocumentsPost
     *
     * Appends a document to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type document_type (optional)
     * @param  string $file_id file_id (optional)
     * @param  string $physical_file_name physical_file_name (optional)
     * @param  string $full_physical_file_name full_physical_file_name (optional)
     * @param  string $description description (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $file_binary file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Document
     */
    public function debtorDocumentPOSTRequestDebtorIDDocumentsPost($accept, $debtor_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        list($response) = $this->debtorDocumentPOSTRequestDebtorIDDocumentsPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);
        return $response;
    }

    /**
     * Operation debtorDocumentPOSTRequestDebtorIDDocumentsPostWithHttpInfo
     *
     * Appends a document to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentPOSTRequestDebtorIDDocumentsPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Document';
        $request = $this->debtorDocumentPOSTRequestDebtorIDDocumentsPostRequest($accept, $debtor_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentPOSTRequestDebtorIDDocumentsPostAsync
     *
     * Appends a document to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentPOSTRequestDebtorIDDocumentsPostAsync($accept, $debtor_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        return $this->debtorDocumentPOSTRequestDebtorIDDocumentsPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentPOSTRequestDebtorIDDocumentsPostAsyncWithHttpInfo
     *
     * Appends a document to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentPOSTRequestDebtorIDDocumentsPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Document';
        $request = $this->debtorDocumentPOSTRequestDebtorIDDocumentsPostRequest($accept, $debtor_id, $jiwa_stateful, $document_type, $file_id, $physical_file_name, $full_physical_file_name, $description, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $file_binary, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentPOSTRequestDebtorIDDocumentsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $document_type (optional)
     * @param  string $file_id (optional)
     * @param  string $physical_file_name (optional)
     * @param  string $full_physical_file_name (optional)
     * @param  string $description (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $file_binary (optional)
     * @param  \Jiwa\Model\DebtorDocumentPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentPOSTRequestDebtorIDDocumentsPostRequest($accept, $debtor_id, $jiwa_stateful = null, $document_type = null, $file_id = null, $physical_file_name = null, $full_physical_file_name = null, $description = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $file_binary = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentPOSTRequestDebtorIDDocumentsPost'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDocumentPOSTRequestDebtorIDDocumentsPost'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_type !== null) {
            $queryParams['DocumentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($file_id !== null) {
            $queryParams['FileID'] = ObjectSerializer::toQueryValue($file_id);
        }
        // query params
        if ($physical_file_name !== null) {
            $queryParams['PhysicalFileName'] = ObjectSerializer::toQueryValue($physical_file_name);
        }
        // query params
        if ($full_physical_file_name !== null) {
            $queryParams['FullPhysicalFileName'] = ObjectSerializer::toQueryValue($full_physical_file_name);
        }
        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($file_binary !== null) {
            $queryParams['FileBinary'] = ObjectSerializer::toQueryValue($file_binary);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete
     *
     * Deletes a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete($accept, $document_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo($accept, $document_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo
     *
     * Deletes a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsync
     *
     * Deletes a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsync($accept, $document_type_id, $jiwa_stateful = null)
    {
        return $this->debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDeleteRequest($accept, $document_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling debtorDocumentTypeDELETERequestDocumentTypesDocumentTypeIDDelete'
            );
        }

        $resourcePath = '/Debtors/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet
     *
     * Retrieves a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DocumentType
     */
    public function debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet($accept, $document_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo($accept, $document_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo
     *
     * Retrieves a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DocumentType';
        $request = $this->debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsync
     *
     * Retrieves a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsync($accept, $document_type_id, $jiwa_stateful = null)
    {
        return $this->debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DocumentType';
        $request = $this->debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGetRequest($accept, $document_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling debtorDocumentTypeGETRequestDocumentTypesDocumentTypeIDGet'
            );
        }

        $resourcePath = '/Debtors/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate
     *
     * Updates a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DocumentType
     */
    public function debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo
     *
     * Updates a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DocumentType';
        $request = $this->debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsync
     *
     * Updates a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsync($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateAsyncWithHttpInfo($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DocumentType';
        $request = $this->debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $document_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdateRequest($accept, $document_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
            );
        }
        // verify the required parameter 'document_type_id' is set
        if ($document_type_id === null || (is_array($document_type_id) && count($document_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type_id when calling debtorDocumentTypePATCHRequestDocumentTypesDocumentTypeIDUpdate'
            );
        }

        $resourcePath = '/Debtors/DocumentTypes/{DocumentTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($document_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DocumentTypeID' . '}',
                ObjectSerializer::toPathValue($document_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentTypePOSTRequestDocumentTypesPost
     *
     * Creates a new debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DocumentType
     */
    public function debtorDocumentTypePOSTRequestDocumentTypesPost($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->debtorDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation debtorDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo
     *
     * Creates a new debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DocumentType, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentTypePOSTRequestDocumentTypesPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DocumentType';
        $request = $this->debtorDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentTypePOSTRequestDocumentTypesPostAsync
     *
     * Creates a new debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypePOSTRequestDocumentTypesPostAsync($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->debtorDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo
     *
     * Creates a new debtor document type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypePOSTRequestDocumentTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DocumentType';
        $request = $this->debtorDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentTypePOSTRequestDocumentTypesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorDocumentTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentTypePOSTRequestDocumentTypesPostRequest($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentTypePOSTRequestDocumentTypesPost'
            );
        }

        $resourcePath = '/Debtors/DocumentTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentTypesGETManyRequestDocumentTypesGet
     *
     * Retrieves a list of debtor document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DocumentType[]
     */
    public function debtorDocumentTypesGETManyRequestDocumentTypesGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo
     *
     * Retrieves a list of debtor document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DocumentType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentTypesGETManyRequestDocumentTypesGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DocumentType[]';
        $request = $this->debtorDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DocumentType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentTypesGETManyRequestDocumentTypesGetAsync
     *
     * Retrieves a list of debtor document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypesGETManyRequestDocumentTypesGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->debtorDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor document types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentTypesGETManyRequestDocumentTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DocumentType[]';
        $request = $this->debtorDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentTypesGETManyRequestDocumentTypesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentTypesGETManyRequestDocumentTypesGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentTypesGETManyRequestDocumentTypesGet'
            );
        }

        $resourcePath = '/Debtors/DocumentTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorDocumentsGETManyRequestDebtorIDDocumentsGet
     *
     * Retrieves a list of debtor documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Document[]
     */
    public function debtorDocumentsGETManyRequestDebtorIDDocumentsGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorDocumentsGETManyRequestDebtorIDDocumentsGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorDocumentsGETManyRequestDebtorIDDocumentsGetWithHttpInfo
     *
     * Retrieves a list of debtor documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Document[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorDocumentsGETManyRequestDebtorIDDocumentsGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Document[]';
        $request = $this->debtorDocumentsGETManyRequestDebtorIDDocumentsGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorDocumentsGETManyRequestDebtorIDDocumentsGetAsync
     *
     * Retrieves a list of debtor documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentsGETManyRequestDebtorIDDocumentsGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorDocumentsGETManyRequestDebtorIDDocumentsGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorDocumentsGETManyRequestDebtorIDDocumentsGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor documents.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorDocumentsGETManyRequestDebtorIDDocumentsGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Document[]';
        $request = $this->debtorDocumentsGETManyRequestDebtorIDDocumentsGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorDocumentsGETManyRequestDebtorIDDocumentsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorDocumentsGETManyRequestDebtorIDDocumentsGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorDocumentsGETManyRequestDebtorIDDocumentsGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorDocumentsGETManyRequestDebtorIDDocumentsGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDelete
     *
     * Deletes a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $freight_forwarder_address_id freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $address2 address2 (optional)
     * @param  string $address3 address3 (optional)
     * @param  string $address4 address4 (optional)
     * @param  string $country country (optional)
     * @param  string $notes notes (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDelete($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null)
    {
        list($response) = $this->debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes);
        return $response;
    }

    /**
     * Operation debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteWithHttpInfo
     *
     * Deletes a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteAsync
     *
     * Deletes a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteAsync($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null)
    {
        return $this->debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDeleteRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDelete'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDelete'
            );
        }
        // verify the required parameter 'freight_forwarder_address_id' is set
        if ($freight_forwarder_address_id === null || (is_array($freight_forwarder_address_id) && count($freight_forwarder_address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $freight_forwarder_address_id when calling debtorFreightForwarderAddressDELETERequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDDelete'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/FreightForwarderAddresses/{FreightForwarderAddressID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($address1 !== null) {
            $queryParams['Address1'] = ObjectSerializer::toQueryValue($address1);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['Address2'] = ObjectSerializer::toQueryValue($address2);
        }
        // query params
        if ($address3 !== null) {
            $queryParams['Address3'] = ObjectSerializer::toQueryValue($address3);
        }
        // query params
        if ($address4 !== null) {
            $queryParams['Address4'] = ObjectSerializer::toQueryValue($address4);
        }
        // query params
        if ($country !== null) {
            $queryParams['Country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($freight_forwarder_address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'FreightForwarderAddressID' . '}',
                ObjectSerializer::toPathValue($freight_forwarder_address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGet
     *
     * Retrieves a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $freight_forwarder_address_id freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorFreightForwarderAddress
     */
    public function debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGet($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetWithHttpInfo
     *
     * Retrieves a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorFreightForwarderAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorFreightForwarderAddress';
        $request = $this->debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetAsync
     *
     * Retrieves a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetAsync($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null)
    {
        return $this->debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetAsyncWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetAsyncWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorFreightForwarderAddress';
        $request = $this->debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGetRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGet'
            );
        }
        // verify the required parameter 'freight_forwarder_address_id' is set
        if ($freight_forwarder_address_id === null || (is_array($freight_forwarder_address_id) && count($freight_forwarder_address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $freight_forwarder_address_id when calling debtorFreightForwarderAddressGETRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/FreightForwarderAddresses/{FreightForwarderAddressID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($freight_forwarder_address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'FreightForwarderAddressID' . '}',
                ObjectSerializer::toPathValue($freight_forwarder_address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdate
     *
     * Updates a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $freight_forwarder_address_id freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $address2 address2 (optional)
     * @param  string $address3 address3 (optional)
     * @param  string $address4 address4 (optional)
     * @param  string $country country (optional)
     * @param  string $notes notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorFreightForwarderAddress
     */
    public function debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdate($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        list($response) = $this->debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes, $body);
        return $response;
    }

    /**
     * Operation debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateWithHttpInfo
     *
     * Updates a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorFreightForwarderAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorFreightForwarderAddress';
        $request = $this->debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateAsync
     *
     * Updates a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateAsync($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        return $this->debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor freight forwarder address.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorFreightForwarderAddress';
        $request = $this->debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $freight_forwarder_address_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdateRequest($accept, $debtor_id, $freight_forwarder_address_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdate'
            );
        }
        // verify the required parameter 'freight_forwarder_address_id' is set
        if ($freight_forwarder_address_id === null || (is_array($freight_forwarder_address_id) && count($freight_forwarder_address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $freight_forwarder_address_id when calling debtorFreightForwarderAddressPATCHRequestDebtorIDFreightForwarderAddressesFreightForwarderAddressIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/FreightForwarderAddresses/{FreightForwarderAddressID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($address1 !== null) {
            $queryParams['Address1'] = ObjectSerializer::toQueryValue($address1);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['Address2'] = ObjectSerializer::toQueryValue($address2);
        }
        // query params
        if ($address3 !== null) {
            $queryParams['Address3'] = ObjectSerializer::toQueryValue($address3);
        }
        // query params
        if ($address4 !== null) {
            $queryParams['Address4'] = ObjectSerializer::toQueryValue($address4);
        }
        // query params
        if ($country !== null) {
            $queryParams['Country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($freight_forwarder_address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'FreightForwarderAddressID' . '}',
                ObjectSerializer::toPathValue($freight_forwarder_address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPost
     *
     * Appends a freight forwarder address to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $address2 address2 (optional)
     * @param  string $address3 address3 (optional)
     * @param  string $address4 address4 (optional)
     * @param  string $country country (optional)
     * @param  string $notes notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorFreightForwarderAddress
     */
    public function debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPost($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        list($response) = $this->debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes, $body);
        return $response;
    }

    /**
     * Operation debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostWithHttpInfo
     *
     * Appends a freight forwarder address to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorFreightForwarderAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorFreightForwarderAddress';
        $request = $this->debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostRequest($accept, $debtor_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostAsync
     *
     * Appends a freight forwarder address to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostAsync($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        return $this->debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostAsyncWithHttpInfo
     *
     * Appends a freight forwarder address to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorFreightForwarderAddress';
        $request = $this->debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostRequest($accept, $debtor_id, $jiwa_stateful, $is_default, $address1, $address2, $address3, $address4, $country, $notes, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $country (optional)
     * @param  string $notes (optional)
     * @param  \Jiwa\Model\DebtorFreightForwarderAddressPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPostRequest($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $country = null, $notes = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPost'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorFreightForwarderAddressPOSTRequestDebtorIDFreightForwarderAddressesPost'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/FreightForwarderAddresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($address1 !== null) {
            $queryParams['Address1'] = ObjectSerializer::toQueryValue($address1);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['Address2'] = ObjectSerializer::toQueryValue($address2);
        }
        // query params
        if ($address3 !== null) {
            $queryParams['Address3'] = ObjectSerializer::toQueryValue($address3);
        }
        // query params
        if ($address4 !== null) {
            $queryParams['Address4'] = ObjectSerializer::toQueryValue($address4);
        }
        // query params
        if ($country !== null) {
            $queryParams['Country'] = ObjectSerializer::toQueryValue($country);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGet
     *
     * Retrieves a list of debtor freight forwarder addresses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorFreightForwarderAddress[]
     */
    public function debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetWithHttpInfo
     *
     * Retrieves a list of debtor freight forwarder addresses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorFreightForwarderAddress[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorFreightForwarderAddress[]';
        $request = $this->debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorFreightForwarderAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetAsync
     *
     * Retrieves a list of debtor freight forwarder addresses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor freight forwarder addresses.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorFreightForwarderAddress[]';
        $request = $this->debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorFreightForwarderAddressesGETManyRequestDebtorIDFreightForwarderAddressesGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/FreightForwarderAddresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorGETRequestDebtorIDGet
     *
     * Retrieves a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Debtor
     */
    public function debtorGETRequestDebtorIDGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorGETRequestDebtorIDGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorGETRequestDebtorIDGetWithHttpInfo
     *
     * Retrieves a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Debtor, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorGETRequestDebtorIDGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorGETRequestDebtorIDGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorGETRequestDebtorIDGetAsync
     *
     * Retrieves a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGETRequestDebtorIDGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorGETRequestDebtorIDGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorGETRequestDebtorIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGETRequestDebtorIDGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorGETRequestDebtorIDGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorGETRequestDebtorIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorGETRequestDebtorIDGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorGETRequestDebtorIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorGETRequestDebtorIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDelete
     *
     * Deletes a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $group_membership_id group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $group_rec_id group_rec_id (optional)
     * @param  string $group_description group_description (optional)
     * @param  string $staff_id staff_id (optional)
     * @param  string $staff_username staff_username (optional)
     * @param  string $staff_title staff_title (optional)
     * @param  string $staff_first_name staff_first_name (optional)
     * @param  string $staff_surname staff_surname (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  int $item_no item_no (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDelete($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null)
    {
        list($response) = $this->debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $last_saved_date_time, $item_no);
        return $response;
    }

    /**
     * Operation debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteWithHttpInfo
     *
     * Deletes a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  int $item_no (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $last_saved_date_time, $item_no);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteAsync
     *
     * Deletes a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  int $item_no (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteAsync($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null)
    {
        return $this->debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $last_saved_date_time, $item_no)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  int $item_no (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $last_saved_date_time, $item_no);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  int $item_no (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDeleteRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDelete'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDelete'
            );
        }
        // verify the required parameter 'group_membership_id' is set
        if ($group_membership_id === null || (is_array($group_membership_id) && count($group_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_membership_id when calling debtorGroupMembershipDELETERequestDebtorIDGroupMembershipsGroupMembershipIDDelete'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/GroupMemberships/{GroupMembershipID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($group_rec_id !== null) {
            $queryParams['GroupRecID'] = ObjectSerializer::toQueryValue($group_rec_id);
        }
        // query params
        if ($group_description !== null) {
            $queryParams['GroupDescription'] = ObjectSerializer::toQueryValue($group_description);
        }
        // query params
        if ($staff_id !== null) {
            $queryParams['StaffID'] = ObjectSerializer::toQueryValue($staff_id);
        }
        // query params
        if ($staff_username !== null) {
            $queryParams['StaffUsername'] = ObjectSerializer::toQueryValue($staff_username);
        }
        // query params
        if ($staff_title !== null) {
            $queryParams['StaffTitle'] = ObjectSerializer::toQueryValue($staff_title);
        }
        // query params
        if ($staff_first_name !== null) {
            $queryParams['StaffFirstName'] = ObjectSerializer::toQueryValue($staff_first_name);
        }
        // query params
        if ($staff_surname !== null) {
            $queryParams['StaffSurname'] = ObjectSerializer::toQueryValue($staff_surname);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'GroupMembershipID' . '}',
                ObjectSerializer::toPathValue($group_membership_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGet
     *
     * Retrieves a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $group_membership_id group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorGroupMembership
     */
    public function debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGet($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetWithHttpInfo
     *
     * Retrieves a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorGroupMembership, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorGroupMembership';
        $request = $this->debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetAsync
     *
     * Retrieves a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetAsync($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null)
    {
        return $this->debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetAsyncWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetAsyncWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorGroupMembership';
        $request = $this->debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGetRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGet'
            );
        }
        // verify the required parameter 'group_membership_id' is set
        if ($group_membership_id === null || (is_array($group_membership_id) && count($group_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_membership_id when calling debtorGroupMembershipGETRequestDebtorIDGroupMembershipsGroupMembershipIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/GroupMemberships/{GroupMembershipID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'GroupMembershipID' . '}',
                ObjectSerializer::toPathValue($group_membership_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdate
     *
     * Updates a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $group_membership_id group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $group_rec_id group_rec_id (optional)
     * @param  string $group_description group_description (optional)
     * @param  string $staff_id staff_id (optional)
     * @param  string $staff_username staff_username (optional)
     * @param  string $staff_title staff_title (optional)
     * @param  string $staff_first_name staff_first_name (optional)
     * @param  string $staff_surname staff_surname (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorGroupMembership
     */
    public function debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdate($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null, $body = null)
    {
        list($response) = $this->debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $last_saved_date_time, $item_no, $body);
        return $response;
    }

    /**
     * Operation debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateWithHttpInfo
     *
     * Updates a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorGroupMembership, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorGroupMembership';
        $request = $this->debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $last_saved_date_time, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateAsync
     *
     * Updates a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateAsync($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null, $body = null)
    {
        return $this->debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $last_saved_date_time, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor group membership.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorGroupMembership';
        $request = $this->debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $last_saved_date_time, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $group_membership_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdateRequest($accept, $debtor_id, $group_membership_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $last_saved_date_time = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdate'
            );
        }
        // verify the required parameter 'group_membership_id' is set
        if ($group_membership_id === null || (is_array($group_membership_id) && count($group_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_membership_id when calling debtorGroupMembershipPATCHRequestDebtorIDGroupMembershipsGroupMembershipIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/GroupMemberships/{GroupMembershipID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($group_rec_id !== null) {
            $queryParams['GroupRecID'] = ObjectSerializer::toQueryValue($group_rec_id);
        }
        // query params
        if ($group_description !== null) {
            $queryParams['GroupDescription'] = ObjectSerializer::toQueryValue($group_description);
        }
        // query params
        if ($staff_id !== null) {
            $queryParams['StaffID'] = ObjectSerializer::toQueryValue($staff_id);
        }
        // query params
        if ($staff_username !== null) {
            $queryParams['StaffUsername'] = ObjectSerializer::toQueryValue($staff_username);
        }
        // query params
        if ($staff_title !== null) {
            $queryParams['StaffTitle'] = ObjectSerializer::toQueryValue($staff_title);
        }
        // query params
        if ($staff_first_name !== null) {
            $queryParams['StaffFirstName'] = ObjectSerializer::toQueryValue($staff_first_name);
        }
        // query params
        if ($staff_surname !== null) {
            $queryParams['StaffSurname'] = ObjectSerializer::toQueryValue($staff_surname);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'GroupMembershipID' . '}',
                ObjectSerializer::toPathValue($group_membership_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPost
     *
     * Appends a group membership to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default is_default (optional)
     * @param  string $group_rec_id group_rec_id (optional)
     * @param  string $group_description group_description (optional)
     * @param  string $staff_id staff_id (optional)
     * @param  string $staff_username staff_username (optional)
     * @param  string $staff_title staff_title (optional)
     * @param  string $staff_first_name staff_first_name (optional)
     * @param  string $staff_surname staff_surname (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorGroupMembership
     */
    public function debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPost($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $item_no = null, $body = null)
    {
        list($response) = $this->debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $item_no, $body);
        return $response;
    }

    /**
     * Operation debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostWithHttpInfo
     *
     * Appends a group membership to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorGroupMembership, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorGroupMembership';
        $request = $this->debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostRequest($accept, $debtor_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostAsync
     *
     * Appends a group membership to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostAsync($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $item_no = null, $body = null)
    {
        return $this->debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostAsyncWithHttpInfo
     *
     * Appends a group membership to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorGroupMembership';
        $request = $this->debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostRequest($accept, $debtor_id, $jiwa_stateful, $is_default, $group_rec_id, $group_description, $staff_id, $staff_username, $staff_title, $staff_first_name, $staff_surname, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  bool $is_default (optional)
     * @param  string $group_rec_id (optional)
     * @param  string $group_description (optional)
     * @param  string $staff_id (optional)
     * @param  string $staff_username (optional)
     * @param  string $staff_title (optional)
     * @param  string $staff_first_name (optional)
     * @param  string $staff_surname (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorGroupMembershipPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPostRequest($accept, $debtor_id, $jiwa_stateful = null, $is_default = null, $group_rec_id = null, $group_description = null, $staff_id = null, $staff_username = null, $staff_title = null, $staff_first_name = null, $staff_surname = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPost'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorGroupMembershipPOSTRequestDebtorIDGroupMembershipsPost'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/GroupMemberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($group_rec_id !== null) {
            $queryParams['GroupRecID'] = ObjectSerializer::toQueryValue($group_rec_id);
        }
        // query params
        if ($group_description !== null) {
            $queryParams['GroupDescription'] = ObjectSerializer::toQueryValue($group_description);
        }
        // query params
        if ($staff_id !== null) {
            $queryParams['StaffID'] = ObjectSerializer::toQueryValue($staff_id);
        }
        // query params
        if ($staff_username !== null) {
            $queryParams['StaffUsername'] = ObjectSerializer::toQueryValue($staff_username);
        }
        // query params
        if ($staff_title !== null) {
            $queryParams['StaffTitle'] = ObjectSerializer::toQueryValue($staff_title);
        }
        // query params
        if ($staff_first_name !== null) {
            $queryParams['StaffFirstName'] = ObjectSerializer::toQueryValue($staff_first_name);
        }
        // query params
        if ($staff_surname !== null) {
            $queryParams['StaffSurname'] = ObjectSerializer::toQueryValue($staff_surname);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGet
     *
     * Retrieves a list of debtor group memberships.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorGroupMembership[]
     */
    public function debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetWithHttpInfo
     *
     * Retrieves a list of debtor group memberships.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorGroupMembership[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorGroupMembership[]';
        $request = $this->debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorGroupMembership[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetAsync
     *
     * Retrieves a list of debtor group memberships.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor group memberships.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorGroupMembership[]';
        $request = $this->debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorGroupMembershipsGETManyRequestDebtorIDGroupMembershipsGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/GroupMemberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNoteDELETERequestDebtorIDNotesNoteIDDelete
     *
     * Deletes a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorNoteDELETERequestDebtorIDNotesNoteIDDelete($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteWithHttpInfo
     *
     * Deletes a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteRequest($accept, $debtor_id, $note_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteAsync
     *
     * Deletes a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteAsync($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        return $this->debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteRequest($accept, $debtor_id, $note_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNoteDELETERequestDebtorIDNotesNoteIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNoteDELETERequestDebtorIDNotesNoteIDDeleteRequest($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNoteDELETERequestDebtorIDNotesNoteIDDelete'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorNoteDELETERequestDebtorIDNotesNoteIDDelete'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling debtorNoteDELETERequestDebtorIDNotesNoteIDDelete'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNoteGETRequestDebtorIDNotesNoteIDGet
     *
     * Retrieves a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Note
     */
    public function debtorNoteGETRequestDebtorIDNotesNoteIDGet($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorNoteGETRequestDebtorIDNotesNoteIDGetWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorNoteGETRequestDebtorIDNotesNoteIDGetWithHttpInfo
     *
     * Retrieves a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNoteGETRequestDebtorIDNotesNoteIDGetWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Note';
        $request = $this->debtorNoteGETRequestDebtorIDNotesNoteIDGetRequest($accept, $debtor_id, $note_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNoteGETRequestDebtorIDNotesNoteIDGetAsync
     *
     * Retrieves a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteGETRequestDebtorIDNotesNoteIDGetAsync($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        return $this->debtorNoteGETRequestDebtorIDNotesNoteIDGetAsyncWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNoteGETRequestDebtorIDNotesNoteIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteGETRequestDebtorIDNotesNoteIDGetAsyncWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Note';
        $request = $this->debtorNoteGETRequestDebtorIDNotesNoteIDGetRequest($accept, $debtor_id, $note_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNoteGETRequestDebtorIDNotesNoteIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNoteGETRequestDebtorIDNotesNoteIDGetRequest($accept, $debtor_id, $note_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNoteGETRequestDebtorIDNotesNoteIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorNoteGETRequestDebtorIDNotesNoteIDGet'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling debtorNoteGETRequestDebtorIDNotesNoteIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNotePATCHRequestDebtorIDNotesNoteIDUpdate
     *
     * Updates a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $note_id note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type note_type (optional)
     * @param  int $line_no line_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $note_text note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Note
     */
    public function debtorNotePATCHRequestDebtorIDNotesNoteIDUpdate($accept, $debtor_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        list($response) = $this->debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);
        return $response;
    }

    /**
     * Operation debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateWithHttpInfo
     *
     * Updates a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Note';
        $request = $this->debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateRequest($accept, $debtor_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateAsync
     *
     * Updates a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateAsync($accept, $debtor_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        return $this->debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor note.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Note';
        $request = $this->debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateRequest($accept, $debtor_id, $note_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNotePATCHRequestDebtorIDNotesNoteIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $note_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNotePATCHRequestDebtorIDNotesNoteIDUpdateRequest($accept, $debtor_id, $note_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNotePATCHRequestDebtorIDNotesNoteIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorNotePATCHRequestDebtorIDNotesNoteIDUpdate'
            );
        }
        // verify the required parameter 'note_id' is set
        if ($note_id === null || (is_array($note_id) && count($note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_id when calling debtorNotePATCHRequestDebtorIDNotesNoteIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Notes/{NoteID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($note_type !== null) {
            $queryParams['NoteType'] = ObjectSerializer::toQueryValue($note_type);
        }
        // query params
        if ($line_no !== null) {
            $queryParams['LineNo'] = ObjectSerializer::toQueryValue($line_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($note_text !== null) {
            $queryParams['NoteText'] = ObjectSerializer::toQueryValue($note_text);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteID' . '}',
                ObjectSerializer::toPathValue($note_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNotePOSTRequestDebtorIDNotesPost
     *
     * Appends a note to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type note_type (optional)
     * @param  int $line_no line_no (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname last_modified_by_staff_surname (optional)
     * @param  string $note_text note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Note
     */
    public function debtorNotePOSTRequestDebtorIDNotesPost($accept, $debtor_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        list($response) = $this->debtorNotePOSTRequestDebtorIDNotesPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);
        return $response;
    }

    /**
     * Operation debtorNotePOSTRequestDebtorIDNotesPostWithHttpInfo
     *
     * Appends a note to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Note, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNotePOSTRequestDebtorIDNotesPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Note';
        $request = $this->debtorNotePOSTRequestDebtorIDNotesPostRequest($accept, $debtor_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNotePOSTRequestDebtorIDNotesPostAsync
     *
     * Appends a note to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNotePOSTRequestDebtorIDNotesPostAsync($accept, $debtor_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        return $this->debtorNotePOSTRequestDebtorIDNotesPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNotePOSTRequestDebtorIDNotesPostAsyncWithHttpInfo
     *
     * Appends a note to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNotePOSTRequestDebtorIDNotesPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Note';
        $request = $this->debtorNotePOSTRequestDebtorIDNotesPostRequest($accept, $debtor_id, $jiwa_stateful, $note_type, $line_no, $last_saved_date_time, $last_modified_by_staff_id, $last_modified_by_staff_username, $last_modified_by_staff_title, $last_modified_by_staff_first_name, $last_modified_by_staff_surname, $note_text, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNotePOSTRequestDebtorIDNotesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $note_type (optional)
     * @param  int $line_no (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $last_modified_by_staff_id (optional)
     * @param  string $last_modified_by_staff_username (optional)
     * @param  string $last_modified_by_staff_title (optional)
     * @param  string $last_modified_by_staff_first_name (optional)
     * @param  string $last_modified_by_staff_surname (optional)
     * @param  string $note_text (optional)
     * @param  \Jiwa\Model\DebtorNotePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNotePOSTRequestDebtorIDNotesPostRequest($accept, $debtor_id, $jiwa_stateful = null, $note_type = null, $line_no = null, $last_saved_date_time = null, $last_modified_by_staff_id = null, $last_modified_by_staff_username = null, $last_modified_by_staff_title = null, $last_modified_by_staff_first_name = null, $last_modified_by_staff_surname = null, $note_text = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNotePOSTRequestDebtorIDNotesPost'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorNotePOSTRequestDebtorIDNotesPost'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($note_type !== null) {
            $queryParams['NoteType'] = ObjectSerializer::toQueryValue($note_type);
        }
        // query params
        if ($line_no !== null) {
            $queryParams['LineNo'] = ObjectSerializer::toQueryValue($line_no);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($last_modified_by_staff_id !== null) {
            $queryParams['LastModifiedByStaffID'] = ObjectSerializer::toQueryValue($last_modified_by_staff_id);
        }
        // query params
        if ($last_modified_by_staff_username !== null) {
            $queryParams['LastModifiedByStaffUsername'] = ObjectSerializer::toQueryValue($last_modified_by_staff_username);
        }
        // query params
        if ($last_modified_by_staff_title !== null) {
            $queryParams['LastModifiedByStaffTitle'] = ObjectSerializer::toQueryValue($last_modified_by_staff_title);
        }
        // query params
        if ($last_modified_by_staff_first_name !== null) {
            $queryParams['LastModifiedByStaffFirstName'] = ObjectSerializer::toQueryValue($last_modified_by_staff_first_name);
        }
        // query params
        if ($last_modified_by_staff_surname !== null) {
            $queryParams['LastModifiedByStaffSurname'] = ObjectSerializer::toQueryValue($last_modified_by_staff_surname);
        }
        // query params
        if ($note_text !== null) {
            $queryParams['NoteText'] = ObjectSerializer::toQueryValue($note_text);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDelete
     *
     * Deletes a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDelete($accept, $note_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo($accept, $note_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo
     *
     * Deletes a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsync
     *
     * Deletes a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsync($accept, $note_type_id, $jiwa_stateful = null)
    {
        return $this->debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDeleteRequest($accept, $note_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling debtorNoteTypeDELETERequestNoteTypesNoteTypeIDDelete'
            );
        }

        $resourcePath = '/Debtors/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNoteTypeGETRequestNoteTypesNoteTypeIDGet
     *
     * Retrieves a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\NoteType
     */
    public function debtorNoteTypeGETRequestNoteTypesNoteTypeIDGet($accept, $note_type_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo($accept, $note_type_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo
     *
     * Retrieves a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\NoteType';
        $request = $this->debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetAsync
     *
     * Retrieves a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetAsync($accept, $note_type_id, $jiwa_stateful = null)
    {
        return $this->debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\NoteType';
        $request = $this->debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNoteTypeGETRequestNoteTypesNoteTypeIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNoteTypeGETRequestNoteTypesNoteTypeIDGetRequest($accept, $note_type_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNoteTypeGETRequestNoteTypesNoteTypeIDGet'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling debtorNoteTypeGETRequestNoteTypesNoteTypeIDGet'
            );
        }

        $resourcePath = '/Debtors/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate
     *
     * Updates a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\NoteType
     */
    public function debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo
     *
     * Updates a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\NoteType';
        $request = $this->debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsync
     *
     * Updates a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsync($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateAsyncWithHttpInfo($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\NoteType';
        $request = $this->debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $note_type_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdateRequest($accept, $note_type_id, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
            );
        }
        // verify the required parameter 'note_type_id' is set
        if ($note_type_id === null || (is_array($note_type_id) && count($note_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_type_id when calling debtorNoteTypePATCHRequestNoteTypesNoteTypeIDUpdate'
            );
        }

        $resourcePath = '/Debtors/NoteTypes/{NoteTypeID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($note_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'NoteTypeID' . '}',
                ObjectSerializer::toPathValue($note_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNoteTypePOSTRequestNoteTypesPost
     *
     * Creates a new debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $default_type default_type (optional)
     * @param  int $item_no item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\NoteType
     */
    public function debtorNoteTypePOSTRequestNoteTypesPost($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        list($response) = $this->debtorNoteTypePOSTRequestNoteTypesPostWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);
        return $response;
    }

    /**
     * Operation debtorNoteTypePOSTRequestNoteTypesPostWithHttpInfo
     *
     * Creates a new debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\NoteType, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNoteTypePOSTRequestNoteTypesPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\NoteType';
        $request = $this->debtorNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNoteTypePOSTRequestNoteTypesPostAsync
     *
     * Creates a new debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypePOSTRequestNoteTypesPostAsync($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        return $this->debtorNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $default_type, $item_no, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo
     *
     * Creates a new debtor note type.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypePOSTRequestNoteTypesPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        $returnType = '\Jiwa\Model\NoteType';
        $request = $this->debtorNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful, $description, $default_type, $item_no, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNoteTypePOSTRequestNoteTypesPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $default_type (optional)
     * @param  int $item_no (optional)
     * @param  \Jiwa\Model\DebtorNoteTypePOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNoteTypePOSTRequestNoteTypesPostRequest($accept, $jiwa_stateful = null, $description = null, $default_type = null, $item_no = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNoteTypePOSTRequestNoteTypesPost'
            );
        }

        $resourcePath = '/Debtors/NoteTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($default_type !== null) {
            $queryParams['DefaultType'] = ObjectSerializer::toQueryValue($default_type);
        }
        // query params
        if ($item_no !== null) {
            $queryParams['ItemNo'] = ObjectSerializer::toQueryValue($item_no);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNoteTypesGETManyRequestNoteTypesGet
     *
     * Retrieves a list of debtor note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\NoteType[]
     */
    public function debtorNoteTypesGETManyRequestNoteTypesGet($accept, $jiwa_stateful = null)
    {
        list($response) = $this->debtorNoteTypesGETManyRequestNoteTypesGetWithHttpInfo($accept, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorNoteTypesGETManyRequestNoteTypesGetWithHttpInfo
     *
     * Retrieves a list of debtor note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\NoteType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNoteTypesGETManyRequestNoteTypesGetWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\NoteType[]';
        $request = $this->debtorNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\NoteType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNoteTypesGETManyRequestNoteTypesGetAsync
     *
     * Retrieves a list of debtor note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypesGETManyRequestNoteTypesGetAsync($accept, $jiwa_stateful = null)
    {
        return $this->debtorNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor note types.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNoteTypesGETManyRequestNoteTypesGetAsyncWithHttpInfo($accept, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\NoteType[]';
        $request = $this->debtorNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNoteTypesGETManyRequestNoteTypesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNoteTypesGETManyRequestNoteTypesGetRequest($accept, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNoteTypesGETManyRequestNoteTypesGet'
            );
        }

        $resourcePath = '/Debtors/NoteTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorNotesGETManyRequestDebtorIDNotesGet
     *
     * Retrieves a list of debtor notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Note[]
     */
    public function debtorNotesGETManyRequestDebtorIDNotesGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorNotesGETManyRequestDebtorIDNotesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorNotesGETManyRequestDebtorIDNotesGetWithHttpInfo
     *
     * Retrieves a list of debtor notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Note[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorNotesGETManyRequestDebtorIDNotesGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Note[]';
        $request = $this->debtorNotesGETManyRequestDebtorIDNotesGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Note[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorNotesGETManyRequestDebtorIDNotesGetAsync
     *
     * Retrieves a list of debtor notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNotesGETManyRequestDebtorIDNotesGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorNotesGETManyRequestDebtorIDNotesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorNotesGETManyRequestDebtorIDNotesGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor notes.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorNotesGETManyRequestDebtorIDNotesGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Note[]';
        $request = $this->debtorNotesGETManyRequestDebtorIDNotesGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorNotesGETManyRequestDebtorIDNotesGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorNotesGETManyRequestDebtorIDNotesGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorNotesGETManyRequestDebtorIDNotesGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorNotesGETManyRequestDebtorIDNotesGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/Notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPATCHRequestDebtorIDUpdate
     *
     * Updates a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit credit_limit (optional)
     * @param  int $early_payment_discount_days early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date last_purchase_date (optional)
     * @param  \DateTime $last_payment_date last_payment_date (optional)
     * @param  double $standing_discount_on_invoices standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold account_on_hold (optional)
     * @param  double $current_balance current_balance (optional)
     * @param  double $period1_balance period1_balance (optional)
     * @param  double $period2_balance period2_balance (optional)
     * @param  double $period3_balance period3_balance (optional)
     * @param  double $period4_balance period4_balance (optional)
     * @param  double $fx_current_balance fx_current_balance (optional)
     * @param  double $fx_period1_balance fx_period1_balance (optional)
     * @param  double $fx_period2_balance fx_period2_balance (optional)
     * @param  double $fx_period3_balance fx_period3_balance (optional)
     * @param  double $fx_period4_balance fx_period4_balance (optional)
     * @param  bool $notify_required notify_required (optional)
     * @param  bool $web_access web_access (optional)
     * @param  \DateTime $commence_date commence_date (optional)
     * @param  string $trading_status trading_status (optional)
     * @param  string $period_type period_type (optional)
     * @param  bool $uses_fx uses_fx (optional)
     * @param  bool $is_cash_only is_cash_only (optional)
     * @param  int $terms_days terms_days (optional)
     * @param  string $terms_type terms_type (optional)
     * @param  bool $exclude_from_aging exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places fx_decimal_places (optional)
     * @param  string $prospect_id prospect_id (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  string $account_no account_no (optional)
     * @param  string $alt_account_no alt_account_no (optional)
     * @param  string $name name (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $address2 address2 (optional)
     * @param  string $address3 address3 (optional)
     * @param  string $address4 address4 (optional)
     * @param  string $postcode postcode (optional)
     * @param  string $phone phone (optional)
     * @param  string $fax fax (optional)
     * @param  string $email_address email_address (optional)
     * @param  string $acn acn (optional)
     * @param  string $abn abn (optional)
     * @param  string $aust_post_dpid aust_post_dpid (optional)
     * @param  string $aust_post_bcsp aust_post_bcsp (optional)
     * @param  string $bank_name bank_name (optional)
     * @param  string $bank_account_no bank_account_no (optional)
     * @param  string $bank_bsbn bank_bsbn (optional)
     * @param  string $bank_account_name bank_account_name (optional)
     * @param  string $tax_exemption_no tax_exemption_no (optional)
     * @param  string $notify_address notify_address (optional)
     * @param  string $parent_debtor_id parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name parent_debtor_name (optional)
     * @param  string $price_scheme_id price_scheme_id (optional)
     * @param  string $price_scheme_description price_scheme_description (optional)
     * @param  string $trading_name trading_name (optional)
     * @param  string $company_name company_name (optional)
     * @param  string $proprietors_name proprietors_name (optional)
     * @param  string $fax_header fax_header (optional)
     * @param  string $fxid fxid (optional)
     * @param  string $fx_name fx_name (optional)
     * @param  string $fx_short_name fx_short_name (optional)
     * @param  string $b_pay_reference b_pay_reference (optional)
     * @param  string $classification classification (optional)
     * @param  string $category1 category1 (optional)
     * @param  string $category2 category2 (optional)
     * @param  string $category3 category3 (optional)
     * @param  string $category4 category4 (optional)
     * @param  string $category5 category5 (optional)
     * @param  string $contact_names contact_names (optional)
     * @param  string $group_memberships group_memberships (optional)
     * @param  string $branch_debtors branch_debtors (optional)
     * @param  string $delivery_addresses delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses freight_forwarder_addresses (optional)
     * @param  string $notes notes (optional)
     * @param  string $credit_notes credit_notes (optional)
     * @param  string $directors directors (optional)
     * @param  string $budgets budgets (optional)
     * @param  string $debtor_part_numbers debtor_part_numbers (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $documents documents (optional)
     * @param  string $debtor_systems debtor_systems (optional)
     * @param  string $debtor_ledgers debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Debtor
     */
    public function debtorPATCHRequestDebtorIDUpdate($accept, $debtor_id, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $last_saved_date_time = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        list($response) = $this->debtorPATCHRequestDebtorIDUpdateWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $credit_limit, $early_payment_discount_days, $early_payment_discount_amount, $last_purchase_date, $last_payment_date, $standing_discount_on_invoices, $account_on_hold, $current_balance, $period1_balance, $period2_balance, $period3_balance, $period4_balance, $fx_current_balance, $fx_period1_balance, $fx_period2_balance, $fx_period3_balance, $fx_period4_balance, $notify_required, $web_access, $commence_date, $trading_status, $period_type, $uses_fx, $is_cash_only, $terms_days, $terms_type, $exclude_from_aging, $debtor_is_branch_account, $remaining_normal_prepaid_labour_pack_hours, $remaining_special_prepaid_labour_pack_hours, $fx_decimal_places, $prospect_id, $last_saved_date_time, $account_no, $alt_account_no, $name, $address1, $address2, $address3, $address4, $postcode, $phone, $fax, $email_address, $acn, $abn, $aust_post_dpid, $aust_post_bcsp, $bank_name, $bank_account_no, $bank_bsbn, $bank_account_name, $tax_exemption_no, $notify_address, $parent_debtor_id, $parent_debtor_account_no, $parent_debtor_name, $price_scheme_id, $price_scheme_description, $trading_name, $company_name, $proprietors_name, $fax_header, $fxid, $fx_name, $fx_short_name, $b_pay_reference, $classification, $category1, $category2, $category3, $category4, $category5, $contact_names, $group_memberships, $branch_debtors, $delivery_addresses, $freight_forwarder_addresses, $notes, $credit_notes, $directors, $budgets, $debtor_part_numbers, $custom_field_values, $documents, $debtor_systems, $debtor_ledgers, $body);
        return $response;
    }

    /**
     * Operation debtorPATCHRequestDebtorIDUpdateWithHttpInfo
     *
     * Updates a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit (optional)
     * @param  int $early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date (optional)
     * @param  \DateTime $last_payment_date (optional)
     * @param  double $standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold (optional)
     * @param  double $current_balance (optional)
     * @param  double $period1_balance (optional)
     * @param  double $period2_balance (optional)
     * @param  double $period3_balance (optional)
     * @param  double $period4_balance (optional)
     * @param  double $fx_current_balance (optional)
     * @param  double $fx_period1_balance (optional)
     * @param  double $fx_period2_balance (optional)
     * @param  double $fx_period3_balance (optional)
     * @param  double $fx_period4_balance (optional)
     * @param  bool $notify_required (optional)
     * @param  bool $web_access (optional)
     * @param  \DateTime $commence_date (optional)
     * @param  string $trading_status (optional)
     * @param  string $period_type (optional)
     * @param  bool $uses_fx (optional)
     * @param  bool $is_cash_only (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  bool $exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places (optional)
     * @param  string $prospect_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $account_no (optional)
     * @param  string $alt_account_no (optional)
     * @param  string $name (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $phone (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $acn (optional)
     * @param  string $abn (optional)
     * @param  string $aust_post_dpid (optional)
     * @param  string $aust_post_bcsp (optional)
     * @param  string $bank_name (optional)
     * @param  string $bank_account_no (optional)
     * @param  string $bank_bsbn (optional)
     * @param  string $bank_account_name (optional)
     * @param  string $tax_exemption_no (optional)
     * @param  string $notify_address (optional)
     * @param  string $parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name (optional)
     * @param  string $price_scheme_id (optional)
     * @param  string $price_scheme_description (optional)
     * @param  string $trading_name (optional)
     * @param  string $company_name (optional)
     * @param  string $proprietors_name (optional)
     * @param  string $fax_header (optional)
     * @param  string $fxid (optional)
     * @param  string $fx_name (optional)
     * @param  string $fx_short_name (optional)
     * @param  string $b_pay_reference (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $contact_names (optional)
     * @param  string $group_memberships (optional)
     * @param  string $branch_debtors (optional)
     * @param  string $delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses (optional)
     * @param  string $notes (optional)
     * @param  string $credit_notes (optional)
     * @param  string $directors (optional)
     * @param  string $budgets (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $documents (optional)
     * @param  string $debtor_systems (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Debtor, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPATCHRequestDebtorIDUpdateWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $last_saved_date_time = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorPATCHRequestDebtorIDUpdateRequest($accept, $debtor_id, $jiwa_stateful, $credit_limit, $early_payment_discount_days, $early_payment_discount_amount, $last_purchase_date, $last_payment_date, $standing_discount_on_invoices, $account_on_hold, $current_balance, $period1_balance, $period2_balance, $period3_balance, $period4_balance, $fx_current_balance, $fx_period1_balance, $fx_period2_balance, $fx_period3_balance, $fx_period4_balance, $notify_required, $web_access, $commence_date, $trading_status, $period_type, $uses_fx, $is_cash_only, $terms_days, $terms_type, $exclude_from_aging, $debtor_is_branch_account, $remaining_normal_prepaid_labour_pack_hours, $remaining_special_prepaid_labour_pack_hours, $fx_decimal_places, $prospect_id, $last_saved_date_time, $account_no, $alt_account_no, $name, $address1, $address2, $address3, $address4, $postcode, $phone, $fax, $email_address, $acn, $abn, $aust_post_dpid, $aust_post_bcsp, $bank_name, $bank_account_no, $bank_bsbn, $bank_account_name, $tax_exemption_no, $notify_address, $parent_debtor_id, $parent_debtor_account_no, $parent_debtor_name, $price_scheme_id, $price_scheme_description, $trading_name, $company_name, $proprietors_name, $fax_header, $fxid, $fx_name, $fx_short_name, $b_pay_reference, $classification, $category1, $category2, $category3, $category4, $category5, $contact_names, $group_memberships, $branch_debtors, $delivery_addresses, $freight_forwarder_addresses, $notes, $credit_notes, $directors, $budgets, $debtor_part_numbers, $custom_field_values, $documents, $debtor_systems, $debtor_ledgers, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPATCHRequestDebtorIDUpdateAsync
     *
     * Updates a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit (optional)
     * @param  int $early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date (optional)
     * @param  \DateTime $last_payment_date (optional)
     * @param  double $standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold (optional)
     * @param  double $current_balance (optional)
     * @param  double $period1_balance (optional)
     * @param  double $period2_balance (optional)
     * @param  double $period3_balance (optional)
     * @param  double $period4_balance (optional)
     * @param  double $fx_current_balance (optional)
     * @param  double $fx_period1_balance (optional)
     * @param  double $fx_period2_balance (optional)
     * @param  double $fx_period3_balance (optional)
     * @param  double $fx_period4_balance (optional)
     * @param  bool $notify_required (optional)
     * @param  bool $web_access (optional)
     * @param  \DateTime $commence_date (optional)
     * @param  string $trading_status (optional)
     * @param  string $period_type (optional)
     * @param  bool $uses_fx (optional)
     * @param  bool $is_cash_only (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  bool $exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places (optional)
     * @param  string $prospect_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $account_no (optional)
     * @param  string $alt_account_no (optional)
     * @param  string $name (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $phone (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $acn (optional)
     * @param  string $abn (optional)
     * @param  string $aust_post_dpid (optional)
     * @param  string $aust_post_bcsp (optional)
     * @param  string $bank_name (optional)
     * @param  string $bank_account_no (optional)
     * @param  string $bank_bsbn (optional)
     * @param  string $bank_account_name (optional)
     * @param  string $tax_exemption_no (optional)
     * @param  string $notify_address (optional)
     * @param  string $parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name (optional)
     * @param  string $price_scheme_id (optional)
     * @param  string $price_scheme_description (optional)
     * @param  string $trading_name (optional)
     * @param  string $company_name (optional)
     * @param  string $proprietors_name (optional)
     * @param  string $fax_header (optional)
     * @param  string $fxid (optional)
     * @param  string $fx_name (optional)
     * @param  string $fx_short_name (optional)
     * @param  string $b_pay_reference (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $contact_names (optional)
     * @param  string $group_memberships (optional)
     * @param  string $branch_debtors (optional)
     * @param  string $delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses (optional)
     * @param  string $notes (optional)
     * @param  string $credit_notes (optional)
     * @param  string $directors (optional)
     * @param  string $budgets (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $documents (optional)
     * @param  string $debtor_systems (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPATCHRequestDebtorIDUpdateAsync($accept, $debtor_id, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $last_saved_date_time = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        return $this->debtorPATCHRequestDebtorIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $credit_limit, $early_payment_discount_days, $early_payment_discount_amount, $last_purchase_date, $last_payment_date, $standing_discount_on_invoices, $account_on_hold, $current_balance, $period1_balance, $period2_balance, $period3_balance, $period4_balance, $fx_current_balance, $fx_period1_balance, $fx_period2_balance, $fx_period3_balance, $fx_period4_balance, $notify_required, $web_access, $commence_date, $trading_status, $period_type, $uses_fx, $is_cash_only, $terms_days, $terms_type, $exclude_from_aging, $debtor_is_branch_account, $remaining_normal_prepaid_labour_pack_hours, $remaining_special_prepaid_labour_pack_hours, $fx_decimal_places, $prospect_id, $last_saved_date_time, $account_no, $alt_account_no, $name, $address1, $address2, $address3, $address4, $postcode, $phone, $fax, $email_address, $acn, $abn, $aust_post_dpid, $aust_post_bcsp, $bank_name, $bank_account_no, $bank_bsbn, $bank_account_name, $tax_exemption_no, $notify_address, $parent_debtor_id, $parent_debtor_account_no, $parent_debtor_name, $price_scheme_id, $price_scheme_description, $trading_name, $company_name, $proprietors_name, $fax_header, $fxid, $fx_name, $fx_short_name, $b_pay_reference, $classification, $category1, $category2, $category3, $category4, $category5, $contact_names, $group_memberships, $branch_debtors, $delivery_addresses, $freight_forwarder_addresses, $notes, $credit_notes, $directors, $budgets, $debtor_part_numbers, $custom_field_values, $documents, $debtor_systems, $debtor_ledgers, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPATCHRequestDebtorIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit (optional)
     * @param  int $early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date (optional)
     * @param  \DateTime $last_payment_date (optional)
     * @param  double $standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold (optional)
     * @param  double $current_balance (optional)
     * @param  double $period1_balance (optional)
     * @param  double $period2_balance (optional)
     * @param  double $period3_balance (optional)
     * @param  double $period4_balance (optional)
     * @param  double $fx_current_balance (optional)
     * @param  double $fx_period1_balance (optional)
     * @param  double $fx_period2_balance (optional)
     * @param  double $fx_period3_balance (optional)
     * @param  double $fx_period4_balance (optional)
     * @param  bool $notify_required (optional)
     * @param  bool $web_access (optional)
     * @param  \DateTime $commence_date (optional)
     * @param  string $trading_status (optional)
     * @param  string $period_type (optional)
     * @param  bool $uses_fx (optional)
     * @param  bool $is_cash_only (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  bool $exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places (optional)
     * @param  string $prospect_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $account_no (optional)
     * @param  string $alt_account_no (optional)
     * @param  string $name (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $phone (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $acn (optional)
     * @param  string $abn (optional)
     * @param  string $aust_post_dpid (optional)
     * @param  string $aust_post_bcsp (optional)
     * @param  string $bank_name (optional)
     * @param  string $bank_account_no (optional)
     * @param  string $bank_bsbn (optional)
     * @param  string $bank_account_name (optional)
     * @param  string $tax_exemption_no (optional)
     * @param  string $notify_address (optional)
     * @param  string $parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name (optional)
     * @param  string $price_scheme_id (optional)
     * @param  string $price_scheme_description (optional)
     * @param  string $trading_name (optional)
     * @param  string $company_name (optional)
     * @param  string $proprietors_name (optional)
     * @param  string $fax_header (optional)
     * @param  string $fxid (optional)
     * @param  string $fx_name (optional)
     * @param  string $fx_short_name (optional)
     * @param  string $b_pay_reference (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $contact_names (optional)
     * @param  string $group_memberships (optional)
     * @param  string $branch_debtors (optional)
     * @param  string $delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses (optional)
     * @param  string $notes (optional)
     * @param  string $credit_notes (optional)
     * @param  string $directors (optional)
     * @param  string $budgets (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $documents (optional)
     * @param  string $debtor_systems (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPATCHRequestDebtorIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $last_saved_date_time = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorPATCHRequestDebtorIDUpdateRequest($accept, $debtor_id, $jiwa_stateful, $credit_limit, $early_payment_discount_days, $early_payment_discount_amount, $last_purchase_date, $last_payment_date, $standing_discount_on_invoices, $account_on_hold, $current_balance, $period1_balance, $period2_balance, $period3_balance, $period4_balance, $fx_current_balance, $fx_period1_balance, $fx_period2_balance, $fx_period3_balance, $fx_period4_balance, $notify_required, $web_access, $commence_date, $trading_status, $period_type, $uses_fx, $is_cash_only, $terms_days, $terms_type, $exclude_from_aging, $debtor_is_branch_account, $remaining_normal_prepaid_labour_pack_hours, $remaining_special_prepaid_labour_pack_hours, $fx_decimal_places, $prospect_id, $last_saved_date_time, $account_no, $alt_account_no, $name, $address1, $address2, $address3, $address4, $postcode, $phone, $fax, $email_address, $acn, $abn, $aust_post_dpid, $aust_post_bcsp, $bank_name, $bank_account_no, $bank_bsbn, $bank_account_name, $tax_exemption_no, $notify_address, $parent_debtor_id, $parent_debtor_account_no, $parent_debtor_name, $price_scheme_id, $price_scheme_description, $trading_name, $company_name, $proprietors_name, $fax_header, $fxid, $fx_name, $fx_short_name, $b_pay_reference, $classification, $category1, $category2, $category3, $category4, $category5, $contact_names, $group_memberships, $branch_debtors, $delivery_addresses, $freight_forwarder_addresses, $notes, $credit_notes, $directors, $budgets, $debtor_part_numbers, $custom_field_values, $documents, $debtor_systems, $debtor_ledgers, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPATCHRequestDebtorIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit (optional)
     * @param  int $early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date (optional)
     * @param  \DateTime $last_payment_date (optional)
     * @param  double $standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold (optional)
     * @param  double $current_balance (optional)
     * @param  double $period1_balance (optional)
     * @param  double $period2_balance (optional)
     * @param  double $period3_balance (optional)
     * @param  double $period4_balance (optional)
     * @param  double $fx_current_balance (optional)
     * @param  double $fx_period1_balance (optional)
     * @param  double $fx_period2_balance (optional)
     * @param  double $fx_period3_balance (optional)
     * @param  double $fx_period4_balance (optional)
     * @param  bool $notify_required (optional)
     * @param  bool $web_access (optional)
     * @param  \DateTime $commence_date (optional)
     * @param  string $trading_status (optional)
     * @param  string $period_type (optional)
     * @param  bool $uses_fx (optional)
     * @param  bool $is_cash_only (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  bool $exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places (optional)
     * @param  string $prospect_id (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  string $account_no (optional)
     * @param  string $alt_account_no (optional)
     * @param  string $name (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $phone (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $acn (optional)
     * @param  string $abn (optional)
     * @param  string $aust_post_dpid (optional)
     * @param  string $aust_post_bcsp (optional)
     * @param  string $bank_name (optional)
     * @param  string $bank_account_no (optional)
     * @param  string $bank_bsbn (optional)
     * @param  string $bank_account_name (optional)
     * @param  string $tax_exemption_no (optional)
     * @param  string $notify_address (optional)
     * @param  string $parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name (optional)
     * @param  string $price_scheme_id (optional)
     * @param  string $price_scheme_description (optional)
     * @param  string $trading_name (optional)
     * @param  string $company_name (optional)
     * @param  string $proprietors_name (optional)
     * @param  string $fax_header (optional)
     * @param  string $fxid (optional)
     * @param  string $fx_name (optional)
     * @param  string $fx_short_name (optional)
     * @param  string $b_pay_reference (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $contact_names (optional)
     * @param  string $group_memberships (optional)
     * @param  string $branch_debtors (optional)
     * @param  string $delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses (optional)
     * @param  string $notes (optional)
     * @param  string $credit_notes (optional)
     * @param  string $directors (optional)
     * @param  string $budgets (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $documents (optional)
     * @param  string $debtor_systems (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPATCHRequestDebtorIDUpdateRequest($accept, $debtor_id, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $last_saved_date_time = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPATCHRequestDebtorIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorPATCHRequestDebtorIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($credit_limit !== null) {
            $queryParams['CreditLimit'] = ObjectSerializer::toQueryValue($credit_limit);
        }
        // query params
        if ($early_payment_discount_days !== null) {
            $queryParams['EarlyPaymentDiscountDays'] = ObjectSerializer::toQueryValue($early_payment_discount_days);
        }
        // query params
        if ($early_payment_discount_amount !== null) {
            $queryParams['EarlyPaymentDiscountAmount'] = ObjectSerializer::toQueryValue($early_payment_discount_amount);
        }
        // query params
        if ($last_purchase_date !== null) {
            $queryParams['LastPurchaseDate'] = ObjectSerializer::toQueryValue($last_purchase_date);
        }
        // query params
        if ($last_payment_date !== null) {
            $queryParams['LastPaymentDate'] = ObjectSerializer::toQueryValue($last_payment_date);
        }
        // query params
        if ($standing_discount_on_invoices !== null) {
            $queryParams['StandingDiscountOnInvoices'] = ObjectSerializer::toQueryValue($standing_discount_on_invoices);
        }
        // query params
        if ($account_on_hold !== null) {
            $queryParams['AccountOnHold'] = ObjectSerializer::toQueryValue($account_on_hold);
        }
        // query params
        if ($current_balance !== null) {
            $queryParams['CurrentBalance'] = ObjectSerializer::toQueryValue($current_balance);
        }
        // query params
        if ($period1_balance !== null) {
            $queryParams['Period1Balance'] = ObjectSerializer::toQueryValue($period1_balance);
        }
        // query params
        if ($period2_balance !== null) {
            $queryParams['Period2Balance'] = ObjectSerializer::toQueryValue($period2_balance);
        }
        // query params
        if ($period3_balance !== null) {
            $queryParams['Period3Balance'] = ObjectSerializer::toQueryValue($period3_balance);
        }
        // query params
        if ($period4_balance !== null) {
            $queryParams['Period4Balance'] = ObjectSerializer::toQueryValue($period4_balance);
        }
        // query params
        if ($fx_current_balance !== null) {
            $queryParams['FXCurrentBalance'] = ObjectSerializer::toQueryValue($fx_current_balance);
        }
        // query params
        if ($fx_period1_balance !== null) {
            $queryParams['FXPeriod1Balance'] = ObjectSerializer::toQueryValue($fx_period1_balance);
        }
        // query params
        if ($fx_period2_balance !== null) {
            $queryParams['FXPeriod2Balance'] = ObjectSerializer::toQueryValue($fx_period2_balance);
        }
        // query params
        if ($fx_period3_balance !== null) {
            $queryParams['FXPeriod3Balance'] = ObjectSerializer::toQueryValue($fx_period3_balance);
        }
        // query params
        if ($fx_period4_balance !== null) {
            $queryParams['FXPeriod4Balance'] = ObjectSerializer::toQueryValue($fx_period4_balance);
        }
        // query params
        if ($notify_required !== null) {
            $queryParams['NotifyRequired'] = ObjectSerializer::toQueryValue($notify_required);
        }
        // query params
        if ($web_access !== null) {
            $queryParams['WebAccess'] = ObjectSerializer::toQueryValue($web_access);
        }
        // query params
        if ($commence_date !== null) {
            $queryParams['CommenceDate'] = ObjectSerializer::toQueryValue($commence_date);
        }
        // query params
        if ($trading_status !== null) {
            $queryParams['TradingStatus'] = ObjectSerializer::toQueryValue($trading_status);
        }
        // query params
        if ($period_type !== null) {
            $queryParams['PeriodType'] = ObjectSerializer::toQueryValue($period_type);
        }
        // query params
        if ($uses_fx !== null) {
            $queryParams['UsesFX'] = ObjectSerializer::toQueryValue($uses_fx);
        }
        // query params
        if ($is_cash_only !== null) {
            $queryParams['IsCashOnly'] = ObjectSerializer::toQueryValue($is_cash_only);
        }
        // query params
        if ($terms_days !== null) {
            $queryParams['TermsDays'] = ObjectSerializer::toQueryValue($terms_days);
        }
        // query params
        if ($terms_type !== null) {
            $queryParams['TermsType'] = ObjectSerializer::toQueryValue($terms_type);
        }
        // query params
        if ($exclude_from_aging !== null) {
            $queryParams['ExcludeFromAging'] = ObjectSerializer::toQueryValue($exclude_from_aging);
        }
        // query params
        if ($debtor_is_branch_account !== null) {
            $queryParams['DebtorIsBranchAccount'] = ObjectSerializer::toQueryValue($debtor_is_branch_account);
        }
        // query params
        if ($remaining_normal_prepaid_labour_pack_hours !== null) {
            $queryParams['RemainingNormalPrepaidLabourPackHours'] = ObjectSerializer::toQueryValue($remaining_normal_prepaid_labour_pack_hours);
        }
        // query params
        if ($remaining_special_prepaid_labour_pack_hours !== null) {
            $queryParams['RemainingSpecialPrepaidLabourPackHours'] = ObjectSerializer::toQueryValue($remaining_special_prepaid_labour_pack_hours);
        }
        // query params
        if ($fx_decimal_places !== null) {
            $queryParams['FXDecimalPlaces'] = ObjectSerializer::toQueryValue($fx_decimal_places);
        }
        // query params
        if ($prospect_id !== null) {
            $queryParams['ProspectID'] = ObjectSerializer::toQueryValue($prospect_id);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // query params
        if ($account_no !== null) {
            $queryParams['AccountNo'] = ObjectSerializer::toQueryValue($account_no);
        }
        // query params
        if ($alt_account_no !== null) {
            $queryParams['AltAccountNo'] = ObjectSerializer::toQueryValue($alt_account_no);
        }
        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($address1 !== null) {
            $queryParams['Address1'] = ObjectSerializer::toQueryValue($address1);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['Address2'] = ObjectSerializer::toQueryValue($address2);
        }
        // query params
        if ($address3 !== null) {
            $queryParams['Address3'] = ObjectSerializer::toQueryValue($address3);
        }
        // query params
        if ($address4 !== null) {
            $queryParams['Address4'] = ObjectSerializer::toQueryValue($address4);
        }
        // query params
        if ($postcode !== null) {
            $queryParams['Postcode'] = ObjectSerializer::toQueryValue($postcode);
        }
        // query params
        if ($phone !== null) {
            $queryParams['Phone'] = ObjectSerializer::toQueryValue($phone);
        }
        // query params
        if ($fax !== null) {
            $queryParams['Fax'] = ObjectSerializer::toQueryValue($fax);
        }
        // query params
        if ($email_address !== null) {
            $queryParams['EmailAddress'] = ObjectSerializer::toQueryValue($email_address);
        }
        // query params
        if ($acn !== null) {
            $queryParams['ACN'] = ObjectSerializer::toQueryValue($acn);
        }
        // query params
        if ($abn !== null) {
            $queryParams['ABN'] = ObjectSerializer::toQueryValue($abn);
        }
        // query params
        if ($aust_post_dpid !== null) {
            $queryParams['AustPostDPID'] = ObjectSerializer::toQueryValue($aust_post_dpid);
        }
        // query params
        if ($aust_post_bcsp !== null) {
            $queryParams['AustPostBCSP'] = ObjectSerializer::toQueryValue($aust_post_bcsp);
        }
        // query params
        if ($bank_name !== null) {
            $queryParams['BankName'] = ObjectSerializer::toQueryValue($bank_name);
        }
        // query params
        if ($bank_account_no !== null) {
            $queryParams['BankAccountNo'] = ObjectSerializer::toQueryValue($bank_account_no);
        }
        // query params
        if ($bank_bsbn !== null) {
            $queryParams['BankBSBN'] = ObjectSerializer::toQueryValue($bank_bsbn);
        }
        // query params
        if ($bank_account_name !== null) {
            $queryParams['BankAccountName'] = ObjectSerializer::toQueryValue($bank_account_name);
        }
        // query params
        if ($tax_exemption_no !== null) {
            $queryParams['TaxExemptionNo'] = ObjectSerializer::toQueryValue($tax_exemption_no);
        }
        // query params
        if ($notify_address !== null) {
            $queryParams['NotifyAddress'] = ObjectSerializer::toQueryValue($notify_address);
        }
        // query params
        if ($parent_debtor_id !== null) {
            $queryParams['ParentDebtorID'] = ObjectSerializer::toQueryValue($parent_debtor_id);
        }
        // query params
        if ($parent_debtor_account_no !== null) {
            $queryParams['ParentDebtorAccountNo'] = ObjectSerializer::toQueryValue($parent_debtor_account_no);
        }
        // query params
        if ($parent_debtor_name !== null) {
            $queryParams['ParentDebtorName'] = ObjectSerializer::toQueryValue($parent_debtor_name);
        }
        // query params
        if ($price_scheme_id !== null) {
            $queryParams['PriceSchemeID'] = ObjectSerializer::toQueryValue($price_scheme_id);
        }
        // query params
        if ($price_scheme_description !== null) {
            $queryParams['PriceSchemeDescription'] = ObjectSerializer::toQueryValue($price_scheme_description);
        }
        // query params
        if ($trading_name !== null) {
            $queryParams['TradingName'] = ObjectSerializer::toQueryValue($trading_name);
        }
        // query params
        if ($company_name !== null) {
            $queryParams['CompanyName'] = ObjectSerializer::toQueryValue($company_name);
        }
        // query params
        if ($proprietors_name !== null) {
            $queryParams['ProprietorsName'] = ObjectSerializer::toQueryValue($proprietors_name);
        }
        // query params
        if ($fax_header !== null) {
            $queryParams['FaxHeader'] = ObjectSerializer::toQueryValue($fax_header);
        }
        // query params
        if ($fxid !== null) {
            $queryParams['FXID'] = ObjectSerializer::toQueryValue($fxid);
        }
        // query params
        if ($fx_name !== null) {
            $queryParams['FXName'] = ObjectSerializer::toQueryValue($fx_name);
        }
        // query params
        if ($fx_short_name !== null) {
            $queryParams['FXShortName'] = ObjectSerializer::toQueryValue($fx_short_name);
        }
        // query params
        if ($b_pay_reference !== null) {
            $queryParams['BPayReference'] = ObjectSerializer::toQueryValue($b_pay_reference);
        }
        // query params
        if ($classification !== null) {
            $queryParams['Classification'] = ObjectSerializer::toQueryValue($classification);
        }
        // query params
        if ($category1 !== null) {
            $queryParams['Category1'] = ObjectSerializer::toQueryValue($category1);
        }
        // query params
        if ($category2 !== null) {
            $queryParams['Category2'] = ObjectSerializer::toQueryValue($category2);
        }
        // query params
        if ($category3 !== null) {
            $queryParams['Category3'] = ObjectSerializer::toQueryValue($category3);
        }
        // query params
        if ($category4 !== null) {
            $queryParams['Category4'] = ObjectSerializer::toQueryValue($category4);
        }
        // query params
        if ($category5 !== null) {
            $queryParams['Category5'] = ObjectSerializer::toQueryValue($category5);
        }
        // query params
        if ($contact_names !== null) {
            $queryParams['ContactNames'] = ObjectSerializer::toQueryValue($contact_names);
        }
        // query params
        if ($group_memberships !== null) {
            $queryParams['GroupMemberships'] = ObjectSerializer::toQueryValue($group_memberships);
        }
        // query params
        if ($branch_debtors !== null) {
            $queryParams['BranchDebtors'] = ObjectSerializer::toQueryValue($branch_debtors);
        }
        // query params
        if ($delivery_addresses !== null) {
            $queryParams['DeliveryAddresses'] = ObjectSerializer::toQueryValue($delivery_addresses);
        }
        // query params
        if ($freight_forwarder_addresses !== null) {
            $queryParams['FreightForwarderAddresses'] = ObjectSerializer::toQueryValue($freight_forwarder_addresses);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($credit_notes !== null) {
            $queryParams['CreditNotes'] = ObjectSerializer::toQueryValue($credit_notes);
        }
        // query params
        if ($directors !== null) {
            $queryParams['Directors'] = ObjectSerializer::toQueryValue($directors);
        }
        // query params
        if ($budgets !== null) {
            $queryParams['Budgets'] = ObjectSerializer::toQueryValue($budgets);
        }
        // query params
        if ($debtor_part_numbers !== null) {
            $queryParams['DebtorPartNumbers'] = ObjectSerializer::toQueryValue($debtor_part_numbers);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($documents !== null) {
            $queryParams['Documents'] = ObjectSerializer::toQueryValue($documents);
        }
        // query params
        if ($debtor_systems !== null) {
            $queryParams['DebtorSystems'] = ObjectSerializer::toQueryValue($debtor_systems);
        }
        // query params
        if ($debtor_ledgers !== null) {
            $queryParams['DebtorLedgers'] = ObjectSerializer::toQueryValue($debtor_ledgers);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPOSTRequestPost
     *
     * Creates a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit credit_limit (optional)
     * @param  int $early_payment_discount_days early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date last_purchase_date (optional)
     * @param  \DateTime $last_payment_date last_payment_date (optional)
     * @param  double $standing_discount_on_invoices standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold account_on_hold (optional)
     * @param  double $current_balance current_balance (optional)
     * @param  double $period1_balance period1_balance (optional)
     * @param  double $period2_balance period2_balance (optional)
     * @param  double $period3_balance period3_balance (optional)
     * @param  double $period4_balance period4_balance (optional)
     * @param  double $fx_current_balance fx_current_balance (optional)
     * @param  double $fx_period1_balance fx_period1_balance (optional)
     * @param  double $fx_period2_balance fx_period2_balance (optional)
     * @param  double $fx_period3_balance fx_period3_balance (optional)
     * @param  double $fx_period4_balance fx_period4_balance (optional)
     * @param  bool $notify_required notify_required (optional)
     * @param  bool $web_access web_access (optional)
     * @param  \DateTime $commence_date commence_date (optional)
     * @param  string $trading_status trading_status (optional)
     * @param  string $period_type period_type (optional)
     * @param  bool $uses_fx uses_fx (optional)
     * @param  bool $is_cash_only is_cash_only (optional)
     * @param  int $terms_days terms_days (optional)
     * @param  string $terms_type terms_type (optional)
     * @param  bool $exclude_from_aging exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places fx_decimal_places (optional)
     * @param  string $prospect_id prospect_id (optional)
     * @param  string $account_no account_no (optional)
     * @param  string $alt_account_no alt_account_no (optional)
     * @param  string $name name (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $address2 address2 (optional)
     * @param  string $address3 address3 (optional)
     * @param  string $address4 address4 (optional)
     * @param  string $postcode postcode (optional)
     * @param  string $phone phone (optional)
     * @param  string $fax fax (optional)
     * @param  string $email_address email_address (optional)
     * @param  string $acn acn (optional)
     * @param  string $abn abn (optional)
     * @param  string $aust_post_dpid aust_post_dpid (optional)
     * @param  string $aust_post_bcsp aust_post_bcsp (optional)
     * @param  string $bank_name bank_name (optional)
     * @param  string $bank_account_no bank_account_no (optional)
     * @param  string $bank_bsbn bank_bsbn (optional)
     * @param  string $bank_account_name bank_account_name (optional)
     * @param  string $tax_exemption_no tax_exemption_no (optional)
     * @param  string $notify_address notify_address (optional)
     * @param  string $parent_debtor_id parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name parent_debtor_name (optional)
     * @param  string $price_scheme_id price_scheme_id (optional)
     * @param  string $price_scheme_description price_scheme_description (optional)
     * @param  string $trading_name trading_name (optional)
     * @param  string $company_name company_name (optional)
     * @param  string $proprietors_name proprietors_name (optional)
     * @param  string $fax_header fax_header (optional)
     * @param  string $fxid fxid (optional)
     * @param  string $fx_name fx_name (optional)
     * @param  string $fx_short_name fx_short_name (optional)
     * @param  string $b_pay_reference b_pay_reference (optional)
     * @param  string $classification classification (optional)
     * @param  string $category1 category1 (optional)
     * @param  string $category2 category2 (optional)
     * @param  string $category3 category3 (optional)
     * @param  string $category4 category4 (optional)
     * @param  string $category5 category5 (optional)
     * @param  string $contact_names contact_names (optional)
     * @param  string $group_memberships group_memberships (optional)
     * @param  string $branch_debtors branch_debtors (optional)
     * @param  string $delivery_addresses delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses freight_forwarder_addresses (optional)
     * @param  string $notes notes (optional)
     * @param  string $credit_notes credit_notes (optional)
     * @param  string $directors directors (optional)
     * @param  string $budgets budgets (optional)
     * @param  string $debtor_part_numbers debtor_part_numbers (optional)
     * @param  string $custom_field_values custom_field_values (optional)
     * @param  string $documents documents (optional)
     * @param  string $debtor_systems debtor_systems (optional)
     * @param  string $debtor_ledgers debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Debtor
     */
    public function debtorPOSTRequestPost($accept, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        list($response) = $this->debtorPOSTRequestPostWithHttpInfo($accept, $jiwa_stateful, $credit_limit, $early_payment_discount_days, $early_payment_discount_amount, $last_purchase_date, $last_payment_date, $standing_discount_on_invoices, $account_on_hold, $current_balance, $period1_balance, $period2_balance, $period3_balance, $period4_balance, $fx_current_balance, $fx_period1_balance, $fx_period2_balance, $fx_period3_balance, $fx_period4_balance, $notify_required, $web_access, $commence_date, $trading_status, $period_type, $uses_fx, $is_cash_only, $terms_days, $terms_type, $exclude_from_aging, $debtor_is_branch_account, $remaining_normal_prepaid_labour_pack_hours, $remaining_special_prepaid_labour_pack_hours, $fx_decimal_places, $prospect_id, $account_no, $alt_account_no, $name, $address1, $address2, $address3, $address4, $postcode, $phone, $fax, $email_address, $acn, $abn, $aust_post_dpid, $aust_post_bcsp, $bank_name, $bank_account_no, $bank_bsbn, $bank_account_name, $tax_exemption_no, $notify_address, $parent_debtor_id, $parent_debtor_account_no, $parent_debtor_name, $price_scheme_id, $price_scheme_description, $trading_name, $company_name, $proprietors_name, $fax_header, $fxid, $fx_name, $fx_short_name, $b_pay_reference, $classification, $category1, $category2, $category3, $category4, $category5, $contact_names, $group_memberships, $branch_debtors, $delivery_addresses, $freight_forwarder_addresses, $notes, $credit_notes, $directors, $budgets, $debtor_part_numbers, $custom_field_values, $documents, $debtor_systems, $debtor_ledgers, $body);
        return $response;
    }

    /**
     * Operation debtorPOSTRequestPostWithHttpInfo
     *
     * Creates a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit (optional)
     * @param  int $early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date (optional)
     * @param  \DateTime $last_payment_date (optional)
     * @param  double $standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold (optional)
     * @param  double $current_balance (optional)
     * @param  double $period1_balance (optional)
     * @param  double $period2_balance (optional)
     * @param  double $period3_balance (optional)
     * @param  double $period4_balance (optional)
     * @param  double $fx_current_balance (optional)
     * @param  double $fx_period1_balance (optional)
     * @param  double $fx_period2_balance (optional)
     * @param  double $fx_period3_balance (optional)
     * @param  double $fx_period4_balance (optional)
     * @param  bool $notify_required (optional)
     * @param  bool $web_access (optional)
     * @param  \DateTime $commence_date (optional)
     * @param  string $trading_status (optional)
     * @param  string $period_type (optional)
     * @param  bool $uses_fx (optional)
     * @param  bool $is_cash_only (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  bool $exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places (optional)
     * @param  string $prospect_id (optional)
     * @param  string $account_no (optional)
     * @param  string $alt_account_no (optional)
     * @param  string $name (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $phone (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $acn (optional)
     * @param  string $abn (optional)
     * @param  string $aust_post_dpid (optional)
     * @param  string $aust_post_bcsp (optional)
     * @param  string $bank_name (optional)
     * @param  string $bank_account_no (optional)
     * @param  string $bank_bsbn (optional)
     * @param  string $bank_account_name (optional)
     * @param  string $tax_exemption_no (optional)
     * @param  string $notify_address (optional)
     * @param  string $parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name (optional)
     * @param  string $price_scheme_id (optional)
     * @param  string $price_scheme_description (optional)
     * @param  string $trading_name (optional)
     * @param  string $company_name (optional)
     * @param  string $proprietors_name (optional)
     * @param  string $fax_header (optional)
     * @param  string $fxid (optional)
     * @param  string $fx_name (optional)
     * @param  string $fx_short_name (optional)
     * @param  string $b_pay_reference (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $contact_names (optional)
     * @param  string $group_memberships (optional)
     * @param  string $branch_debtors (optional)
     * @param  string $delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses (optional)
     * @param  string $notes (optional)
     * @param  string $credit_notes (optional)
     * @param  string $directors (optional)
     * @param  string $budgets (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $documents (optional)
     * @param  string $debtor_systems (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Debtor, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPOSTRequestPostWithHttpInfo($accept, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorPOSTRequestPostRequest($accept, $jiwa_stateful, $credit_limit, $early_payment_discount_days, $early_payment_discount_amount, $last_purchase_date, $last_payment_date, $standing_discount_on_invoices, $account_on_hold, $current_balance, $period1_balance, $period2_balance, $period3_balance, $period4_balance, $fx_current_balance, $fx_period1_balance, $fx_period2_balance, $fx_period3_balance, $fx_period4_balance, $notify_required, $web_access, $commence_date, $trading_status, $period_type, $uses_fx, $is_cash_only, $terms_days, $terms_type, $exclude_from_aging, $debtor_is_branch_account, $remaining_normal_prepaid_labour_pack_hours, $remaining_special_prepaid_labour_pack_hours, $fx_decimal_places, $prospect_id, $account_no, $alt_account_no, $name, $address1, $address2, $address3, $address4, $postcode, $phone, $fax, $email_address, $acn, $abn, $aust_post_dpid, $aust_post_bcsp, $bank_name, $bank_account_no, $bank_bsbn, $bank_account_name, $tax_exemption_no, $notify_address, $parent_debtor_id, $parent_debtor_account_no, $parent_debtor_name, $price_scheme_id, $price_scheme_description, $trading_name, $company_name, $proprietors_name, $fax_header, $fxid, $fx_name, $fx_short_name, $b_pay_reference, $classification, $category1, $category2, $category3, $category4, $category5, $contact_names, $group_memberships, $branch_debtors, $delivery_addresses, $freight_forwarder_addresses, $notes, $credit_notes, $directors, $budgets, $debtor_part_numbers, $custom_field_values, $documents, $debtor_systems, $debtor_ledgers, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPOSTRequestPostAsync
     *
     * Creates a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit (optional)
     * @param  int $early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date (optional)
     * @param  \DateTime $last_payment_date (optional)
     * @param  double $standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold (optional)
     * @param  double $current_balance (optional)
     * @param  double $period1_balance (optional)
     * @param  double $period2_balance (optional)
     * @param  double $period3_balance (optional)
     * @param  double $period4_balance (optional)
     * @param  double $fx_current_balance (optional)
     * @param  double $fx_period1_balance (optional)
     * @param  double $fx_period2_balance (optional)
     * @param  double $fx_period3_balance (optional)
     * @param  double $fx_period4_balance (optional)
     * @param  bool $notify_required (optional)
     * @param  bool $web_access (optional)
     * @param  \DateTime $commence_date (optional)
     * @param  string $trading_status (optional)
     * @param  string $period_type (optional)
     * @param  bool $uses_fx (optional)
     * @param  bool $is_cash_only (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  bool $exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places (optional)
     * @param  string $prospect_id (optional)
     * @param  string $account_no (optional)
     * @param  string $alt_account_no (optional)
     * @param  string $name (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $phone (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $acn (optional)
     * @param  string $abn (optional)
     * @param  string $aust_post_dpid (optional)
     * @param  string $aust_post_bcsp (optional)
     * @param  string $bank_name (optional)
     * @param  string $bank_account_no (optional)
     * @param  string $bank_bsbn (optional)
     * @param  string $bank_account_name (optional)
     * @param  string $tax_exemption_no (optional)
     * @param  string $notify_address (optional)
     * @param  string $parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name (optional)
     * @param  string $price_scheme_id (optional)
     * @param  string $price_scheme_description (optional)
     * @param  string $trading_name (optional)
     * @param  string $company_name (optional)
     * @param  string $proprietors_name (optional)
     * @param  string $fax_header (optional)
     * @param  string $fxid (optional)
     * @param  string $fx_name (optional)
     * @param  string $fx_short_name (optional)
     * @param  string $b_pay_reference (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $contact_names (optional)
     * @param  string $group_memberships (optional)
     * @param  string $branch_debtors (optional)
     * @param  string $delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses (optional)
     * @param  string $notes (optional)
     * @param  string $credit_notes (optional)
     * @param  string $directors (optional)
     * @param  string $budgets (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $documents (optional)
     * @param  string $debtor_systems (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPOSTRequestPostAsync($accept, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        return $this->debtorPOSTRequestPostAsyncWithHttpInfo($accept, $jiwa_stateful, $credit_limit, $early_payment_discount_days, $early_payment_discount_amount, $last_purchase_date, $last_payment_date, $standing_discount_on_invoices, $account_on_hold, $current_balance, $period1_balance, $period2_balance, $period3_balance, $period4_balance, $fx_current_balance, $fx_period1_balance, $fx_period2_balance, $fx_period3_balance, $fx_period4_balance, $notify_required, $web_access, $commence_date, $trading_status, $period_type, $uses_fx, $is_cash_only, $terms_days, $terms_type, $exclude_from_aging, $debtor_is_branch_account, $remaining_normal_prepaid_labour_pack_hours, $remaining_special_prepaid_labour_pack_hours, $fx_decimal_places, $prospect_id, $account_no, $alt_account_no, $name, $address1, $address2, $address3, $address4, $postcode, $phone, $fax, $email_address, $acn, $abn, $aust_post_dpid, $aust_post_bcsp, $bank_name, $bank_account_no, $bank_bsbn, $bank_account_name, $tax_exemption_no, $notify_address, $parent_debtor_id, $parent_debtor_account_no, $parent_debtor_name, $price_scheme_id, $price_scheme_description, $trading_name, $company_name, $proprietors_name, $fax_header, $fxid, $fx_name, $fx_short_name, $b_pay_reference, $classification, $category1, $category2, $category3, $category4, $category5, $contact_names, $group_memberships, $branch_debtors, $delivery_addresses, $freight_forwarder_addresses, $notes, $credit_notes, $directors, $budgets, $debtor_part_numbers, $custom_field_values, $documents, $debtor_systems, $debtor_ledgers, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPOSTRequestPostAsyncWithHttpInfo
     *
     * Creates a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit (optional)
     * @param  int $early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date (optional)
     * @param  \DateTime $last_payment_date (optional)
     * @param  double $standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold (optional)
     * @param  double $current_balance (optional)
     * @param  double $period1_balance (optional)
     * @param  double $period2_balance (optional)
     * @param  double $period3_balance (optional)
     * @param  double $period4_balance (optional)
     * @param  double $fx_current_balance (optional)
     * @param  double $fx_period1_balance (optional)
     * @param  double $fx_period2_balance (optional)
     * @param  double $fx_period3_balance (optional)
     * @param  double $fx_period4_balance (optional)
     * @param  bool $notify_required (optional)
     * @param  bool $web_access (optional)
     * @param  \DateTime $commence_date (optional)
     * @param  string $trading_status (optional)
     * @param  string $period_type (optional)
     * @param  bool $uses_fx (optional)
     * @param  bool $is_cash_only (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  bool $exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places (optional)
     * @param  string $prospect_id (optional)
     * @param  string $account_no (optional)
     * @param  string $alt_account_no (optional)
     * @param  string $name (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $phone (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $acn (optional)
     * @param  string $abn (optional)
     * @param  string $aust_post_dpid (optional)
     * @param  string $aust_post_bcsp (optional)
     * @param  string $bank_name (optional)
     * @param  string $bank_account_no (optional)
     * @param  string $bank_bsbn (optional)
     * @param  string $bank_account_name (optional)
     * @param  string $tax_exemption_no (optional)
     * @param  string $notify_address (optional)
     * @param  string $parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name (optional)
     * @param  string $price_scheme_id (optional)
     * @param  string $price_scheme_description (optional)
     * @param  string $trading_name (optional)
     * @param  string $company_name (optional)
     * @param  string $proprietors_name (optional)
     * @param  string $fax_header (optional)
     * @param  string $fxid (optional)
     * @param  string $fx_name (optional)
     * @param  string $fx_short_name (optional)
     * @param  string $b_pay_reference (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $contact_names (optional)
     * @param  string $group_memberships (optional)
     * @param  string $branch_debtors (optional)
     * @param  string $delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses (optional)
     * @param  string $notes (optional)
     * @param  string $credit_notes (optional)
     * @param  string $directors (optional)
     * @param  string $budgets (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $documents (optional)
     * @param  string $debtor_systems (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPOSTRequestPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorPOSTRequestPostRequest($accept, $jiwa_stateful, $credit_limit, $early_payment_discount_days, $early_payment_discount_amount, $last_purchase_date, $last_payment_date, $standing_discount_on_invoices, $account_on_hold, $current_balance, $period1_balance, $period2_balance, $period3_balance, $period4_balance, $fx_current_balance, $fx_period1_balance, $fx_period2_balance, $fx_period3_balance, $fx_period4_balance, $notify_required, $web_access, $commence_date, $trading_status, $period_type, $uses_fx, $is_cash_only, $terms_days, $terms_type, $exclude_from_aging, $debtor_is_branch_account, $remaining_normal_prepaid_labour_pack_hours, $remaining_special_prepaid_labour_pack_hours, $fx_decimal_places, $prospect_id, $account_no, $alt_account_no, $name, $address1, $address2, $address3, $address4, $postcode, $phone, $fax, $email_address, $acn, $abn, $aust_post_dpid, $aust_post_bcsp, $bank_name, $bank_account_no, $bank_bsbn, $bank_account_name, $tax_exemption_no, $notify_address, $parent_debtor_id, $parent_debtor_account_no, $parent_debtor_name, $price_scheme_id, $price_scheme_description, $trading_name, $company_name, $proprietors_name, $fax_header, $fxid, $fx_name, $fx_short_name, $b_pay_reference, $classification, $category1, $category2, $category3, $category4, $category5, $contact_names, $group_memberships, $branch_debtors, $delivery_addresses, $freight_forwarder_addresses, $notes, $credit_notes, $directors, $budgets, $debtor_part_numbers, $custom_field_values, $documents, $debtor_systems, $debtor_ledgers, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPOSTRequestPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  double $credit_limit (optional)
     * @param  int $early_payment_discount_days (optional)
     * @param  double $early_payment_discount_amount (optional)
     * @param  \DateTime $last_purchase_date (optional)
     * @param  \DateTime $last_payment_date (optional)
     * @param  double $standing_discount_on_invoices (optional)
     * @param  bool $account_on_hold (optional)
     * @param  double $current_balance (optional)
     * @param  double $period1_balance (optional)
     * @param  double $period2_balance (optional)
     * @param  double $period3_balance (optional)
     * @param  double $period4_balance (optional)
     * @param  double $fx_current_balance (optional)
     * @param  double $fx_period1_balance (optional)
     * @param  double $fx_period2_balance (optional)
     * @param  double $fx_period3_balance (optional)
     * @param  double $fx_period4_balance (optional)
     * @param  bool $notify_required (optional)
     * @param  bool $web_access (optional)
     * @param  \DateTime $commence_date (optional)
     * @param  string $trading_status (optional)
     * @param  string $period_type (optional)
     * @param  bool $uses_fx (optional)
     * @param  bool $is_cash_only (optional)
     * @param  int $terms_days (optional)
     * @param  string $terms_type (optional)
     * @param  bool $exclude_from_aging (optional)
     * @param  bool $debtor_is_branch_account (optional)
     * @param  double $remaining_normal_prepaid_labour_pack_hours (optional)
     * @param  double $remaining_special_prepaid_labour_pack_hours (optional)
     * @param  int $fx_decimal_places (optional)
     * @param  string $prospect_id (optional)
     * @param  string $account_no (optional)
     * @param  string $alt_account_no (optional)
     * @param  string $name (optional)
     * @param  string $address1 (optional)
     * @param  string $address2 (optional)
     * @param  string $address3 (optional)
     * @param  string $address4 (optional)
     * @param  string $postcode (optional)
     * @param  string $phone (optional)
     * @param  string $fax (optional)
     * @param  string $email_address (optional)
     * @param  string $acn (optional)
     * @param  string $abn (optional)
     * @param  string $aust_post_dpid (optional)
     * @param  string $aust_post_bcsp (optional)
     * @param  string $bank_name (optional)
     * @param  string $bank_account_no (optional)
     * @param  string $bank_bsbn (optional)
     * @param  string $bank_account_name (optional)
     * @param  string $tax_exemption_no (optional)
     * @param  string $notify_address (optional)
     * @param  string $parent_debtor_id (optional)
     * @param  string $parent_debtor_account_no (optional)
     * @param  string $parent_debtor_name (optional)
     * @param  string $price_scheme_id (optional)
     * @param  string $price_scheme_description (optional)
     * @param  string $trading_name (optional)
     * @param  string $company_name (optional)
     * @param  string $proprietors_name (optional)
     * @param  string $fax_header (optional)
     * @param  string $fxid (optional)
     * @param  string $fx_name (optional)
     * @param  string $fx_short_name (optional)
     * @param  string $b_pay_reference (optional)
     * @param  string $classification (optional)
     * @param  string $category1 (optional)
     * @param  string $category2 (optional)
     * @param  string $category3 (optional)
     * @param  string $category4 (optional)
     * @param  string $category5 (optional)
     * @param  string $contact_names (optional)
     * @param  string $group_memberships (optional)
     * @param  string $branch_debtors (optional)
     * @param  string $delivery_addresses (optional)
     * @param  string $freight_forwarder_addresses (optional)
     * @param  string $notes (optional)
     * @param  string $credit_notes (optional)
     * @param  string $directors (optional)
     * @param  string $budgets (optional)
     * @param  string $debtor_part_numbers (optional)
     * @param  string $custom_field_values (optional)
     * @param  string $documents (optional)
     * @param  string $debtor_systems (optional)
     * @param  string $debtor_ledgers (optional)
     * @param  \Jiwa\Model\DebtorPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPOSTRequestPostRequest($accept, $jiwa_stateful = null, $credit_limit = null, $early_payment_discount_days = null, $early_payment_discount_amount = null, $last_purchase_date = null, $last_payment_date = null, $standing_discount_on_invoices = null, $account_on_hold = null, $current_balance = null, $period1_balance = null, $period2_balance = null, $period3_balance = null, $period4_balance = null, $fx_current_balance = null, $fx_period1_balance = null, $fx_period2_balance = null, $fx_period3_balance = null, $fx_period4_balance = null, $notify_required = null, $web_access = null, $commence_date = null, $trading_status = null, $period_type = null, $uses_fx = null, $is_cash_only = null, $terms_days = null, $terms_type = null, $exclude_from_aging = null, $debtor_is_branch_account = null, $remaining_normal_prepaid_labour_pack_hours = null, $remaining_special_prepaid_labour_pack_hours = null, $fx_decimal_places = null, $prospect_id = null, $account_no = null, $alt_account_no = null, $name = null, $address1 = null, $address2 = null, $address3 = null, $address4 = null, $postcode = null, $phone = null, $fax = null, $email_address = null, $acn = null, $abn = null, $aust_post_dpid = null, $aust_post_bcsp = null, $bank_name = null, $bank_account_no = null, $bank_bsbn = null, $bank_account_name = null, $tax_exemption_no = null, $notify_address = null, $parent_debtor_id = null, $parent_debtor_account_no = null, $parent_debtor_name = null, $price_scheme_id = null, $price_scheme_description = null, $trading_name = null, $company_name = null, $proprietors_name = null, $fax_header = null, $fxid = null, $fx_name = null, $fx_short_name = null, $b_pay_reference = null, $classification = null, $category1 = null, $category2 = null, $category3 = null, $category4 = null, $category5 = null, $contact_names = null, $group_memberships = null, $branch_debtors = null, $delivery_addresses = null, $freight_forwarder_addresses = null, $notes = null, $credit_notes = null, $directors = null, $budgets = null, $debtor_part_numbers = null, $custom_field_values = null, $documents = null, $debtor_systems = null, $debtor_ledgers = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPOSTRequestPost'
            );
        }

        $resourcePath = '/Debtors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($credit_limit !== null) {
            $queryParams['CreditLimit'] = ObjectSerializer::toQueryValue($credit_limit);
        }
        // query params
        if ($early_payment_discount_days !== null) {
            $queryParams['EarlyPaymentDiscountDays'] = ObjectSerializer::toQueryValue($early_payment_discount_days);
        }
        // query params
        if ($early_payment_discount_amount !== null) {
            $queryParams['EarlyPaymentDiscountAmount'] = ObjectSerializer::toQueryValue($early_payment_discount_amount);
        }
        // query params
        if ($last_purchase_date !== null) {
            $queryParams['LastPurchaseDate'] = ObjectSerializer::toQueryValue($last_purchase_date);
        }
        // query params
        if ($last_payment_date !== null) {
            $queryParams['LastPaymentDate'] = ObjectSerializer::toQueryValue($last_payment_date);
        }
        // query params
        if ($standing_discount_on_invoices !== null) {
            $queryParams['StandingDiscountOnInvoices'] = ObjectSerializer::toQueryValue($standing_discount_on_invoices);
        }
        // query params
        if ($account_on_hold !== null) {
            $queryParams['AccountOnHold'] = ObjectSerializer::toQueryValue($account_on_hold);
        }
        // query params
        if ($current_balance !== null) {
            $queryParams['CurrentBalance'] = ObjectSerializer::toQueryValue($current_balance);
        }
        // query params
        if ($period1_balance !== null) {
            $queryParams['Period1Balance'] = ObjectSerializer::toQueryValue($period1_balance);
        }
        // query params
        if ($period2_balance !== null) {
            $queryParams['Period2Balance'] = ObjectSerializer::toQueryValue($period2_balance);
        }
        // query params
        if ($period3_balance !== null) {
            $queryParams['Period3Balance'] = ObjectSerializer::toQueryValue($period3_balance);
        }
        // query params
        if ($period4_balance !== null) {
            $queryParams['Period4Balance'] = ObjectSerializer::toQueryValue($period4_balance);
        }
        // query params
        if ($fx_current_balance !== null) {
            $queryParams['FXCurrentBalance'] = ObjectSerializer::toQueryValue($fx_current_balance);
        }
        // query params
        if ($fx_period1_balance !== null) {
            $queryParams['FXPeriod1Balance'] = ObjectSerializer::toQueryValue($fx_period1_balance);
        }
        // query params
        if ($fx_period2_balance !== null) {
            $queryParams['FXPeriod2Balance'] = ObjectSerializer::toQueryValue($fx_period2_balance);
        }
        // query params
        if ($fx_period3_balance !== null) {
            $queryParams['FXPeriod3Balance'] = ObjectSerializer::toQueryValue($fx_period3_balance);
        }
        // query params
        if ($fx_period4_balance !== null) {
            $queryParams['FXPeriod4Balance'] = ObjectSerializer::toQueryValue($fx_period4_balance);
        }
        // query params
        if ($notify_required !== null) {
            $queryParams['NotifyRequired'] = ObjectSerializer::toQueryValue($notify_required);
        }
        // query params
        if ($web_access !== null) {
            $queryParams['WebAccess'] = ObjectSerializer::toQueryValue($web_access);
        }
        // query params
        if ($commence_date !== null) {
            $queryParams['CommenceDate'] = ObjectSerializer::toQueryValue($commence_date);
        }
        // query params
        if ($trading_status !== null) {
            $queryParams['TradingStatus'] = ObjectSerializer::toQueryValue($trading_status);
        }
        // query params
        if ($period_type !== null) {
            $queryParams['PeriodType'] = ObjectSerializer::toQueryValue($period_type);
        }
        // query params
        if ($uses_fx !== null) {
            $queryParams['UsesFX'] = ObjectSerializer::toQueryValue($uses_fx);
        }
        // query params
        if ($is_cash_only !== null) {
            $queryParams['IsCashOnly'] = ObjectSerializer::toQueryValue($is_cash_only);
        }
        // query params
        if ($terms_days !== null) {
            $queryParams['TermsDays'] = ObjectSerializer::toQueryValue($terms_days);
        }
        // query params
        if ($terms_type !== null) {
            $queryParams['TermsType'] = ObjectSerializer::toQueryValue($terms_type);
        }
        // query params
        if ($exclude_from_aging !== null) {
            $queryParams['ExcludeFromAging'] = ObjectSerializer::toQueryValue($exclude_from_aging);
        }
        // query params
        if ($debtor_is_branch_account !== null) {
            $queryParams['DebtorIsBranchAccount'] = ObjectSerializer::toQueryValue($debtor_is_branch_account);
        }
        // query params
        if ($remaining_normal_prepaid_labour_pack_hours !== null) {
            $queryParams['RemainingNormalPrepaidLabourPackHours'] = ObjectSerializer::toQueryValue($remaining_normal_prepaid_labour_pack_hours);
        }
        // query params
        if ($remaining_special_prepaid_labour_pack_hours !== null) {
            $queryParams['RemainingSpecialPrepaidLabourPackHours'] = ObjectSerializer::toQueryValue($remaining_special_prepaid_labour_pack_hours);
        }
        // query params
        if ($fx_decimal_places !== null) {
            $queryParams['FXDecimalPlaces'] = ObjectSerializer::toQueryValue($fx_decimal_places);
        }
        // query params
        if ($prospect_id !== null) {
            $queryParams['ProspectID'] = ObjectSerializer::toQueryValue($prospect_id);
        }
        // query params
        if ($account_no !== null) {
            $queryParams['AccountNo'] = ObjectSerializer::toQueryValue($account_no);
        }
        // query params
        if ($alt_account_no !== null) {
            $queryParams['AltAccountNo'] = ObjectSerializer::toQueryValue($alt_account_no);
        }
        // query params
        if ($name !== null) {
            $queryParams['Name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($address1 !== null) {
            $queryParams['Address1'] = ObjectSerializer::toQueryValue($address1);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['Address2'] = ObjectSerializer::toQueryValue($address2);
        }
        // query params
        if ($address3 !== null) {
            $queryParams['Address3'] = ObjectSerializer::toQueryValue($address3);
        }
        // query params
        if ($address4 !== null) {
            $queryParams['Address4'] = ObjectSerializer::toQueryValue($address4);
        }
        // query params
        if ($postcode !== null) {
            $queryParams['Postcode'] = ObjectSerializer::toQueryValue($postcode);
        }
        // query params
        if ($phone !== null) {
            $queryParams['Phone'] = ObjectSerializer::toQueryValue($phone);
        }
        // query params
        if ($fax !== null) {
            $queryParams['Fax'] = ObjectSerializer::toQueryValue($fax);
        }
        // query params
        if ($email_address !== null) {
            $queryParams['EmailAddress'] = ObjectSerializer::toQueryValue($email_address);
        }
        // query params
        if ($acn !== null) {
            $queryParams['ACN'] = ObjectSerializer::toQueryValue($acn);
        }
        // query params
        if ($abn !== null) {
            $queryParams['ABN'] = ObjectSerializer::toQueryValue($abn);
        }
        // query params
        if ($aust_post_dpid !== null) {
            $queryParams['AustPostDPID'] = ObjectSerializer::toQueryValue($aust_post_dpid);
        }
        // query params
        if ($aust_post_bcsp !== null) {
            $queryParams['AustPostBCSP'] = ObjectSerializer::toQueryValue($aust_post_bcsp);
        }
        // query params
        if ($bank_name !== null) {
            $queryParams['BankName'] = ObjectSerializer::toQueryValue($bank_name);
        }
        // query params
        if ($bank_account_no !== null) {
            $queryParams['BankAccountNo'] = ObjectSerializer::toQueryValue($bank_account_no);
        }
        // query params
        if ($bank_bsbn !== null) {
            $queryParams['BankBSBN'] = ObjectSerializer::toQueryValue($bank_bsbn);
        }
        // query params
        if ($bank_account_name !== null) {
            $queryParams['BankAccountName'] = ObjectSerializer::toQueryValue($bank_account_name);
        }
        // query params
        if ($tax_exemption_no !== null) {
            $queryParams['TaxExemptionNo'] = ObjectSerializer::toQueryValue($tax_exemption_no);
        }
        // query params
        if ($notify_address !== null) {
            $queryParams['NotifyAddress'] = ObjectSerializer::toQueryValue($notify_address);
        }
        // query params
        if ($parent_debtor_id !== null) {
            $queryParams['ParentDebtorID'] = ObjectSerializer::toQueryValue($parent_debtor_id);
        }
        // query params
        if ($parent_debtor_account_no !== null) {
            $queryParams['ParentDebtorAccountNo'] = ObjectSerializer::toQueryValue($parent_debtor_account_no);
        }
        // query params
        if ($parent_debtor_name !== null) {
            $queryParams['ParentDebtorName'] = ObjectSerializer::toQueryValue($parent_debtor_name);
        }
        // query params
        if ($price_scheme_id !== null) {
            $queryParams['PriceSchemeID'] = ObjectSerializer::toQueryValue($price_scheme_id);
        }
        // query params
        if ($price_scheme_description !== null) {
            $queryParams['PriceSchemeDescription'] = ObjectSerializer::toQueryValue($price_scheme_description);
        }
        // query params
        if ($trading_name !== null) {
            $queryParams['TradingName'] = ObjectSerializer::toQueryValue($trading_name);
        }
        // query params
        if ($company_name !== null) {
            $queryParams['CompanyName'] = ObjectSerializer::toQueryValue($company_name);
        }
        // query params
        if ($proprietors_name !== null) {
            $queryParams['ProprietorsName'] = ObjectSerializer::toQueryValue($proprietors_name);
        }
        // query params
        if ($fax_header !== null) {
            $queryParams['FaxHeader'] = ObjectSerializer::toQueryValue($fax_header);
        }
        // query params
        if ($fxid !== null) {
            $queryParams['FXID'] = ObjectSerializer::toQueryValue($fxid);
        }
        // query params
        if ($fx_name !== null) {
            $queryParams['FXName'] = ObjectSerializer::toQueryValue($fx_name);
        }
        // query params
        if ($fx_short_name !== null) {
            $queryParams['FXShortName'] = ObjectSerializer::toQueryValue($fx_short_name);
        }
        // query params
        if ($b_pay_reference !== null) {
            $queryParams['BPayReference'] = ObjectSerializer::toQueryValue($b_pay_reference);
        }
        // query params
        if ($classification !== null) {
            $queryParams['Classification'] = ObjectSerializer::toQueryValue($classification);
        }
        // query params
        if ($category1 !== null) {
            $queryParams['Category1'] = ObjectSerializer::toQueryValue($category1);
        }
        // query params
        if ($category2 !== null) {
            $queryParams['Category2'] = ObjectSerializer::toQueryValue($category2);
        }
        // query params
        if ($category3 !== null) {
            $queryParams['Category3'] = ObjectSerializer::toQueryValue($category3);
        }
        // query params
        if ($category4 !== null) {
            $queryParams['Category4'] = ObjectSerializer::toQueryValue($category4);
        }
        // query params
        if ($category5 !== null) {
            $queryParams['Category5'] = ObjectSerializer::toQueryValue($category5);
        }
        // query params
        if ($contact_names !== null) {
            $queryParams['ContactNames'] = ObjectSerializer::toQueryValue($contact_names);
        }
        // query params
        if ($group_memberships !== null) {
            $queryParams['GroupMemberships'] = ObjectSerializer::toQueryValue($group_memberships);
        }
        // query params
        if ($branch_debtors !== null) {
            $queryParams['BranchDebtors'] = ObjectSerializer::toQueryValue($branch_debtors);
        }
        // query params
        if ($delivery_addresses !== null) {
            $queryParams['DeliveryAddresses'] = ObjectSerializer::toQueryValue($delivery_addresses);
        }
        // query params
        if ($freight_forwarder_addresses !== null) {
            $queryParams['FreightForwarderAddresses'] = ObjectSerializer::toQueryValue($freight_forwarder_addresses);
        }
        // query params
        if ($notes !== null) {
            $queryParams['Notes'] = ObjectSerializer::toQueryValue($notes);
        }
        // query params
        if ($credit_notes !== null) {
            $queryParams['CreditNotes'] = ObjectSerializer::toQueryValue($credit_notes);
        }
        // query params
        if ($directors !== null) {
            $queryParams['Directors'] = ObjectSerializer::toQueryValue($directors);
        }
        // query params
        if ($budgets !== null) {
            $queryParams['Budgets'] = ObjectSerializer::toQueryValue($budgets);
        }
        // query params
        if ($debtor_part_numbers !== null) {
            $queryParams['DebtorPartNumbers'] = ObjectSerializer::toQueryValue($debtor_part_numbers);
        }
        // query params
        if ($custom_field_values !== null) {
            $queryParams['CustomFieldValues'] = ObjectSerializer::toQueryValue($custom_field_values);
        }
        // query params
        if ($documents !== null) {
            $queryParams['Documents'] = ObjectSerializer::toQueryValue($documents);
        }
        // query params
        if ($debtor_systems !== null) {
            $queryParams['DebtorSystems'] = ObjectSerializer::toQueryValue($debtor_systems);
        }
        // query params
        if ($debtor_ledgers !== null) {
            $queryParams['DebtorLedgers'] = ObjectSerializer::toQueryValue($debtor_ledgers);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDelete
     *
     * Deletes a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $part_number_id part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id inventory_id (optional)
     * @param  string $part_no part_no (optional)
     * @param  string $debtor_part_no debtor_part_no (optional)
     * @param  string $debtor_barcode debtor_barcode (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDelete($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null)
    {
        list($response) = $this->debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode);
        return $response;
    }

    /**
     * Operation debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteWithHttpInfo
     *
     * Deletes a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteAsync
     *
     * Deletes a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteAsync($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null)
    {
        return $this->debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteAsyncWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDeleteRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDelete'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDelete'
            );
        }
        // verify the required parameter 'part_number_id' is set
        if ($part_number_id === null || (is_array($part_number_id) && count($part_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $part_number_id when calling debtorPartNumberDELETERequestDebtorIDDebtorPartNumbersPartNumberIDDelete'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DebtorPartNumbers/{PartNumberID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inventory_id !== null) {
            $queryParams['InventoryID'] = ObjectSerializer::toQueryValue($inventory_id);
        }
        // query params
        if ($part_no !== null) {
            $queryParams['PartNo'] = ObjectSerializer::toQueryValue($part_no);
        }
        // query params
        if ($debtor_part_no !== null) {
            $queryParams['DebtorPartNo'] = ObjectSerializer::toQueryValue($debtor_part_no);
        }
        // query params
        if ($debtor_barcode !== null) {
            $queryParams['DebtorBarcode'] = ObjectSerializer::toQueryValue($debtor_barcode);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($part_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PartNumberID' . '}',
                ObjectSerializer::toPathValue($part_number_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGet
     *
     * Retrieves a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $part_number_id part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorPartNumber
     */
    public function debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGet($accept, $debtor_id, $part_number_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetWithHttpInfo
     *
     * Retrieves a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorPartNumber, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorPartNumber';
        $request = $this->debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetAsync
     *
     * Retrieves a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetAsync($accept, $debtor_id, $part_number_id, $jiwa_stateful = null)
    {
        return $this->debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetAsyncWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetAsyncWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorPartNumber';
        $request = $this->debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGetRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGet'
            );
        }
        // verify the required parameter 'part_number_id' is set
        if ($part_number_id === null || (is_array($part_number_id) && count($part_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $part_number_id when calling debtorPartNumberGETRequestDebtorIDDebtorPartNumbersPartNumberIDGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DebtorPartNumbers/{PartNumberID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($part_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PartNumberID' . '}',
                ObjectSerializer::toPathValue($part_number_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdate
     *
     * Updates a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  string $part_number_id part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id inventory_id (optional)
     * @param  string $part_no part_no (optional)
     * @param  string $debtor_part_no debtor_part_no (optional)
     * @param  string $debtor_barcode debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorPartNumber
     */
    public function debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdate($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        list($response) = $this->debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode, $body);
        return $response;
    }

    /**
     * Operation debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateWithHttpInfo
     *
     * Updates a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorPartNumber, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorPartNumber';
        $request = $this->debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateAsync
     *
     * Updates a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateAsync($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        return $this->debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor part number.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateAsyncWithHttpInfo($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorPartNumber';
        $request = $this->debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  string $part_number_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdateRequest($accept, $debtor_id, $part_number_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdate'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdate'
            );
        }
        // verify the required parameter 'part_number_id' is set
        if ($part_number_id === null || (is_array($part_number_id) && count($part_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $part_number_id when calling debtorPartNumberPATCHRequestDebtorIDDebtorPartNumbersPartNumberIDUpdate'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DebtorPartNumbers/{PartNumberID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inventory_id !== null) {
            $queryParams['InventoryID'] = ObjectSerializer::toQueryValue($inventory_id);
        }
        // query params
        if ($part_no !== null) {
            $queryParams['PartNo'] = ObjectSerializer::toQueryValue($part_no);
        }
        // query params
        if ($debtor_part_no !== null) {
            $queryParams['DebtorPartNo'] = ObjectSerializer::toQueryValue($debtor_part_no);
        }
        // query params
        if ($debtor_barcode !== null) {
            $queryParams['DebtorBarcode'] = ObjectSerializer::toQueryValue($debtor_barcode);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }
        // path params
        if ($part_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PartNumberID' . '}',
                ObjectSerializer::toPathValue($part_number_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPost
     *
     * Appends a debtor part number to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id inventory_id (optional)
     * @param  string $part_no part_no (optional)
     * @param  string $debtor_part_no debtor_part_no (optional)
     * @param  string $debtor_barcode debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorPartNumber
     */
    public function debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPost($accept, $debtor_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        list($response) = $this->debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode, $body);
        return $response;
    }

    /**
     * Operation debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostWithHttpInfo
     *
     * Appends a debtor part number to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorPartNumber, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorPartNumber';
        $request = $this->debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostRequest($accept, $debtor_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostAsync
     *
     * Appends a debtor part number to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostAsync($accept, $debtor_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        return $this->debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostAsyncWithHttpInfo
     *
     * Appends a debtor part number to a debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorPartNumber';
        $request = $this->debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostRequest($accept, $debtor_id, $jiwa_stateful, $inventory_id, $part_no, $debtor_part_no, $debtor_barcode, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $inventory_id (optional)
     * @param  string $part_no (optional)
     * @param  string $debtor_part_no (optional)
     * @param  string $debtor_barcode (optional)
     * @param  \Jiwa\Model\DebtorPartNumberPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPostRequest($accept, $debtor_id, $jiwa_stateful = null, $inventory_id = null, $part_no = null, $debtor_part_no = null, $debtor_barcode = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPost'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorPartNumberPOSTRequestDebtorIDDebtorPartNumbersPost'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DebtorPartNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inventory_id !== null) {
            $queryParams['InventoryID'] = ObjectSerializer::toQueryValue($inventory_id);
        }
        // query params
        if ($part_no !== null) {
            $queryParams['PartNo'] = ObjectSerializer::toQueryValue($part_no);
        }
        // query params
        if ($debtor_part_no !== null) {
            $queryParams['DebtorPartNo'] = ObjectSerializer::toQueryValue($debtor_part_no);
        }
        // query params
        if ($debtor_barcode !== null) {
            $queryParams['DebtorBarcode'] = ObjectSerializer::toQueryValue($debtor_barcode);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGet
     *
     * Retrieves a list of debtor part numbers.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorPartNumber[]
     */
    public function debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGet($accept, $debtor_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetWithHttpInfo
     *
     * Retrieves a list of debtor part numbers.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorPartNumber[], HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorPartNumber[]';
        $request = $this->debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetRequest($accept, $debtor_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPartNumber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetAsync
     *
     * Retrieves a list of debtor part numbers.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetAsync($accept, $debtor_id, $jiwa_stateful = null)
    {
        return $this->debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetAsyncWithHttpInfo
     *
     * Retrieves a list of debtor part numbers.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetAsyncWithHttpInfo($accept, $debtor_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorPartNumber[]';
        $request = $this->debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetRequest($accept, $debtor_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $debtor_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGetRequest($accept, $debtor_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGet'
            );
        }
        // verify the required parameter 'debtor_id' is set
        if ($debtor_id === null || (is_array($debtor_id) && count($debtor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_id when calling debtorPartNumbersGETManyRequestDebtorIDDebtorPartNumbersGet'
            );
        }

        $resourcePath = '/Debtors/{DebtorID}/DebtorPartNumbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($debtor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'DebtorID' . '}',
                ObjectSerializer::toPathValue($debtor_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete
     *
     * Deletes a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Object
     */
    public function debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteWithHttpInfo
     *
     * Deletes a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Object, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteRequest($accept, $pricing_group_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsync
     *
     * Deletes a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsync($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        return $this->debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsyncWithHttpInfo
     *
     * Deletes a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\Object';
        $request = $this->debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteRequest($accept, $pricing_group_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDeleteRequest($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete'
            );
        }
        // verify the required parameter 'pricing_group_id' is set
        if ($pricing_group_id === null || (is_array($pricing_group_id) && count($pricing_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pricing_group_id when calling debtorPricingGroupDELETERequestPricingGroupsPricingGroupIDDelete'
            );
        }

        $resourcePath = '/Debtors/PricingGroups/{PricingGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($pricing_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PricingGroupID' . '}',
                ObjectSerializer::toPathValue($pricing_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGet
     *
     * Retrieves a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorPricingGroup
     */
    public function debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGet($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        list($response) = $this->debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful);
        return $response;
    }

    /**
     * Operation debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetWithHttpInfo
     *
     * Retrieves a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorPricingGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorPricingGroup';
        $request = $this->debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetRequest($accept, $pricing_group_id, $jiwa_stateful);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsync
     *
     * Retrieves a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsync($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        return $this->debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsyncWithHttpInfo
     *
     * Retrieves a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        $returnType = '\Jiwa\Model\DebtorPricingGroup';
        $request = $this->debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetRequest($accept, $pricing_group_id, $jiwa_stateful);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGetRequest($accept, $pricing_group_id, $jiwa_stateful = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGet'
            );
        }
        // verify the required parameter 'pricing_group_id' is set
        if ($pricing_group_id === null || (is_array($pricing_group_id) && count($pricing_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pricing_group_id when calling debtorPricingGroupGETRequestPricingGroupsPricingGroupIDGet'
            );
        }

        $resourcePath = '/Debtors/PricingGroups/{PricingGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($pricing_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PricingGroupID' . '}',
                ObjectSerializer::toPathValue($pricing_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate
     *
     * Updates a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $is_default is_default (optional)
     * @param  \DateTime $last_saved_date_time last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPATCHRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorPricingGroup
     */
    public function debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        list($response) = $this->debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful, $description, $is_default, $last_saved_date_time, $body);
        return $response;
    }

    /**
     * Operation debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateWithHttpInfo
     *
     * Updates a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPATCHRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorPricingGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorPricingGroup';
        $request = $this->debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateRequest($accept, $pricing_group_id, $jiwa_stateful, $description, $is_default, $last_saved_date_time, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsync
     *
     * Updates a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsync($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        return $this->debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful, $description, $is_default, $last_saved_date_time, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsyncWithHttpInfo
     *
     * Updates a debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateAsyncWithHttpInfo($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorPricingGroup';
        $request = $this->debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateRequest($accept, $pricing_group_id, $jiwa_stateful, $description, $is_default, $last_saved_date_time, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $pricing_group_id (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \DateTime $last_saved_date_time (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPATCHRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdateRequest($accept, $pricing_group_id, $jiwa_stateful = null, $description = null, $is_default = null, $last_saved_date_time = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate'
            );
        }
        // verify the required parameter 'pricing_group_id' is set
        if ($pricing_group_id === null || (is_array($pricing_group_id) && count($pricing_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pricing_group_id when calling debtorPricingGroupPATCHRequestPricingGroupsPricingGroupIDUpdate'
            );
        }

        $resourcePath = '/Debtors/PricingGroups/{PricingGroupID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // query params
        if ($last_saved_date_time !== null) {
            $queryParams['LastSavedDateTime'] = ObjectSerializer::toQueryValue($last_saved_date_time);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }

        // path params
        if ($pricing_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'PricingGroupID' . '}',
                ObjectSerializer::toPathValue($pricing_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorPricingGroupPOSTRequestPricingGroupsPost
     *
     * Creates a new debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description description (optional)
     * @param  bool $is_default is_default (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPOSTRequest $body body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\DebtorPricingGroup
     */
    public function debtorPricingGroupPOSTRequestPricingGroupsPost($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        list($response) = $this->debtorPricingGroupPOSTRequestPricingGroupsPostWithHttpInfo($accept, $jiwa_stateful, $description, $is_default, $body);
        return $response;
    }

    /**
     * Operation debtorPricingGroupPOSTRequestPricingGroupsPostWithHttpInfo
     *
     * Creates a new debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPOSTRequest $body (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\DebtorPricingGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorPricingGroupPOSTRequestPricingGroupsPostWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorPricingGroup';
        $request = $this->debtorPricingGroupPOSTRequestPricingGroupsPostRequest($accept, $jiwa_stateful, $description, $is_default, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\DebtorPricingGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorPricingGroupPOSTRequestPricingGroupsPostAsync
     *
     * Creates a new debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPricingGroupPOSTRequestPricingGroupsPostAsync($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        return $this->debtorPricingGroupPOSTRequestPricingGroupsPostAsyncWithHttpInfo($accept, $jiwa_stateful, $description, $is_default, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorPricingGroupPOSTRequestPricingGroupsPostAsyncWithHttpInfo
     *
     * Creates a new debtor pricing group.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorPricingGroupPOSTRequestPricingGroupsPostAsyncWithHttpInfo($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        $returnType = '\Jiwa\Model\DebtorPricingGroup';
        $request = $this->debtorPricingGroupPOSTRequestPricingGroupsPostRequest($accept, $jiwa_stateful, $description, $is_default, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorPricingGroupPOSTRequestPricingGroupsPost'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $description (optional)
     * @param  bool $is_default (optional)
     * @param  \Jiwa\Model\DebtorPricingGroupPOSTRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorPricingGroupPOSTRequestPricingGroupsPostRequest($accept, $jiwa_stateful = null, $description = null, $is_default = null, $body = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorPricingGroupPOSTRequestPricingGroupsPost'
            );
        }

        $resourcePath = '/Debtors/PricingGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($description !== null) {
            $queryParams['Description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($is_default !== null) {
            $queryParams['IsDefault'] = ObjectSerializer::toQueryValue($is_default);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation debtorSAVERequestSaveGet
     *
     * Saves a stateful debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id debtor_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Jiwa\Model\Debtor
     */
    public function debtorSAVERequestSaveGet($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        list($response) = $this->debtorSAVERequestSaveGetWithHttpInfo($accept, $jiwa_stateful, $debtor_id);
        return $response;
    }

    /**
     * Operation debtorSAVERequestSaveGetWithHttpInfo
     *
     * Saves a stateful debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     *
     * @throws \Jiwa\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Jiwa\Model\Debtor, HTTP status code, HTTP response headers (array of strings)
     */
    public function debtorSAVERequestSaveGetWithHttpInfo($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorSAVERequestSaveGetRequest($accept, $jiwa_stateful, $debtor_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Jiwa\Model\Debtor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation debtorSAVERequestSaveGetAsync
     *
     * Saves a stateful debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorSAVERequestSaveGetAsync($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        return $this->debtorSAVERequestSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful, $debtor_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation debtorSAVERequestSaveGetAsyncWithHttpInfo
     *
     * Saves a stateful debtor.
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function debtorSAVERequestSaveGetAsyncWithHttpInfo($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        $returnType = '\Jiwa\Model\Debtor';
        $request = $this->debtorSAVERequestSaveGetRequest($accept, $jiwa_stateful, $debtor_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'debtorSAVERequestSaveGet'
     *
     * @param  string $accept Accept Header (required)
     * @param  bool $jiwa_stateful Stateful indicator (optional)
     * @param  string $debtor_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function debtorSAVERequestSaveGetRequest($accept, $jiwa_stateful = null, $debtor_id = null)
    {
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling debtorSAVERequestSaveGet'
            );
        }

        $resourcePath = '/Debtors/Save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($debtor_id !== null) {
            $queryParams['DebtorID'] = ObjectSerializer::toQueryValue($debtor_id);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($jiwa_stateful !== null) {
            $headerParams['jiwa-stateful'] = ObjectSerializer::toHeaderValue($jiwa_stateful);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/x-www-form-urlencoded', 'application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
